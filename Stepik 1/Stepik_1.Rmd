---
title: "Основы программирования на R"
author: "Антон Антонов"
output:
  html_document:
    highlight: textmate
    toc: yes
  pdf_document: default
header-includes: \usepackage[english, russian]{babel}
urlcolor: blue
---

```{r setup, include=FALSE}
library(microbenchmark)
knitr::opts_chunk$set(echo = TRUE, cache = T)
```

# 1. Базовые структуры и понятия
## 1.1 Введение в курс
### 1.1.1 Введение
#### Немного об автор курса Антоне Антонове 
* Академическая математика (вычислительные стохастические методы)
* Количественная финансовая математике (алгоритмическая торговля)
* Open source contributions: [github.com/tonytonov](https://github.com/tonytonov)
* StackOverflow: [stackoverflow.com/users/1900149/tonytonov](https://stackoverflow.com/users/1900149/tonytonov)
* St. Petersburg R User Group: [vk.com/spbrug](https://vk.com/spbrug), [meetup.com/St-Petersburg-R-User-Group ](http://meetup.com/St-Petersburg-R-User-Group )

#### Почему R?
* Объемы данных растут
* Это настоящий язык программирования
* Он бесплатен, кроссплатформенный, расширяем, у него огромное сообщество

#### Почему программирование?
Есть два типа знакомства с R:

* Первый тип знакомства с R: обучение конкретным методам
* Второй тип:
    + Как устроены объекты языка?
    + Почему они ведут себя именно так?
    + Как их можно эффективно использовать?
    + Основная цель: ускорить переход от простого к сложному
    
Мы пойдем по **второму пути**!
    
#### Почему "основы"?
* Курс покрывает основные объекты и семантические принципы
* Рассматриваются типичные ошибки и сложности при работе с R
* Материал универсален и не заточен под специфику данных какой-то области

#### Материалы курса
* Все материалы доступны на [https://github.com/tonytonov/Rcourse](github.com/tonytonov/Rcourse)
* Рекомендуемые книги:
    + Norman Matloff "The Art of R Programming"
    + Richard Cotton "Learning R"
    + Hadley Wickham "Advanced R" (после года программирования)
    
#### Рекомендации по прохождению
* Сложность курса возрастает:
    + первая неделя -- "easy"
    + вторая неделя -- "normal"
    + третья неделя -- "hard"
* Задания можно пропускать и возвращаться к ним позже
* Если что-то непонятно, ищите аналогичные темы в справке, книгах и интернете
* Побольше экспериментов!
* Don't give up easily :)

## 1.2 Переменные, глобальное окружение, справка
### 1.2.1 План урока
В этом уроке мы

* узнаем, чем хорош (и не очень хорош) R;
* научимся использовать встроенную справку;
* будем создавать, изменять и удалять переменные в глобальном окружении;
* используем функции с аргументами и без;
* напишем свои собственные функции.

### 1.2.2
#### Что такое R
* R -- язык программирования для научных вычислений и анализ данных с упором на визуализацию и воспроизводимость
* R -- свободное кросс-платформенное программное обеспечение с открытым исходным кодом
* R -- интерпретируемый язык с интерфейсом командной строки (его не нужно компилировать)
* R -- мультипарадигменный язык, сочетающий в себе
    1. функциональное 
    2. процедурное
    3. объектно-ориентированное
    4. рефлексивное программирование
    
#### Плюсы
* R бесплатен, его код открыт
* Огромное количество встроенных статических тестов, математических алгоритмов, функций для анализа данных в академических и отраслевых исследованиях
* Расширяемость: модульная система пакетов (packages)
* Обширное сообщество разработчиков
* Полностью программируемая высокоуровневая графика
* Кросс-платформенность, воспроизводимость результатов
* R становится популярным: статьи, книги, конференции, юзер группы

#### Минусы
* R достаточно сложен как язык программирования
* Документация некоторых методов труднодоступна без глубокого знания математических методов и статистических процедур
* Легко написать плохой (медленный, неподдерживаемый, нечитаемый) код
* Пакеты дополнений устаревают
* Можно заметить некоторую непоследовательность в именовании переменных и реализации методов

#### Помогите, ничего не работает!
* Это нормально
* Внимательно читаем текст ошибок и предупреждений
* Встроенная справка: `help("sin")`, `help.search("logarithm")`
* <https://cran.r-project.org/doc/FAQ/R-FAQ.html>
* Пользуемся поисковыми системами
* R Mailing List Archive
* [stackoverflow.com](https://stackoverflow.com)

### 1.2.3 Задача
В этом тесте отметьте верные утверждения о характеристиках языка R.
Итак, правда ли, что R:

* это язык с проприетарным (закрытым) кодом?
* чрезвычайно прост в освоении?
* создан для коммерческого использования?
* требует компиляции перед исполнением кода?
* **сочетает в себе несколько различных стилей (парадигм) программирования?**
* **это язык с открытым исходным кодом?**

### 1.2.4 Задача

### 1.2.5 Запускаем Rstudio
#### Встроенная справка
```{r}
help("sin")
```

Справка состоит из нескольких частей:

* Description -- описание на человеческом языке
* Details     -- важные детали и подробности
* Value       -- возвращаемое значение
* Examples    -- примеры использования

В `R` одинарные и двойные кавычки **равнозначны**:
```{r}
help('sin')
```

А для некоторых функций можно вообще не указывать имя в кавычках:
```{r}
help(sin)
```

Это правило не работает например для зарезервированных слов:
```{r}
# help(for) # выполнение кода выдаст ошибку
help("for")
```

Вместо функции `help` можно использовать знак вопроса `?`:
```{r}
?sin
```

Ну и если мы хотим спросить что-то "запретное":
```{r}
?"function"
```

Во вкладке `History` появилась история наших действий в консоли. Тут есть поиск, иногда это полезно.

### 1.2.6 Задача
Воодушевлённый предыдущим видео, я решил посмотреть справку по использованию оператора if. 

Что произойдет, если я наберу в консоли 
`?if`
и нажму Enter?

#### Решение
* Справка не откроется, потому что Enter нужно нажать ещё раз.
* **Справка не откроется: if -- зарезервированное слово, которое надо заключать в кавычки.**
* Откроется справка по циклам.
* Откроется справка с перечнем зарезервированных слов.
* Справка не откроется, потому что такого оператора нет, вместо него есть оператор ifelse.
* Следующий шаг Решить снова

### 1.2.7 Задача
В R есть функция, которая реализует алгоритм [быстрого преобразования Фурье](https://en.wikipedia.org/wiki/Fast_Fourier_transform). Круто, да?

Попробуйте найти название этой функции поиском по справке или в google. 

Подсказки:

* Название алгоритма на английском можно узнать по ссылке выше.
* R чувствителен к регистру, то есть функция cos существует, а `COS` или `cOs` -- нет.
* Ответ содержит не более шести символов.

#### Решение
`fft`

### 1.2.8
#### Основы основ
* R -- интерпретируемый язык
* Команды исполняются построчно
* Командная строка расположена во вкладке "Console" в RStudio
```{r}
2 + 1
sin(pi/6)
```

#### Переменные
Нам не очень интересно использовать R как калькулятор. Мы хотим использовать понятия переменной и функции. Начнем с переменных. Чтобы создать переменную необходимо использовать оператор присваивания `<-` (Alt + -).

Обычно в языках программирования оператором присваивания является знак равно `=`. В R он тоже используется, но немного в других случаях.

Предположим, что мы хотим посчитать количество питомце в доме. Создадим две переменные `cats` и `dogs`, а затем их сумму присвоим новой переменной `pets`.
```{r}
cats <- 5
dogs <- 2
pets <- cats + dogs
```

Напечатано ничего не будет, просто сохранится переменная. Проверим, сохранилась ли переменная `pets`. Для этого необходимо просто написать ее имя:
```{r}
pets
```

Не любое имя переменной считается валидным!

#### Глобальное окружение
Поговорим о том месте, где живут созданные нами переменные.

* Каждая переменная определяемая нами живет в собственном *окружении*
* Окружение переменной -- это пространство, где ее можно найти; то место где она считается определенной
* Те переменные, что мы создали ранее, попадают в *глобальное окружение*; это то окружение, которое создается и считается самым широким
* Переменные из глобального окружения доступны во вкладке "Environment" в RStudio
* Либо можно просто ввести команду `ls()` в консоли
```{r}
ls() # list objects
```

#### Вызов функции
Поподробнее остановимся на функциях и их аргументах, как их можно указывать.

В R определено множество встроенных функций, например `rnorm`:
```{r}
?rnorm    # посмотрим на справку по этой функции
rnorm(15) # генерирует 15 случайных чисел из нормального распределения
```

Аргументы функции можно указать по имени, через запятую по правилу ключ --> значение.
```{r}
rnorm(15, mean = 5, sd = 3)
```

На этом примере виден принцип разделение присваивания (`<-` и `=`): если мы указываем значение для переменной, то `<-`, если указываем значение аргумента, то используем оператор `=`.

#### Написание функций
Не всегда мы будем использовать уже существующие функции. Мы захотим использовать свои функции!

Для определения новой функции существует ключевое слово `function`; в круглых скобках *аргументы* функции, в фигурных -- **тело** функции (её код):
```{r}
returnTwo <- function(){
  y <- 2                # переменная, созданная в локальном окружении
  return(y)             # для возвращения переменной
}
```

Использование нашей функции:
```{r}
returnTwo()
```

#### Окружение функции
Локальное окружение (внутри функции) и глобальное окружение (то где эта функция находится) -- разные вещи. 

Напишем функцию, прибавляющую к любому числу поступившему на ее вход 10:
```{r}
addten <- function(x) {
  x <- x + 10
}
```

И применим ее к нашим кошкам (ДА! Больше кошек!):
```{r}
addten(cats)
cats
```

Котиков больше не стало, хнык. Это произошло потому что мы **переприсвоили значение переменной `x` в локальном окружении** и оно не попало в глобальное.

Для того чтобы функция повлияла на глобальное окружение, необходимо пользоваться ключевым словом `return`:
```{r}
morecats <- function(x) {
  return(x + 10)          # просто засунем в return увеличение на 10
}
```

Проверим:
```{r}
morecats(cats)
```

#### Оператор глобального присваивания
Существует оператор **глобального присваивания**, `<<-`. Мы могли бы завести в теле функции новую переменную `moreDogs`, куда бы мы сложили результат прибавления 10 к аргументу `x`. И использую символ `<<-` мы создаем переменную не в локальном окружении, а в глобальном. 
```{r}
addten_2 <- function(x) {
  moreDogs <<- x + 10
}

addten_2(dogs)
dogs            # значение не поменялось, т.к. мы создали переменную в глобальном окружении
moreDogs        # а вот и она, новая переменная
```

Функция обладающие свойством действовать на глобальное окружение называются функциями со *сторонним эффектом* (side effect). 

Но такая практика является сомнительной, ибо дает право функции право менять объекты в глобальном окружении.

#### Удаление переменных из окружения
Давайте проверим состояние глобального окружения, вызовем функцию `ls()`:
```{r}
ls()
```

Вердикт -- надо чистить.
```{r}
rm(dogs)
rm(moreDogs)
ls()
```

Но можно удалить все одним махом%
```{r}
rm(list = ls())
ls()
```

Будьте аккуратны при удалении переменных!

#### Полезное из коментов. 
##### Вопрос про `rm()` vs `qs()`
**Илья Ильюшёнок**
Сталкивался с тем, что `rm()` удаляет переменные из окружения, но в памяти они продолжают занимать место. Недавно узнал о существовании функции `gc()`. Пробовал сочетание `rm(value)` и `gc()` - помогает. Возможно, есть ещё какие-то способы решения этой проблемы?

**Антон Антонов**
Хороший вопрос, спасибо. Вы всё делаете правильно. На самом деле, `rm` действительно не высвобождает память, а просто уничтожает имя переменной. Память освобождается сборщиком мусора, который вызывается либо самим R, либо вручную (`gc` -- garbage collector). Манипулирование памятью в R -- достаточно хитрый механизм, и, строго говоря, даже вызов gc вручную не всегда гарантирует освобождение памяти. Похожий вопрос есть на [stackoverflow](http://stackoverflow.com/questions/1467201/forcing-garbage-collection-to-run-in-r-with-the-gc-command).

### 1.2.9
Самые внимательные зрители могли заметить, что на последнем слайде я указал
?`function`
Зарезервированное слово окружено здесь не одинарными ('function') и не двойными ("function") кавычками, а символами backtick (на моей клавиатуре этот символ расположен на клавише с буквой ё).
Так тоже можно! А вот при работе со строками (на второй неделе) лучше использовать кавычки.

### 1.2.10
Если в функции используется оператор <<-, влияющий на объекты в глобальном окружении, то подобное поведение называется ...

* **сторонним эффектом (side effect)**
* функциональным программированием (functional programming)
* локальным окружением (local environment)
* возвращаемым значением (return value)

### 1.2.11
R может послужить хорошей заменой вашему настольному калькулятору. Например, посчитайте, чему равно значение двоичного логарифма от квадрата синуса арктангенса единицы. 
Подсказки:

Справку по тригонометрии мы вызывали неоднократно.
Я уже упоминал, как найти логарифм. Двоичный логарифм там же. 
Возведение в степень — оператор ^.
Ответ — целое число. 
P.S. Что значит у вас нет настольного калькулятора?!

#### Решение
```{r}
log2(
  sin(
    atan(1)
  )^2
)
```

### 1.2.12
Бытует мнение, что если в скриптах попадаются куски одинакового кода длиной хотя бы в три строки, то надо срочно заводить функцию, а не копипастить одно и то же. Не берусь сказать, что это непреложная истина, но здравое зерно в таком принципе есть.  
Иными словами, пришло время потренироваться в написании функций.  
Напишите функцию, которая принимает на вход два числа и возвращает результат деления первого на второе.  
Оболочку я уже написал, с вас только тело функции.  
P.S. Как будет готово, поэкспериментируйте с вашей функцией: что будет, если вызвать

`divide(1, 0)`  
`divide(-99999, 0)`  
`divide(0, 0)`  
`divide(Inf, Inf)`  

Это тот результат, который вы ожидали?

#### Решение
```{r}
divide <- function(x, y) {
  x / y
}
```
Проверяем:
```{r}
divide(100, 10)
divide(1, 0)
divide(-99999, 0)
divide(0, 0)
divide(Inf, Inf)

```

### 1.2.13 Глоссарий
`?help`, `?help.search`  
`?"<-"`, `?ls`  
`?function`  
`?rm`  
`?rnorm`  

## 1.3 Векторы (часть 1)
### 1.3.1 План урока
В этом уроке мы

* рассмотрим ключевой объект языка -- вектор;
* посмотрим, какие есть удобные возможности для создания численных векторов;
* узнаем про типы векторов и правила их приведения;
* увидим, как действует принцип векторизации.

Вектора и векторизация -- это краеугольный камень языка R и ключ к написанию красивого и эффективного кода. Идеи, которые лежат в основе урока, редко встречаются в других языках программирования, так что будьте внимательны!

### 1.3.2
Представьте себе множество простых чисел от 1 до 100 или все слова английского языка начинающиеся на K. 

Какая структура данных подходит для хранения такого рода объектов?

Разные языки программирования отвечают на этот вопрос по разному.

* Вектор -- самая базовая структура данных в R
* На векторах основаны более сложные структуры (матрицы, список, фактор, дата фрейм)
* Векторизация -- одна из ключевых концепций языка R

$$
f:
\begin{bmatrix}
  x_1 \\
  x_2 \\
  \vdots \\
  x_m
\end{bmatrix}
\longrightarrow
\begin{bmatrix}
  f(x_1) \\
  f(x_2) \\
  \vdots \\
  f(x_m)
\end{bmatrix}
$$

Представим, что у нас есть вектор длины $m$ и мы хотим получить другой вектор, который является результатом применения некоей функции $f$ к каждому элементу вектора. Если бы мы программировали на классическом императивном языке (C, C++), то на пришлось бы сделать следующее:

* завести новую переменную
* указать ее длину (определить количество памяти под нее)
* указать тип
* завести цикл и применить к каждому элементу $x_i$ функцию $f$
* записать результат в конечный вектор

Так вот, для того, чтобы сделать тоже самое в R чаще всего придется написать $f(x)$ и все. И все эти действия будут произведены автоматически. 

#### Вектор
* Вектор -- **индексированный** набор данных **одного типа**
* R не делает различия между скалярными и векторными величинами, т.е. скаляр -- это вектор длины 1
* Индексация векторов начинается с единицы (не с нуля!)
* Для создания вектора можно использовать функцию `vector`

Как бы мы сделали в обычном язык:
```{r}
x <- vector(length = 2) # задали длину ветора и его имя
x[1] <- 5               # задали первое значение
x[2] <- 8               # задали второе значение
x                       # вывели на экран
```

Но в R такая запись излишня (хотя и является абсолютно корректной).

#### Создание векторов: функция `c`
Вместо поэлементного присваивания используют компактную запись:
```{r}
x <- c(5, 8)
x
```

Функция `c` может быть вложенной и принимать переменные, и количество этих переменных может быть не ограничено:
```{r}
y <- c(x, 1, c(3, 4), x, NA)
y
```

#### Создание векторов: оператор `:`
Применение функции `с` требует перечисления всех элементов будущего вектора. Очень часто бывает так, что нам необходимо создать числовую последовательность с шагом 1.

Вот для создания такого рода последовательностей в `R` существует оператор двоеточие `:`:
```{r}
5:9
3:-1
1:pi    # именно челочисленный шаг
pi:1    # именно челочисленный шаг
```

#### Создание векторов: функция `seq`
Для создания последовательностей с шагом отличным от единицы:
```{r}
seq(1, 2, by = 0.25)       # от 1 до 2 с шагом 0.25
seq(3, 4, length.out = 5)  # от 3 до 4 с длиной вектора 5, шаг вычисляется автоматически
seq(3, 4, length = 5)      # не обязательно указывать имя аргумента целиком, достаточно тольуо уникального префикса

```

#### Создание векторов: функция `rep`
Повторение векторов
```{r}
rep(1:3, times = 3)       # повтор вектора три раза
rep(1:3, each = 3)        # повтор каждого элемента вектора три раза
rep(1:3, length.out = 5)  # для нецелого кол-ва повторений
```

### 1.3.3 Задача
В R существует множество операторов, как бинарных (требующих двух аргументов, например, `*`), так и унарных (требующих одного аргумента, например, `?`). Сопоставьте следующие бинарные операторы языка с их названиями.

К слову, приоритет операторов (порядок их действия) описан в справке `?Syntax`.

#### Ответы
* `<-`  -- Оператор присваивания
* `<<-` -- Оператор глобального присваивания
* `<=`  -- Меньше либо равно
* `^`   -- Возведение в степень
* `:`   -- Создание числовых векторов с шагом 1
* `/`   -- Деление

### 1.3.4 Задача
Концепция *векторизации* подразумевает, что

#### Ответы
* при создании вектора не нужно указывать его тип.
* **некоторые функции и операторы действуют поэлементно.**
* для операций с векторами необходимо использовать циклы в явном виде.
* вместо поэлементного присваивания можно воспользоваться функцией c.
* индексация векторов начинается с единицы.

### 1.3.5 Решение задач
#### Традиции, традиции
```{r}
hello <- "Hello, world"   # в глобальном окружении сразу появилась переменная hello
print(hello)              # распечатаем
hello                     # в консоли работает и так; но есди мы в batch режиме то только через print
```

#### Трудности перевода
```{r}
c(1, 3, 5)   # нужно быть осторожным, чтобы не спутать раскладку клавиатуры
```

#### Особенность чисел double (плавающая точка):
```{r}
0.1 + 0.1 == 0.2    # выдаст TRUE
0.1 + 0.05 == 0.15  # выдаст FALSE
```
Числа с плавающей точкой хранятся особым образом, поэтому оператор двойного равенства здесь неуместен.

Для того чтобы корректно сравнивать числа `double`, нужна функция `all.equal()`, она сравнивает числа с некоторой точностью:
```{r}
all.equal(0.1 + 0.05, 0.15)
```

Эта особенность очень хорошо задокументировано:

* R FAQ 7.31
* google "R why are these numbers not equal"
* <https://stackoverflow.com/questions/9508518/why-are-these-numbers-not-equal>

#### Задача
Мы хотим создать вектор от 0 до 1, который содержит в себе все трети и все седьмые части; а так же этот вектор нужно упорядочить по возрастанию:
```{r}
u <- seq(0, 1, 1/3) # трети
v <- seq(0, 1, 1/7) # седьмые
w <- sort(c(u, v))  # сортировка
unique(w)           # убираем повторы
```

### 1.3.6 Задача
Вместе мы решили задачу про 1/3 и 1/7. Напишите функцию `get_fractions`, которая принимает на вход два числа, m и n, и возвращает аналогичный вектор, содержащий все дроби вида {i/m, i = 0, 1, ..., m} и  {j/n, j = 0, 1, ..., n}. Вектор не должен содержать повторов. И -- сюжетный поворот -- должен быть упорядочен в порядке убывания.

Подсказки: 

проверить функцию можно подстановкой m=3, n=7: должен получиться вектор из моего примера, только задом наперёд;
в R огромное количество функций, а у многих функций есть вспомогательные аргументы.

#### Решение
```{r}
get_fractions <- function(m, n) {
  a <- seq(0, 1, 1/m)
  b <- seq(0, 1, 1/n)
  sort(unique(c(a, b)), decreasing = T) # лучше сначала избавиться от лишних и только потом упорядочить
}
get_fractions(3, 7)
```

#### Подглядел в ответах
```{r}
get_fractions_2 <- function(m, n) {
    sort(unique(c(0:m/m, 0:n/n)), d = T) # помним, что : главнее /
}
get_fractions_2(3, 7)
```

### 1.3.7 Типы векторов
#### Типы векторов
Вектор это структура, которая может содержать данные только одного типа

Основные типы:

1. **logical** (TRUE/FALSE)
2. **integer** (целые числа)
3. **numeric/double** (числа с плавающей точкой)
4. **complex** (комплексные числа)
5. **character** (строки)
6. **raw** (байтовые последовательности)

Для определения типа вектора есть функция `typeof` и `is.*` (где `*` обозначает любой из типов):
```{r}
a <- c("Дуб", "Дерево", "Воробей")
typeof(a)
is.character(a)
is.logical(a)
```

#### Приведение типов
Естественным считается приведение слева направо по цепочке:

<center>logical --- integer --- double --- character</center>

```{r}
b <- c(FALSE, 1.5)
typeof(b)
b <- c(5, b, "abc")
typeof(b)
b
```

#### Принудительное приведение типов
Принудительное приведение типов осуществляется функциями `as.*`:
```{r}
# as.double(b) # или
as.numeric(b)  # 
as.integer(b)
```

#### Длина вектора: `length`
Помимо типа у любого вектора есть длина:
```{r}
x <- 1:100
length(x)
```

Длина определяется автоматически, но ее можно принудительно менять:
```{r}
length(x) <- 4; x # команды в одной строке нужно разделять точкой с запятой
length(x) <- 7; x
```

#### Именованые вектора
Для того, чтобы именовать вектор, нужно воспользоваться одним из двух способов:

##### 1. Имя = Значение как аргумент функции  `c`
```{r}
a <- c(uno = 1, dos = 2, "universal answer" = 42, 99) # у 42 в имени есть пробел - его в кавычки заключаем
names(a) # вызов имен 
```

##### 2. Переприсвоить вектору `names` другие значения имен
```{r}
names(a) <- c("one", "two", "forty two", "ninty nine") 
a
```

Чтобы избавиться от вектора имен, нужно присвоить `names(a)` пустоту или `NULL`
```{r eval = F}
names(a) <- NULL
```

#### Векторная арифментика
Арифметические операторы *векторизованы* (применяются поэлементно):
```{r}
1:3 + c(-1, 2, 0)
1:3 * c(-1, 2, 0)
c(T, T, T) & c(0, 1, 999)  # все что не ноль - это TRUE
```

#### Векторизация
Многие функции в R имеют встроенную поддержку векторизации:
```{r}
# векторизована
sqrt(1:4)
# векторизована
floor(seq(0, 3, by = 0.25)) # округление вниз до ближайщего целого
# не векторизована
sum(1:100)
```

### 1.3.8 Задача
К этому времени вы уже достаточно знаете про типы векторов и без труда укажете иерархию среди четырёх основных типов, выстроив их в порядке сверху вниз от самого "узкого" к самому "широкому".

* Логический (logical)
* Целочисленный (integer)
* Числа с плавающей точкой (numeric/double)
* Строковый (character)

### 1.3.9 Задача
Давайте экспериментировать с типами! Функции семейства `as.*` дают возможность устраивать форменные безобразия. Установите соответствие между вызовами слева и результатами справа.
Попробуйте пройти это задание, не пользуясь консолью `R`. 

* `1:1` -- `-1 0 1`
* `as.logical(-1:1)` -- `TRUE FALSE TRUE`
* `as.character(as.logical(-1:1))` -- `"TRUE" "FALSE" "TRUE"`
* `as.numeric(as.logical(-1:1))` -- `1 0 1`
* `as.character(as.numeric(as.logical(-1:1)))` -- `"1" "0" "1"`
* `as.numeric(as.character(as.logical(-1:1))` -- `NA NA NA`

### 1.3.9 Задача
Я упоминал, что большинство имён из букв и цифр в R являются валидными, то есть такими, которые можно использовать в качестве имён переменных или имён `names()` в векторах. Попробуйте придумать способ, с помощью которого можно проверять валидность имени и с его помощью отметьте только валидные имена из предложенного списка.

P.S. Строго описанные правила именования есть в R FAQ и на stackoverflow. Кто ищёт, тот всегда найдёт!

P.P.S. Пожалуйста, никогда не именуйте переменные похожим образом. Это учебный пример!

* next
* :smiley:
* **super_long_name_in_fact_so_long_i_cannot_stop_typing_please_help**
* **.hidden**
* 2b.or.not.2b
* function
* **xXx_TerM1Nat0R_xXx**

Искать надо *r variable naming rules*, найдется подобное:
* [R FAQ 7.14](http://cran.r-project.org/doc/FAQ/R-FAQ.html#What-are-valid-names_003f)
* [stackoverflow](https://stackoverflow.com/questions/9195718/variable-name-restrictions-in-r)

А еще можно использовать функцию `exists()`:
```{r}
exists('for')
exists('myvariable')
```

Либо проверять по списку зарезервированных слов:

* `if` `else` `repeat` `while` `function` `for` `in` `next` `break`
* `TRUE` `FALSE` `NULL` `Inf` `NaN` `NA` `NA_integer_` `NA_real_` `NA_complex_` `NA_character_`

### 1.3.11 Глоссарий
`?c`, `?":"`
`?seq`, `?rep`
`?print`
`?all.equal`
`?typeof`
`?is.logical`, `?as.logical`, etc.
`?length`, `?names`

## 1.4 Управляющие конструкции, работа с пакетами
### 1.4.1 План урока
В этом уроке мы

* рассмотрим условные операторы и циклы;
* ужаснёмся, как легко "повесить" R, если забыть о векторизации;
* перестанем называть пакеты библиотеками;
* узнаем об установке и поддержке пакетов.

Условия и циклы всегда так или иначе присутствуют в реализациях хоть сколько-нибудь сложных алгоритмов. Для того, чтобы в этом убедиться, достаточно посмотреть в исходный код популярных пакетов. Вы ведь не успели забыть, что исходный код R и всех его пакетов полностью открыт?

### 1.4.2 
#### Конструкция `if` и `else`
Управляющие конструкции в R сильно похожи на управляющие конструкции других языках.

`if (<condition>) {<do something>} else {<do another thing>}`

* Здесь \<condition\> -- это выражение, результатом которого будет логический вектор длины 1 (`TRUE` или `FALSE`; `NA` приведет к ошибке)
* \<do something\> и \<do something else\> -- произвольные команды
```{r}
if (sqrt(2) > 1.5) {
  print("Greather!")
} else {
  print("Less!")
  
}
```

Переносить `else` на следующую строчку **нельзя**!

#### Конструкция `ifelse`
А давайте поставим в условие вектор длиною больше 1:
```{r}
if (c(T, F)) print("Hmm...?")
```

И что тогда делать, если нам нужно проверить условие на целом векторе? Именно для этого и существует `ifelse`:
```{r}
ifelse(runif(8) > 0.5, "Орел", "Решка") # 
```

А если есть несколько условий?
```{r}
x <- runif(8)
ifelse(x > 2/3, "Камень",
       ifelse(x > 1/3, "Ножницы", "Бумага"))
```

#### Множественный выбор: `switch`
```{r}
switch("factorial",                 # строка на входе
       sum = 5 + 5,
       product = 5 * 5,
       factorial = factorial(5),
       0)
```

Используется очень редко!

#### Циклы: `repeat`
```{r}
i <- 0                # задаем начальное значение
repeat {
  i <- i + runif(1)   # прибавляем случайную величину от 0 до 1
  print(i)            # печатаем ее
  if (i > 5) break    # условие на выход
}
```

#### Циклы: `while`
```{r}
i <- 2^14
while (i > 1000) {   # отличие от repeat - тут условие в начале
  i <- i/2
  print(i)
}
```

Цикл `repeat` -- может быть выполнен хотя бы один раз, а `while` может и не разу.

#### Циклы: `for`
Синтаксис простой
```{r}
for (i in 1:10) {
  if (i %% 2 == 0) print(i) # %% - остатоr от деления
}
```

Пример с `next` и `break`
```{r}
for (i in letters) {
  if (i == "b") next
  if (i == "d") break
  print(i)
}
```

Внутри цикла необходимо **принудительно** вызывать `print` для распечатывания переменной!

#### `for` против векторизации
При неверном использовании цикла `for` можно буквально в две строчки написать громоздкий и неэффективный код.

Нам нужно посчитать квадратные корни чисел от 1 до 10 000 000:
```{r}
v <- 1:1e7
t_x <- system.time({
  x <- 0                           # не указана длина результата 
  for (i in v) x[i] <- sqrt(v[i])
})
t_x
```

Почти `r round(t_x[3])` секунд. Это очень медленно. 
```{r}
t_y <- system.time({
  y <- sqrt(v)
})
t_y
```

А если использовать **силу векторизации ** то выйдет всего `r t_y[3]` секунды!

Проверим идентичность результатов:
```{r}
identical(x, y)
```

### 1.4.3 Задача
Если утверждение верное, поставьте галочку. Впрочем, это лишняя информация, смысл задания и так понятен.

* **ifelse -- это векторизованный вариант if.**
* %% -- это оператор целочисленного деления (integer division).
* Синтаксис цикла for зависит от типа вектора в условии.
* **Не стоит использовать цикл for, если есть возможность использовать векторизацию.**
* В цикле if можно переносить условие else на новую строку.

### 1.4.4 Задача
Выполните в своей сессии следующие команды (про функцию set.seed я расскажу чуть далее):

`set.seed(1337)`
`x <- runif(1e6, min = -1, max = 1)`

Теперь в вашем распоряжении вектор x длиной один миллион. Мне крайне интересно, сколько среди них чисел в диапазоне (-0.2, 0.3). Для определённости не включая границы интервала. Впрочем, кто знаком с теорией вероятностей, тот знает, что это уточнение несущественно.

P.S. Задача-то простецкая вышла: всегда можно распечатать x на принтере и посчитать вручную.
```{r}
set.seed(1337)
x <- runif(1e6, min = -1, max = 1)
y1 <- length(x[x > -0.2 & x < 0.3])
# или
y2 <- sum(ifelse(x > -0.2 & x < 0.3, 1, 0))
# чужое
y3 <- table(x > -0.2 & x < 0.3)
y4 <- sum(x > -0.2 & x < 0.3)

# проверка на быстроту
microbenchmark(y1, y2, y3, y4, times = 1000) # т.к. все ф-ии из base - скорость одинаковая
```

### 1.4.5 Задача
Вам не нравятся ни монетка, ни "камни-ножницы-бумага"? Хорошо, давайте играть в "Монополию", только у меня нет кубика. Напишите его сами!

Функция `dice_roll(n)` должна выдавать n независимых бросков игрального кубика. Допустимые значения, разумеется, в диапазоне от 1 до 6.

Только учтите, что если кубик нечестный (не все грани выпадают с равной вероятностью), я это проверю и играть с вами не сяду!

```{r}
dice_roll <- function(n) {
  ceiling(runif(n, min = 0, max = 6))
}
table(dice_roll(100))         # table - удобно смотреть кол-во выпавших граней

# Улучшенный вариант, но такую функцию еще не проходили
dice_roll_2 <- function(n) {
  sample(6, size = n, replace = T)
}
table(dice_roll_2(100))
```

### 1.4.6 Пакеты
* R проектировался как расширяемый и модульный язык модульный язык, где каждый модуль обладает логичной и завершенной функциональностью. Такая единица называется **пакетом**. 
* Даже ядро языка -- это пакет `base`
* Вместе с `base` поставляется несколько пакетов, часть из которых уже подключена в сессии, а остальные можно подключать без необходимости установки.
* Неправильно называть пакет (`package`) библиотекой (`library`)!
* Еще раз: модули расширений для R называются пакетами!
* Библиотека (в контексте экосистемы R) -- это место на диске, где хранятся доступный пакеты

```{r}
.libPaths()
```

#### Пакеты (packages)
* CRAN (Comprehensive R Archive Network): <https://cran.r-project.org> -- центральный репозиторий
* GitHub, bitbucket

```{r, eval = FALSE}
installed.packages()
```

```{r, echo = FALSE}
i <- as.data.frame(installed.packages())      # переводим в датафрейм
i <- na.omit(i[, c("Package", "Priority")])   # оставляем только две переменные и удаляем в них NA
i[i$Priority == "base", ]                     # оставляем только base
```

#### Подключение пакетов

```{r fig.height = 3, fig.width = 3, fig.align = 'center'}
library(grid)      # функция ображается к библиотеке и подключает пакет
grid.newpage()
grid.lines()
```

* `library(pkgname)`: можно писать название пакета без кавычек
* Вместо `library(pkgname)` можно использовать `require(pkgname)`; отличие вот в чем, если пакета в системе нет то при вызове `library(pkgname)` выведется ошибка, а при вызове `require(pkgname)` будет возвращено значение `FLASE`

#### Установка пакетов из CRAN
```{r, eval=FALSE}
install.packages("xts", dependencies = T) # обязательно в кавычках; пакет для работы с временными рядами
```

```{r, message=F, warning=F}
library(xts)    # а тут можно без кавычек
```

Обновление пакетов: `update.packages()`.
Крайне полезная функция для случая, если какие-то пакеты не работают как надо: `sessionInfo()`:
```{r echo=F}
sessionInfo()
```

### 1.4.7 Задача
Давайте проверим, что вы можете устанавливать пакеты. Если в какой-то момент что-то пойдёт не так, обращайтесь к R FAQ (раздел 6.3) либо ищите в google по запросам с текстом ошибок.

Установите и подключите пакет под названием randtoolbox. У вас должно появиться сообщение

This is randtoolbox. For ???, type 'help("randtoolbox")'.

Какое слово я замаскировал? 

#### Ответ
`overview`

### 1.4.8 Задача
Я уже говорил, что некоторые пакеты зависят друг от друга. Таким образом, все пакеты в CRAN выстраиваются в дерево зависимостей (поглядеть на этого монстра можно здесь). Все имеющиеся зависимости для каждого пакета хранятся в специальном файле под названием DESCRIPTION.

Чтобы получить справку по пакету целиком, можно воспользоваться командой вида

`help(package = "xts")`

Первая ссылка в списке и есть DESCRIPTION. В поле Depends указаны те пакеты, без которых данный пакет работать не будет.

Пакет stats поставляется вместе с R, а в CRAN есть пакеты quantmod, xts и zoo. Установите недостающие пакеты, подключите их и, пользуясь полем Depends?, укажите иерархию зависимостей этих пакетов друг от друга, начиная с самого "независимого".

### 1.4.9 Задача
Поизучайте повнимательнее вывод функции sessionInfo(). Что он содержит?

* **Подключённые пакеты, поставляемые с base**
* Температуру процессора
* **Пакеты, подключённые пользователем**
* Стоимость барреля нефти марки Brent в USD
* **Тип архитектуры платформы (32-bit, 64-bit)**
* **Версию языка R**
* **Название операционной системы**
* **Название локали для отображения текста ошибок и сообщений**

### 1.4.10 Глоссарий
* `?if`, `?ifelse`, `?switch`
* `?Logic`
* `?repeat`, `?while`, `?for`
* `?installed.packages`, `?library`, `?require`
* `?install.packages`, `?update.packages`
* `?sessionInfo`

## 1.5 Векторы (часть 2)
### 1.5.1
В этом уроке мы

* рассмотрим правила переписывания для векторов;
* перечислим типы индексирования;
* познакомимся с эффективными приёмами доступа и замены элементов вектора;
* вместе решим несколько хитрых упражнений.

Это ключевой урок на первой неделе: здесь я рассказываю о том, как сделать работу с векторами проще и приятнее. А ещё здесь больше всего очков. Сюда можно возвращаться в течение всего курса за полезными функциями и примерами использования.

### 1.5.2
#### Правила переписывания (recycling)
Мы уже видели, что арифметика на векторах одинаковой длины работает должным образом. 

Как работает арифметика на векторах разной длины?

1. Длина результата равна длине большего из векторов
2. Меньший вектор дублируется (переписывается) несколько раз, чтобы длина переписанного вектора совпала с длиной большего
3. Если длина большего вектора не делится нацело на длину меньшего, то выдается предупреждение

```{r}
1:5 + 0:1
# recycling in action (1, 2, 3, 4, 5) + (0, 1, 0, 1, 0) => (1, 3, 3, 5, 5)
```

Но зачем это нужно?

Чаще всего для операций с векторами, одним длины n и единичного:
```{r}
1:10 + 3    # прибавляем к числа от 1 до 10 тройку
```

```{r}
(5:8)^2    # возведем в квадрат все целые числа от 5 до 8; помним о приоритете операторов!!!
```

```{r}
1:4 >= 3    # логический оператор
```

#### Доступ к элемента вектора
Рассмотрим простой вектор:
```{r}
x <- seq(10, 100, by = 10)
```

Чтение и запись элементов осуществляется при помощи оператора `[`:
```{r eval=F}
x[ind]           # печать элемента вектора x с индексом ind
val <- x[ind]    # заведение новой переменной с присваиванием
x[ind] <- val    # замена элемента вектра неким значением
```

Для аргумента `ind` есть несколько правил. Тривиальный случай:
```{r}
x[]    # его отсутствие; на печать пойдет весь вектор
```

#### Положительное индексирование
"Элементы с порядковыми номерами":
```{r}
x[1]
x[3:4]                      # индексирование работает с векторами
x[c(8, 7, 3, 6:8, x[1])]    # можно создавать индексы налету; рекурсия разрешена 
```

#### Отрицательное индексирование
"Все элементы, кроме указанных":
```{r}
x[-5]
x[-(2:6)]
x[c(-3, -5, -length(x), -5)]    # можно повторять индексы
```

#### Логические индексы
"Элементы, соответствующие значению `TRUE`":
```{r}
x[rep(c(T, F), 5)]    # возвращаем все НЕчетные элементы вектора
x[c(T, F)]            # так короче; спасибо рпавилу переписывания
x[x > 77 & x < 99]
```

#### Индексация по имени
Для именованых векторов работают конструкции типа:
```{r}
a[c("two", "one", "forty two")]
```

```{r}
a[c("forty two", "forty three", "forty four")] # при обращении к несуществующим элементам ошибки не будет
```

#### Функции `all` и `any`
Рассмотрим несколько полезных функций при работе с векторами
```{r}
all(x < 200); all(x >20) # проверка всех элементов вектора
```

```{r}
any(x > 150); any(x < 15)    # хотя бы один элемент удовлетворяющий условию
```

#### Функция `which`
Что если нас интересуют не сами элементы, а их позиции (индексы)? Для этого можно воспользоваться функцией `which`. В качестве аргумента укажем интересующее нас условие. И мы получим порядковый номер элементов с пятого по десятый:
```{r}
which(x >= 50)
```

И еще пара функций:
```{r}
which.min(x)
which.max(x)
```

#### Атрибуты объектов
* `length` -- это "свойство" объекта, оно есть всегда
* *Атрибуты* (`names`, `dimnames`, `dim`, ...) могут присутствовать, если это необходимо
```{r}
x <- c(5, 3, 9)
names(x) <- c("V", "III", "IX")
```

```{r}
attr(x, "author") <- "Ceasar"  # создаем новый атоибут
attributes(x)                  # показывает все доступные атрибуты вектора х
```
Удалить атрибуты так же легко:
```{r}
attributes(x) <- NULL  # сам вектор х не пострадает
attributes(x)
```

### 1.5.3 Задача
Чем больше вы знаете разнообразных функций для работы с векторами, тем больше существует вариантов для решения простых задач. Пусть имеется вектор x произвольного типа. Какая конструкция может быть использована, чтобы получить содержимое вектора x без каждого седьмого элемента?

P.S. Давайте предполагать, что понятие "каждый седьмой" имеет смысл, то есть элементов в векторе хотя бы семь.

#### Ответы (подходят все)
* x[1:length(x) %% 7 > 0]
* x[1:length(x) %% 7 != 0]
* x[-(seq(7, length(x), by = 7))]
* x[-(1:floor(length(x)/7) * 7)]
* x[c(rep(T, 6), F)]

### 1.5.4 Задача
Я дал целый набор функций для работы с векторами, и некоторые названия похожи, а функции могут быть принципиально разными. Чтобы не запутаться, давайте наведём порядок. 

Строки -- высказывания о функциях, столбцы -- сами функции. Если сразу ответить трудно, поэкспериментируйте в консоли на каких-нибудь простых векторах.

Подсказки: 

* Есть ли отношения вида "больше-меньше" для строкового типа? Оказывается, да: строки можно упорядочить в так называемом лексикографическом порядке. Поэтому "самая большая строка" -- это не значит самая длинная, это последняя в упорядоченном наборе строк.
* Векторизованность в самом широком смысле означает поэлементное действие: функция f векторизована, если f(v) есть результат применения f к каждому элементу вектора v. Это не всегда означает, что длина результата равна длине v.
* Вот набор векторов, на котором можно попробовать действие функций:
```{r eval = F}
5
1:10
22:19
c("A", "BBB", "Z")
c("1", "99", "HI")
c(TRUE, FALSE)
```

#### Ответ
|Rows|max|which|which.max|
|----------------------------------------------------|:------:|:------:|:------:|
|Предназначена только для логического типа векторов|нет|**да**|нет|
|Совместима с числовым, логическим и строковым типом (для строкового типа нет неявного приведения, т.е. результат также имеет строковый тип)|**да**|нет|нет|
|Длина результата может быть больше единицы (т.е. результат -- вектор произвольной длины)|нет|**да**|нет|
|Совместима с числовым, логическим и строковым типом (для строкового типа производится попытка приведения к числовому типу; если это удаётся, то результат имеет числовой тип)|нет|нет|**да**|

### 1.5.5 Задача
Сложнейший вопрос: если в R сложить два вектора, имеющих длину 4 и 6, то результат будет вектором длины ...

#### Ответ
* 4
* **6**
* 24
* ошибка: арифметика на векторах разной длины недопустима
* 12 

### 1.5.6
Теперь, вооружившись знаниями о векторах в R мы можем решать более сложные задачи. 

Одна из классических задач *fizz-buzz*: необходимо распечатать все числа от 1 до 100 при этом заменив каждое третье число словом *fizz*, каждое пятое словом *buzz*, а если число делится на 15 то на слово *fizz-buzz*.

Для начала решим задачу в *императивном* стиле, без использования векторизации:
```{r}
y <- vector(mode = "character", length = 100)    # создадим пустой вектор; он будет состоять из строк
y <- character(100)                              # более короткая запись приедыдущей командв
# пройдемся по вектору с помощью цикла for
for (i in 1:100) {
  if (i %% 15 == 0) {
    y[i] <- "fizz buzz"
  } else if (i %% 3 == 0){
    y[i] <- "fizz"
  } else if (i %% 5 == 0){
    y[i] <- "buzz"
  } else {
    y[i] <- i
  }
}
y
```

а теперь напишем скрипт используя возможности векторизации, автоматическое приведение векторов:
```{r}
# Заведем два вектора
x <- 1:100
z <- 1:100
# x %% 5 # вернет вектор остатков от длеения всех элементов вектора х на 5
# x %% 5 == 0 # выбираем только те элементы, которые равны нулю; каждый пятый элемент будет равен TRUE
z[x %% 5 == 0] <- "buzz"    # заметим, что численный вектор z приаелся к строковому вектору
z[x %% 3 == 0] <- "fizz"
z[x %% 15 == 0] <- "fizz buzz"
```

А теперь сравним результаты, полученные первым и вторым способом:
```{r}
all(y == z)
```

#### Примечания из комментарием
Для создания индекса могут быть полезны функции `seq_along` (создаёт вектор 1:n для объекта x) и `seq_len` (создаёт аналогичный вектор, но в качестве аргументы принимает конечную длину). В векторизованном решении это избавляет нас от необходимости держать индекс в отдельной переменной.

К этим двоим можно добавить и `seq.int`

### 1.5.7 Задача
Я зашифровал для вас послание. Вот оно:

1, 23, 5, 19, 15, 13, 5

Один из встроенных массивов, о котором я упоминал в лекциях, поможет вам расшифровать эпитет, применимый к языку R. Регистр неважен.

#### Ответ
```{r}
paste(letters[c(1, 23, 5, 19, 15, 13, 5)], collapse = "")
```

### 1.5.7 Задача
Ранее мы решали задачу про трети и седьмые части, и там мы использовали функцию  `seq`, чтобы создать вектор. Ниже показано как сделать это гораздо проще:
```{r}
(0:7)/7     # нам снова помогли правила переписывания
```

#### Геометрическая прогрессия
```{r}
x <- 2^(0:10)
x
log2(x)      # проверяем правильность
```

#### Добавим элемент случайности
```{r}
set.seed(42)           # настройка случайного генератора
x <- sample(1:100, 50) # выбираем 50 случайных чисел из чисел от 1 до 100
```

Создание случайных наборов полезно для тестирования и отладки своих функций. 

#### Небольшая задача
Мы хотим найти в нашем векторе x два соседних числа отличающиеся на максимальную величину.

Для начала нам надо создать вектор со всеми попарными разницами.
```{r}
x[-1]                                      # наш вектор без первого элемента
x[-length(x)]                              # наш вектор без последнего элемента
x[-1] - x[-length(x)]                      # тот самый вектор разниц
abs(x[-1] - x[-length(x)])                 # находим модуль этого вектора
k <- which.max(abs(x[-1] - x[-length(x)])) # присваиваем переменной номер искомого первого элемента
x[c(k, k + 1)]                             # выводим двух соседов с максимальной разницей в значении
```

#### Многоразовые min/max
А что, если у нас есть несколько таких значений в векторе?
```{r}
set.seed(42)
x <- sample(1:100, 50, replace = T); x # добавляем повторы
min(x)                                 # выдает только один ээлемент, но он в векторе повторяется несколько раз
which.min(x)                           # выдаст только первое вхождение
which(x == min(x))                     
```

**ВАЖНО**: вспоминаем об опасности оператора `==` при работе с Не целочисленными значениями!

#### Создадим функцию для решения задачи
```{r}
maxdiff <- function(x) {
  y <- abs(x[-1] - x[-length(x)])
  # y <- abs(diff(x))                   # бонус из комментов
  k <- which(y == max(y))
  print("First neighbour(s):")
  print(x[k])
  print("Second neighbour(s):")
  print(x[k + 1])
  print("Maximum absolute diff is:")
  print(max(y))
}
```

А теперь проверим нашу функцию на нескольких векторах
```{r}
xx <- sample(1:100, 1e4, replace = T)
maxdiff(xx)
```

#### олезности из коментов
Функция `diff` как раз реализует нахождение лага между элементами вектора. Таким образом строчку `y <- abs(x[-1] - x[-length(x)])` можно заменить на `y <- abs(diff(x))`.

### 1.5.9 Задача
Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в нём не меньше, чем предыдущий. Точно так же, вектор назовём нестрого убывающим, если каждый следующий элемент в нём не больше, чем предыдущий. Напишите функцию, которая принимает один аргумент (числовой вектор) и возвращает TRUE, если вектор обладает свойством нестрогой монотонности, то есть является либо нестрого возрастающим, либо нестрого убывающим. В противном случае функция возвращает FALSE.

Пример. x=c(0, 0, 3, 4, 4, 8) нестрого возрастает, возвращаем TRUE. y=c(3:0, 1) был бы нестрого убывающим, если бы не последняя единица, поэтому возвращаем FALSE.

Подсказки: 

* "Не меньше" = "больше либо равно".
* обратите внимание на постоянный вектор, например rep(0, 10). Является ли он нестрого возрастающим? А нестрого убывающим?

#### Решение
```{r}
lessgross <- function(x) {
  all(diff(x)<= 0) | all(diff(x)>= 0)
}
```

##### Проверка
```{r}
lessgross(c(0, 0, 3, 4, 4, 8))
lessgross(c(0, 2, 5, 4, 4, 8))
```

### 1.5.10 Задача
Четыре способа индексирования векторов -- это как времена года: какие-то мы любим больше, какие-то меньше, но они все равноправны. Сопоставьте перечисленные способы и наиболее подходящие к ним характеристики.

P.S. Желающие могут включить Вивальди.

#### Ответ
* **Логическое** -- Единственный способ, для которого работают правила переписывания
* **По именам** -- Способ, при котором отсутствие совпадения ведёт к созданию NA
* **Положительное** -- Способ целочисленного индексирования, для которого длина результата всегда равна длине индекса
* **Отрицательное** -- Способ целочисленного индексирования, для которого длина результата редко когда равна длине индекса

### 1.5.11 Задача
Разбавим курс ложечкой комбинаторики. Пусть у нас есть n предметов, из которых нужно выбрать k штук. Известнейшая комбинаторная формула $C^k_n=\frac{n!}{k!(n-k)!}$ (["Цэ из эн по ка"](https://en.wikipedia.org/wiki/Combination)) задаёт количество всевозможных *сочетаний*. Похожий вид имеет и количество сочетаний с *повторениями* (мультикомбинаций).

Запрограммируйте оба этих значения в виде функции, зависящей от n и k. Аргумент with_repetitions будет отвечать за вариант подсчёта: если он FALSE, то пусть считается количество сочетаний, а если TRUE, то сочетаний с повторениями.

Подсказки:

* если вам необходима вспомогательная функция, её также можно определить. Назовите её как угодно.
* в имеющейся декларации функции `combin_count` указано `with_repetitions = FALSE`. Это аргумент по умолчанию: оно будет подставлено, если вызвать функцию без указания `with_repetitions`, т.е. `combin_count(10, 5)` в точности эквивалентно `combin_count(10, 5, FALSE)`.
* подсчёт факториалов "в лоб" сопряжён с опасностью переполнения целочисленного типа. В данном случае я не буду проверять корректную работу при больших значениях n, оставим этот аспект за скобками.
* если вы не знаете, как считать число сочетаний с повторениями, обратитесь к [Википедии](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%87%D0%B5%D1%82%D0%B0%D0%BD%D0%B8%D0%B5).

#### Решение
```{r}
combin_count <- function(n, k, with_repetitions = F) {
  if (with_repetitions) {
    factorial(n + k - 1) / (factorial(k) * factorial(n - 1))
    } else {
    factorial(n) / (factorial(k) * factorial(n - k))
  }
}
```

#### Решение из коментов
```{r}
combin_count_2 <- function(n, k, with_repretitions = FALSE) {
    ifelse(with_repretitions, choose(n + k - 1, k), choose(n, k))
}
```

Тут использовалась функция `choose`.

### 1.5.12 Задача
Пришло время подвести итоги первой недели. В этом списке отметьте пройденные объекты, темы и понятия.

Если ответ не сходится, значит, вы что-то пропустили! 

* **Правила переписывания**
* Матрица, список
* **Глобальное и локальное окружение**
* **Основные типы векторов**
* Generic функции
* Функции семейства apply
* **Вектор, функция** 

### 1.5.13 Глоссарий
* Recycling rules
* `?"+"`, `?Arithmetic`, `?"["`
* `?all`, `?any`
* `?which`, `?which.min`, `?which.max`
* `?attributes`
* `?sample`, `?runif`

# 2. Продвинутые структуры
## 2.1. Матрицы и списки
### 2.1.1 План урока
В этом уроке мы

* выберем красную таблетку и увидим, как устроена матрица;
* рассмотрим, как хранить данные различных типов и длин при помощи списка;
* ознакомимся с семейством функций apply;
* попытаемся угадать, кто скрывается за маской анонимной функции.

Не устаю напоминать про то, что важно самостоятельно пощупать новые объекты. Создавайте какие угодно вектора, матрицы и списки в своей сессии, применяйте к ним функции, о которых я рассказываю, проверяйте на них свои решения задач.

### 2.1.2
И матрица и список наследует очень много свойств от векторов

#### Матрица
* Матрица  -- двумерный массив данных только одного типа; для матриц работает такое же приведение типов что и для векторов
* По сути, это вектор уложенный по столбцам (!)
* Для создания матрицы можно использовать функцию `matrix`

```{r}
matrix(1:6, ncol = 3, nrow = 2)
# 1:6  - это вектор, который мы хотим упаковать по столбцам
# ncol - кол-во столбцов
# nrow - кол-во строк
```

#### Создание матриц
Избавимся от ненужной избыточности
```{r}
matrix(1:6, ncol = 3)   # достаточно указать только один из агрументов ncol/nrow; второй аргумент будет вычислен автоматически исходя ир размера вектора
```

Если мы хотим, чтобы вектор был упакован не по столбцам, а по строчкам, то мы воспользуемся аргументом `byrow = TRUE`:
```{r}
matrix(1:6, nrow = 2, byrow = T)
```

Ну и наконец, если мы укажем короткий вектор и много столбцов, то этот вектор будет переписан столько раз, сколько нужно для создания матрицы заданного размера:
```{r}
matrix(7:8, nrow = 2, ncol = 5)
```

#### Атрибут `dim`
Единственное отличие матрицы от вектора, это атрибут `dim` - он отвечает за размерность.
```{r}
m <- matrix(1:6, ncol = 3)
dim(m)                     # выводит размерность матрицы
```
Или можно самим собрать такой атрибут:
```{r}
c(nrow(m), ncol(m))
```

А что же произойдет с матрицей, когда мы уберем атрибут `dim`?
```{r}
dim(m) <- NULL; m    # матрица превратится в вектор!!!
```

А если восстановить этот атрибут, то матрица обретет исходный вид:
```{r}
dim(m) <- c(2, 3); m
```

#### Арифметические операторы
Для матриц работают те же правила, что и для векторов:
* поэлементно;
* с учетом правил переписывания.

Создадим две матрицы размером 2х2 каждая:
```{r}
m1 <- matrix(1:4, nrow = 2)
m2 <- matrix(c(1, 2, 2, 3), nrow = 2)
m1 + m2    # поэлементное сложение
m1 + 5     # а тут работает правило переписывания для числа 5 (оно повторяется длч каждого элемента матрицы)
```

Остальные операторы работают так же:
```{r}
m1 * 2
m1 * m2
```

#### Умножение в смысле линейной алгебры
```{r}
m1 %*% m2    # слегка поменялся оператор
```

Пример логики умножения матриц:

$$
A \cdot B =
\begin{pmatrix}
  a_{11} &a_{12} \\
  a_{21} &a_{22}
\end{pmatrix}
\cdot
\begin{pmatrix}
  b_{11} &b_{12} \\
  b_{21} &b_{22}
\end{pmatrix}
=
\begin{pmatrix}
  a_{11} \cdot b_{11} + a_{12} \cdot b_{21} & a_{11} \cdot b_{12} + a_{12} \cdot b_{22} \\
  a_{21} \cdot b_{11} + a_{22} \cdot b_{21} & a_{21} \cdot b_{12} + a_{22} \cdot b_{22}
\end{pmatrix}
$$

#### Индексирование матриц
Те же правила, что и для векторов, но с учетом двух размерностей
```{r}
m <- matrix(1:10, ncol = 5); m
m[1, 3]     # 1 - строка, 3 - столбец
```

Если необходимо вывести всю строку или весь столбец, то нужно просто опустить второй из индексов:
```{r}
m[2, ]    # доступ ко второму ряду
m[, 3]    # доступ к третьему столбцу
```

Это правило можно использовать для замены элементов матрицы:
```{r}
m[1, ] <- 0; m        # замена первой строки нулями
m[, -5] <- 11:18; m   # замена всех столбцов кроме пятого
```

#### Схлопывание размерности
```{r}
m <- matrix(1:10, ncol = 5)
ind <- c(1, 3, 5)
m[, ind]              # доступ к столбцам 1, 3, 5
ind <- 3
m[, ind]              # доступ к первому столбцу, но в виде строки ((((
m[, ind, drop = F]    # а вот теперь в виде столбца
```

#### Ремарка
У `TRUE` и `FALSE` есть однобуквенные сокращения (`T` и `F`): `drop = F`

#### Именованные матрицы: `rownames / colnames`
Заведем для всех строк и столбцов имена:
```{r}
m <- matrix(1:10, ncol = 5)
rownames(m) <- c("row_1", "row_2")
colnames(m) <- paste0("column_", 1:5)    # для ленивых )
m
```

И теперь к матрице можно обращаться по именам столбцов и строк:
```{r}
m["row_2", c("column_2", "column_5"), drop = F]  # без дропа не будет выведено название строки
```

#### Присоедтинение матриц: `rbind / cbind`
```{r}
rbind(m1, m2) # в высоту
cbind(m1, m2) # в ширину
```

### Аргумент `...` (ellipsis)
Если открыть справку о функции `rbind` или `cbind` то мы увидем аргумент `...` -- *ellipsis*. Это новый аспект языка R о котором еще не велась речь: этот аргумент позволяет передавать любое количество объектов в функцию.
```{r}
cbind(m1, m2, 1:2, c(5, 3), m2[ , 1], m1 * 3, cbind(m2, m1))
```

Другие примеры функций с ellipsis: `c`, `paste`, `paste0`, `sum`.

#### Применение функции к матрице: `apply`
А как применить функцию ко всей матрице?
```{r}
m <- matrix(1:25, ncol = 5); m
f <- function(x) sum(x^2)     
```

Три аргумента функции `apply`:
* Массив (матрица)
* Индекс (1 - по строкам, 2 - по столбцам)
* Функция

Теперь мы можем применить функцию `f` к матрице `m` построчно и по столбцам:
```{r}
apply(m, 1, f)
apply(m, 2, f)
```

#### Применение функции к матрице: `apply` ко всем элементам
Рассмотрим задачу, в которой необходимо заменить на 13 все элементы матрицы которые меньше 13, а остальные оставить прежними:
```{r}
apply(m, 1:2, function(i) if (i > 13) i else 13) # просто указываем 1:2 и функция примениться ко всем элементам
```

**ВАЖНО**: Функция без названия (и нигде не хранящаяся) -- называется *анонимной* функцией. Она прекратила свое существование после того, как функция `apply` была выполнена. Ни в одном из окружений ее не осталось. Это очень удобно для однократного небольшого преобразования, когда нет необходимости заводить отдельную функцию.

На самаом деле, эту задачу можно решить проще и быстрее используя логическое индексирование в матрице.
```{r}
m[m < 13] <- 13; m
```

#### `rowSums`, `rowMeans`, `colSums`, `colMeans`
На матрицах чаще всего используются две операции -- это суммы по столбцам и по строкам, а так же средние по столбцам и строкам. Поэтому для них создали отдельные функции.

Простой пример:
```{r}
m <- matrix(1:25, 5)
rowSums(m)
```

Давайте проверим правильность подсчета. Для этого напишем свою функию, используя самописную `apply` и `all.equal`:
```{r}
all.equal(colSums(m), apply(m, 2, sum))
all.equal(rowMeans(m), apply(m, 1, mean))
```

### 2.1.3 Задача
Если матрица mat имеет размерность `m` на `n (например, `mat <- matrix(0, m, n)`), то какой объект будет возвращён после выполнения следующих операций?

#### Решение
Команда | Расшифровка
--------------------:| --------------------------------------------------------
**mat[m, n]** | Вектор длины 1, содержащий элемент в правом нижнем углу
**mat[n, m]** | Скорее всего, ошибочная запись: ошибки не будет только при m=n
**mat[m, ]**  | Вектор, содержащий строку (ряд) номер m
**mat[m, , drop = FALSE]** | Матрица, состоящая из одной строки (ряда) номер m
**mat[, n, drop = F]** | Матрица, состоящая из одного столбца (колонки) номер n
**mat[, n, drop = TRUE]** | Вектор, содержащий столбец (колонку) номер n
**mat > 5** | Матрица m на n логического типа по условию
**mat[mat > 5]** | Вектор, содержащий все значения по условию (возможно, пустой)**

#### 2.1.4 Задача
Предположим, что у нас есть целочисленный вектор v и число n. Наша задача — найти позицию элемента в векторе, который ближе всего к числу n. При этом если таких элементов несколько, необходимо указать все позиции.

Напишите функцию, которая принимает на вход вектор и число и возвращает вектор индексов, отвечающих указанному условию. Индексы должны быть выстроены по возрастанию.

Пример. Пусть `v <- c(5, 2, 7, 7, 7, 2, 0, 0)` и `n=1`. Ответом будет вектор

`2 6 7 8`

Подсказки: 

* "ближе всего" означает минимальную разницу между числами;
* не забудьте про модуль!


#### Решение
```{r}
# в функцию не стал заворачивать
v <- c(5, 2, 7, 7, 7, 2, 0, 0)
n <- 1
which(abs(v - n) == min(abs(v - n)))
```

#### Из комментов
Решение БЕЗ `which`:
```{r}
find_closest <- function(v, n) {
  w <- abs(v - n)
  names(w) <- 1:length(v)
  as.integer(names(w[w == min(w)]))
}
```

### 2.1.5 Сцепить две матрици по диагонали
Предположим нам необходимо сцепить две матрицы, но не по вертикали или по горизонтали, а по диагонали.
```{r}
bind_diag <- function(m1, m2, fill) {
  # для начала нужно ввести результирующую матрицу
  # заполним ее сразу наполнителем fill
  m3 <- matrix(fill,
               nrow = nrow(m1) + nrow(m2),
               ncol = ncol(m1) + ncol(m2))
  # первый кусок - левый верхний угол
  m3[1:nrow(m1), 1:ncol(m1)] <- m1
  # у второй матрицы положение примерно такое же, только чуть сдвинутое
  # тут важен приоритет операций - у двоеточия он выше; Syntax {base}
  m3[nrow(m1) + 1:nrow(m2), ncol(m1) + 1:ncol(m2)] <- m2
  # возвращаем результат
  m3
}
m1 <- matrix(1:12, nrow = 3)
m2 <- matrix(10:15, ncol = 3)
bind_diag(m1, m2, fill = NA)
bind_diag(m2, m1, fill = 0)
```

### 2.1.6 Задача
Построим Зиккурат! Напишите функцию, которая принимает одно целое число n,  авозвращает "ступенчатую" матрицу, состоящую из n этажей. Этажи нумеруются с первого, ширина каждой ступени равна одной строке и одному столбцу.

```{r}
zikkurat <- function(n) {
  m <- matrix(NA, nrow = n * 2 - 1, ncol = n * 2 - 1)
   for (i in 1:n) {
    m[i:(n * 2 - i), i:(n * 2 - i)] <- i
  }
  m
}
zikkurat(4)
```

#### Решение из комментов
```{r}
build_ziggurat <- function(n) {
  d <- n * 2 - 1
  outer(1:d, 1:d, function(x,y) {
   x <- n - abs(n - x)
   y <- n - abs(n - y)
   pmin(x,y)
  })
}
```

А теперь сравним два решения по скорости:
```{r}
microbenchmark(zikkurat(100), build_ziggurat(100))
```

### 2.1.7 Списки
* Список -- индексированная структура, т.е. у его элементов есть номера, начинающиеся с единицы
* Элементами списка могут быть произвольные объекты
* В отличие от вектора, список может хранить данные различной длины или различных типов. Например, что делать, если нужно вернуть вывести матрицу и вектор одновременно -- нужно использовать список
* Создание списков осуществляется функцией `list`

```{r}
list(1:5, "my_data", matrix(0, 2, 2)) # принимает через запятую те элементы, что должны стать частью списка
```

#### Создание списков

При создании списков, как и при создании векторов, мы можем воспользоваться специальной записью вида `ключ - значение`, если мы хотим, чтобы некоторые элементы списка были проименованы. При этом не обязательно давать имена всем элементам списка. 

```{r}
list(a = 1, b = 1:3, "1to5" = 1:5, 42)
```

Если мы хотим, чтобы некоторые элементы списка были проименованы, нужно воспользоваться записью вида ключ-значение. При этом не обязательно давать имена всем элементам списка.

```{r}
list(a = 1, b = 1:3, "1to5" = 1:5, 42)
```

Необхожимо помнить о невалидных именах (начинается с цифры или специального символа), то необходимо это имя поместить в кавычки.

##### Список может быть рекурсивным
Это значит, что элементом списка может быть тоже список, и т.д.

```{r}
list(a = list(1, 2, 3), b = list(list(4), 5, 6))
```

Это может пригодится для построения древовидных структур.

#### Конкатенация списков
То есть объединение списков. Допустим у нас есть два списка `l1` и `l2`
```{r}
l1 <- list(name = "John", salary = 1000)
l2 <- list(has_car = TRUE, car = "lamborghini")
```

```{r}
c(l1, l2)
```

#### Конверсия между списком и вектором
Списки и вектора очень похожи. Любой веткор можно привести к списку:
```{r}
v <- 1:7
list(v)
```

Но не наоборот! Если сведение осмыслено, то есть `unlist`:
```{r}
l <- list(1:3, 4:5, last = 6)
unlist(l)
```

Нужно помнить, что как только мы получаем вектор, то сразу задействуется автоматическое приведение типов

```{r}
unlist(c(l, "spy"))
```

#### Доступ к элементам списка
**Первый способ**: как для векторов, `[]`
```{r}
l[3:2]; l[-(1:2)]
```

Здесь мы использовали положительное и отрицательное индексирование. В результате получаем подсписок.

Так же можно воспользоваться логическим вектором для индексирования или обратится по имени (имя должно быть заключено в кавычки):
```{r}
l[c(T, F, T)]; l["last"]
```

Обратите внимание, что если в результате обращения по единичным скобкам получаем только один элемент, то это все равно будет список.

**Второй способ**: доступ к конкретному элементу `[[]]`
```{r}
l[[1]]
l[["last"]]
```

Мы получили непосредственно сам элемент списка, вектор в данном случае.

**Третий способ**: доступ по имени с частичным дополнением , `$`

```{r}
l$last
l$l # l$la; l$las
```

Здесь мы тоже получим сам элемент. 

Нам не обязательно указывать полное имя, в отличие от предыдущих способов записи. Можно указать уникальный префикс. 

**Зафиксируем этот момент**:

* Одинарные скобки `[]`
    + действуют векторные правила индексирования (4 правила индексирования, справедливые  для векторов)
    + возвращаемое значение -- **подсписок**
* Двойные скобки `[[]]`
    + (скалрный) номер элемента или его полное имя
    + возвращаемое значение -- **элемент списка**
* Знак доллара `$`
    + частичное имя элемента
    + возвращаемое значение -- **элемент списка**
    
#### Замена и добавление элементов списка

```{r}
l <- list(1:3, 4:5, last = 6)
l[[3]] <- NULL; l
```

Мы не обязаны указывать элементы подряд:
```{r}
l[[4]] <- 999; l
```
Мы принудительно создаем четвертый элемент списка, не имея третего. При этом создастся третий **пустой** элемент.

#### Рассмотрим другой случай
Создадим список, состоящий из двух элементов:
```{r}
l <- list(vec = 1:7, fun = sqrt); #l$fun(4)
names(l)
```

Да, элементом списка может быть функция!!!

Давайте создадим новый элемент списка `string`, но прежде проверим существует ли он:
```{r}
is.null(l$string)
l$string <- "Citius, altus, fortius"
l
```

#### Применение функции к списку: `lapply`
Если мы хотим применить какую-либо функцию к строкам листолбцам матрицы то мы воспользуемся ф-ей `apply`.

На самом деле это цело семейство функций. 

Давайте познакомимся с `lapply`. Она применяет функцию к каждому элементу списка.

Давайте узнаем длинну каждого элемента списка:
```{r}
l <- list(a = c("12", "34"), b = LETTERS[5:10], c = 1:5)
lapply(l, length)
```

#### Применение функции к списку: `lapply`, `sapply`
А что если нам необходимо передать в функцию, используемую внутри `lapply`, некий аргумент?

Это можно сделать просто через запятую:

```{r}
lapply(l, paste, collapse = "|")
```

Таким образом, аргумент `collapse = "|"` уйдет внутрь ф-ии `paste`. 

То же самое можно получить используя анонимную функцию:
```{r}
lapply(l, function(s) paste(s, collapse = "|"))
```

Функция `sapply` упрощает вывод:
```{r}
sapply(l, paste, collapse = "|")
```

В результате мы получим вектор. Буква **s** в названии функции от слова **simplify**.

#### Частичное дополнение по $ и аргументам функции
```{r}
l <- list(some_name = 1, incredibly_long_name = 2)
l$inc + 2
```

Таким образом можно не писать полное имя элемента списка.

```{r}
f <- function(x, ridiculously_long_arg) x + ridiculously_long_arg
f(3, rid = 5) # f(3, 5)
```

### 2.1.8 Небольшое отступление про NA, NaN и NULL
Небольшая добавка: в R есть три похожих ключевых слова, `NA`, `NaN` и `NULL`. Они различаются по смысловой нагрузке. 

* `NA` -- это пропущенное значение ("not available"). Например, респондент не ответил на все вопросы предложенной анкеты, или данные с метеостанции за определённый период потерялись из-за сбоя оборудования. `NA` в этом случае обозначает, что эти данные существуют и имеют смысл, но их не удалось узнать.
* `NaN` -- "not-a-number" -- результат недопустимой арифметической операции, например `0/0` или `Inf - Inf`.
* `NULL` -- отсутствие объекта, "пустота". Применяется в тех случаях, когда объект действительно не существует, не может иметь осмысленного значения.

Для проверки значений есть три функции, `is.na`, `is.nan` и `is.null`, соответственно.
   
### 2.1.9 Задача
Для работы с матрицами пригодится функция под названием `diag`. Примечательно, что эта функция возвращает принципиально разные объекты в зависимости от аргумента. Какие именно?

P.S. Единичная матрица -- это не та, которая состоит из единиц. Единицы у неё только на диагонали, а остальные элементы равны нулю.

```{r}
diag(5)
diag(c(2,5))
(m <- matrix(1:4, 2))
diag(m)
```

#### Ответы
|Начало|Окончание|
|-------------------------------------|:-----------------------------------------------------------------|
|Если x -- положительное число, то ...|... возвращаемое значение -- единичная матрица указанного размера|
|Если x -- вектор хотя бы из двух элементов, то ...|... возвращаемое значение -- диагональная матрица с указанными элементами на диагонали|
|Если x -- матрица, то ...|... возвращаемое значение -- вектор, содержащий диагональные элементы|

### 2.1.10 Использование списков при создании функций в R
Сейчас мы разберем пример, когда список используется в качестве возвращаемого значения функции.

#### Get the longest element
У нас есть список и элементы этого списка представляют из себя вектора различной длины. Поэтому мы не можем использовать матрицу и приходится оперировать списком. 

Задача следующая: найти позицию элемента максимальной длины и вывести ее и зам элемент.

Этапы решения:

* Для начала мы применим функцию `length` ко всему списку; для этого нам понадобится функция семейства `apply`. 
* Затем мы найдем индекс `ind` этого элемента при помощи функции `which.max()`. 
* Ну и результатом функции будет список, содержащий и номер элемента и сам элемент.

```{r}
get_longest <- function(l){
  len <- sapply(l, length)
  ind <- which.max(len)
  list(number = ind, element = l[[ind]])
}
```

Задача решена! Но перед тем, как с этой задачей распрощаться, ее нужно оттестировать!

Один из способов тестировки=: написать другую функцию, которая буде генерировать списки, подходящие под условия задачи. Ну а дальше мы будем проверять эти сгенерированные списки на нашей функции. 

Нужно написать такую функцию, которая возвращала бы список, у которого определенное количество элементов, но эти элементы могут быть разной длины и они содержат какие-то случайные значения.

Функция `gen_list` на вход получает три аргумента:

* `n_element` -- количество аргументов списка
* `max_len` -- максимальная длина каждого элемента
* `seed` -- значение датчика генератора случайных значений

Для аргумента `seed` мы поставили умолчание, которое будет использовано, если в функции не указвать другое значение этого аргумента.

```{r}
gen_list <- function(n_elements, max_len, seed = 111){
  set.seed(seed)
  len <- sample(1:max_len, n_elements)
  lapply(1:n_elements, function(i) rnorm(len[i]))
}
```

Давайте посмотрим, что получилось:
```{r}
l1 <- gen_list(4, 10)
l1
gl1 <- get_longest(l1)
gl1
```

Теперь воспользуемся той же структурой, но поменяем значение датчика случайных чисел:
```{r}
l2 <- gen_list(4, 10, 777)
l2
gl2 <- get_longest(l2)
gl2$number
```

Таким образом мы не только написали решение задачи, но и протестировали его!

### 2.1.11 Задача
Если вектор достаточно длинный, то визуально сложно оценить, какие в нём содержатся элементы и сколько раз они повторяются. В этом случае полезно будет посмотреть на таблицу частот элементов.

Пусть x -- целочисленный вектор. Напишите функцию, которая вернёт матрицу из двух строк. В первой строке перечислите все различные элементы вектора, упорядоченные по возрастанию. Во второй строке укажите частоты (количество повторов) этих элементов.

Пример. Пусть `x <- c(5, 2, 7, 7, 7, 2, 0, 0)`. Тогда функция должна вернуть матрицу `2х4` с элементами:

* 0 2 5 7
* 2 2 1 3

#### Решение
```{r}
x <- c(5, 2, 7, 7, 7, 2, 0, 0)

count_elements <- function(s) {
  y <- sort(unique(s))
  rbind(y, sapply(y, function(i) sum(s == i)))
}

count_elements(x)

# функция, которая все делает сама
table(x)

```

### 2.1.12 Задача
Пусть целочисленная матрица `m` содержит некоторое количество нулей, которое мы хотим заменить на пропущенные значения. Какая из конструкций произведёт такую замену?

P.S. Для того, чтобы, наоборот, заменить `NA`, нужно использовать специальную функцию `is.na`: сравнения вида `m == NA` всегда возвращают `NA`.

#### Ответы

* `m[m == 0] <- NA`
* `m <- apply(m, 1:2, function(k) if (!k) NA else k)`
* `for (i in 1:nrow(m)) {for (j in 1:ncol(m)) {if (m[i, j] == 0) m[i, j] <- NA}} # omg who wrote this?`
* **Все из вышеперечисленных (хотя apply здесь ужасен, а двойной цикл for дважды ужасен)**

#### Хак от АА
[Ganenkov Nikolay](https://stepik.org/users/715020): поясните пожалуйста запись (!к)... если "не к" то NA... не встречалось ранее что-то.

[Антон Антонов](https://stepik.org/users/1477364): Это некий "хак": я пользуюсь тем, что оператор `!` принудительно приводит к логическому типу. А это делается по правилу `0` -- `FALSE`, всё остальное -- `TRUE`. Таким образом, `!k` то же самое что `k != 0`.



