---
title: "Основы программирования на R"
author: "Антон Антонов"
output: 
    html_document:
        highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = T)
```

# 1. Базовые структуры и понятия
## 1.1 Введение в курс
### 1.1.1 Введение
#### Немного об автор курса Антоне Антонове 
* Академическая математика (вычислительные стохастические методы)
* Количественная финансовая математике (алгоритмическая торговля)
* Open source contributions: [github.com/tonytonov](https://github.com/tonytonov)
* StackOverflow: [stackoverflow.com/users/1900149/tonytonov](https://stackoverflow.com/users/1900149/tonytonov)
* St. Petersburg R User Group: [vk.com/spbrug](https://vk.com/spbrug), [meetup.com/St-Petersburg-R-User-Group ](http://meetup.com/St-Petersburg-R-User-Group )

#### Почему R?
* Объемы данных растут
* Это настоящий язык программирования
* Он бесплатен, кроссплатформен, расширяем, у него огромное сообщество

#### Почему программирование?
Есть два типа знакомства с R:

* Первый тип знакомства с R: обучение конкретным методам
* Второй тип:
    + Как устроены объекты языка?
    + Почему они ведут себя имнно так?
    + Как их можно эффективно использовать?
    + Основная цель: ускорить переход от простого к сложному
    
Мы пойдем по **второму пути**!
    
#### Почему "основы"?
* Курс покрывает основные объекты и семантические принципы
* Рассматриваются типичные ошибки и сложности при работе с R
* Материал универсален и не заточен под специфику данных какой-то области

#### Материалы курса
* Все материалы доступны на [https://github.com/tonytonov/Rcourse](github.com/tonytonov/Rcourse)
* Рекомендуемые книги:
    + Norman Matloff "The Art of R Programming"
    + Richard Cotton "Learning R"
    + Hadley Wickham "Advanced R" (после года программирования)
    
#### Рекомендации по прохождению
* Сложность курса возрастает:
    + первая неделя -- "easy"
    + вторая неделя -- "normal"
    + третья неделя -- "hard"
* Задания можно пропускать и возвращаться к ним позже
* Если что-то непонятно, ищите аналогичные темы в справке, книгах и интернете
* Побольше экспериментов!
* Don't give up easily :)

## 1.2 Переменные, глобальное окружение, справка
### 1.2.1 План урока
В этом уроке мы

* узнаем, чем хорош (и не очень хорош) R;
* научимся использовать встроенную справку;
* будем создавать, изменять и удалять переменные в глобальном окружении;
* используем функции с аргументами и без;
* напишем свои собственные функции.

### 1.2.2
#### Что такое R
* R -- язык программирования для научных вычислений и анализ данных с упором на визуальзацию и воспроизводимость
* R -- свободное кросс-платформенное программное обеспечение с открытым исходным кодом
* R -- интерпретируемый язык с интерфейсом командной строки (его не нужно компилировать)
* R -- мультипарадигменный язык, сочетающий в себе
    1. функциональное 
    2. процедурное
    3. объектно-ориентированное
    4. рефлексивное программирование
    
#### Плюсы
* R беспалтен, его код открыт
* Огромное количество встроенных статических тестов, математических алгоритмов, функций для анализа данных в академических и отраслевых исследованиях
* Расширяемость: модульная система пакетов (packages)
* Обширное сообщество разработчиков
* Полностью программируемая высокоуровневая графика
* Кросс-плватформенность, воспроизводимость результатов
* R становится популярным: статьи, книги, конференции, юзер группы

#### Минусы
* R достаточно сложен как язык программирования
* Документация некоторых методов труднодоступна без глубокого знания математических методов и статистических процедур
* Легко написать плохой (медленный, неподдерживаемый, нечитаемый) код
* Пакеты дополнений устаревают
* Можно заметить некоторую непоследовательность в именовании переменных и реализации методов

#### Помогите, ничего не работает!
* Это нормально
* Внимательно читаем текст ошибок и предупреждений
* Встроенная справка: `help("sin")`, `help.search("logarithm")`
* <https://cran.r-project.org/doc/FAQ/R-FAQ.html>
* Пользуемся поисковыми системами
* R Mailing List Archive
* [stackoverflow.com](https://stackoverflow.com)

### 1.2.3 Задача
В этом тесте отметьте верные утверждения о характеристиках языка R.
Итак, правда ли, что R:

* это язык с проприетарным (закрытым) кодом?
* чрезвычайно прост в освоении?
* создан для коммерческого использования?
* требует компиляции перед исполнением кода?
* **сочетает в себе несколько различных стилей (парадигм) программирования?**
* **это язык с открытым исходным кодом?**

### 1.2.4 Задача

### 1.2.5 Запускаем Rstudio
#### Встроенная справка
```{r}
help("sin")
```

Справка состоит из нескольких частей:

* Description -- описание на человеческом языке
* Details -- важные детали и подробности
* Value -- возвращаемое значение
* Examples -- примеры использования

В `R` одинарные и двойные кавычки **равнозначны**:
```{r}
help('sin')
```

А для некторых функций можно вообще не укхывать имя в кавычках:
```{r}
help(sin)
```

Это правило не работает например для зарезервированных слов:
```{r}
# help(for) # выполнение кода выдаст ошибку
help("for")
```

Вместо функции `help` можно использовать знак вопроса `?`:
```{r}
?sin
```

Ну и если мы хотим спросить что-то "запретное":
```{r}
?"function"
```

Во вкладке `History` появилась история наших действий в консоли. Тут есть поиск, иногда это полезно.

### 1.2.6 Задача
Воодушевлённый предыдущим видео, я решил посмотреть справку по использованию оператора if. 

Что произойдёт, если я наберу в консоли 
`?if`
и нажму Enter?

#### Решение
* Справка не откроется, потому что Enter нужно нажать ещё раз.
* **Справка не откроется: if -- зарезервированное слово, которое надо заключать в кавычки.**
* Откроется справка по циклам.
* Откроется справка с перечнем зарезервированных слов.
* Справка не откроется, потому что такого оператора нет, вместо него есть оператор ifelse.
* Следующий шагРешить снова

### 1.2.7 Задача
В R есть функция, которая реализует алгоритм [быстрого преобразования Фурье](https://en.wikipedia.org/wiki/Fast_Fourier_transform). Круто, да?

Попробуйте найти название этой функции поиском по справке или в google. 

Подсказки:

* Название алгоритма на английском можно узнать по ссылке выше.
* R чувствителен к регистру, то есть функция cos существует, а `COS` или `cOs` -- нет.
* Ответ содержит не более шести символов.

#### Решение
`fft`

### 1.2.8
#### Основы основ
* R -- интерпретируемый язык
* Команды исполняются построчно
* Командная строка расположена во вкладке "Console" в RStudio
```{r}
2 + 1
sin(pi/6)
```

#### Переменные
Нам не очень интересно использоват R как калькулятор. Мы хотим использовать понятия переменной и функции. Начнем с переменных. Чтобы создать переменную необходимо использовать оператор присваивания `<-` (Alt + -).

Обычно в языках программирования опертором присваивания является знак равно `=`. В R он тоже используется, но немного в других случаях.

Предположим, что мы хотим посчитать количество питомце в доме. Создадим две переменные `cats` и `dogs`, а затем их сумму присвоим новой переменной `pets`.
```{r}
cats <- 5
dogs <- 2
pets <- cats + dogs
```

Напечатано ничего не будет, просто сохранится переменная. Проверим, сохранилась ли переменная `pets`. Для этого необходимо просто написать ее имя:
```{r}
pets
```

Не любое имя переменной считается валидным!

#### Глобальное окружение
Поговорим о том месте, где живут созданные нами переменные.

* Каждая переменная определяемая нами живет в собственном *окружении*
* Окружение переменной -- это пространство, где ее можно найти; то место где она считается определенной
* Те переменные, что мы создали ранее, попадают в *глобальное окружение*; это то окружение, которое создается и считается самым широким
* Переменные из глобального окружения доступны во вкладке "Environment" в RStudio
* Либо можно просто ввести команду `ls()` в консоли
```{r}
ls() # list objects
```

#### Вызов функции
Поподробнее остановимся на функцииях и их аргументах, как их можно указывать.

В R определно множество встроенных функций, например `rnorm`:
```{r}
?rnorm    # посмотрим на справку по этой функции
rnorm(15) # генерирует 15 случайных чисел из нормального распределения
```

Аргументы функции можно указать по имени, через запятую по правилу ключ --> значение.
```{r}
rnorm(15, mean = 5, sd = 3)
```

На этом примере видет принцип разделение присваивания (`<-` и `=`): если мы указываем значение для переменной, то `<-`, если указываем значение аргумента, то используем оператор `=`.

#### Написание функций
Не всегда мы будем использовать уже существующие функции. Мы захотим использовать свои функции!

Для определения новой функции существует ключевое слово `function`; в круглых скобках *аргументы* функции, в фигурных -- **тело** функции (её код):
```{r}
returnTwo <- function(){
  y <- 2                # переменная, созданная в локальном окружении
  return(y)             # для возвращения переменной
}
```

Использование нашей функции:
```{r}
returnTwo()
```

#### Окружение функции
Локальное окружение (внутри функции) и глобальное окружение (то где эта функция находится) -- оазные вещи. 

Напишем функцию, прибавляющую к любому числу поступившему на ее вход 10:
```{r}
addten <- function(x) {
  x <- x + 10
}
```

И применим ее к нашим кошкам (ДА! Больше кошек!):
```{r}
addten(cats)
cats
```

Котиков больше не стало, хнык. Это произошло потому что мы **переприсвоили значение переменной `x` в локальном окружении** и оно не попало в глобальное.

Для того чтобы функция повлияла на глобальное окружение, необходимо пользоваться ключевым словом `return`:
```{r}
morecats <- function(x) {
  return(x + 10)          # просто засунем в return увеличение на 10
}
```

Проверим:
```{r}
morecats(cats)
```

#### Оператор глобального присваивания
Существует оператор **глобального присваивания**, `<<-`. Мы могли бы завести в теле функции новую переменную `moreDogs`, куда бы мы сложили результат прибавления 10 к аргументу `x`. И использую символ `<<-` мы создаем перменную не в локальном окружении, а в глобальном. 
```{r}
addten_2 <- function(x) {
  moreDogs <<- x + 10
}

addten_2(dogs)
dogs            # значение не поменялось, т.к. мы создали переменную в глобальном окружении
moreDogs        # а вот и она, новая переменная
```

Функция обладающие свойством действовать на глобальное оокружение называются функциями со *сторонним эффектом* (side effect). 

Но такая практика является сомнительной, ибо дает право функции право менять объекты в глобальном окружении.

#### Удаление переменных из окружения
Давайте проверим состояние глобального окружения, вызовем функцию `ls()`:
```{r}
ls()
```

Вердикт -- надо чистить.
```{r}
rm(dogs)
rm(moreDogs)
ls()
```

Но можно удалить все одним махом%
```{r}
rm(list = ls())
ls()
```

Будьте аккуратны при удалении переменных!

#### Полезное из коментов. 
##### Вопрос про `rm()` vs `qs()`
**Илья Ильюшёнок**
Сталкивался с тем, что `rm()` удаляет переменные из окружения, но в памяти они продолжают занимать место. Недавно узнал о существовании функции `gc()`. Пробовал сочетание `rm(value)` и `gc()` - помогает. Возможно, есть ещё какие-то способы решения этой проблемы?

**Антон Антонов**
Хороший вопрос, спасибо. Вы всё делаете правильно. На самом деле, `rm` действительно не высвобождает память, а просто уничтожает имя переменной. Память освобождается сборщиком мусора, который вызывается либо самим R, либо вручную (`gc` -- garbage collector). Манипулирование памятью в R -- достаточно хитрый механизм, и, строго говоря, даже вызов gc вручную не всегда гарантирует освобождение памяти. Похожий вопрос есть на [stackoverflow](http://stackoverflow.com/questions/1467201/forcing-garbage-collection-to-run-in-r-with-the-gc-command).

### 1.2.9
Самые внимательные зрители могли заметить, что на последнем слайде я указал
?`function`
Зарезервированное слово окружено здесь не одинарными ('function') и не двойными ("function") кавычками, а символами backtick (на моей клавиатуре этот символ расположен на клавише с буквой ё).
Так тоже можно! А вот при работе со строками (на второй неделе) лучше использовать кавычки.

### 1.2.10
Если в функции используется оператор <<-, влияющий на объекты в глобальном окружении, то подобное поведение называется ...

* **сторонним эффектом (side effect)**
* функциональным программированием (functional programming)
* локальным окружением (local environment)
* возвращаемым значением (return value)

### 1.2.11
R может послужить хорошей заменой вашему настольному калькулятору. Например, посчитайте, чему равно значение двоичного логарифма от квадрата синуса арктангенса единицы. 
Подсказки:

Справку по тригонометрии мы вызывали неоднократно.
Я уже упоминал, как найти логарифм. Двоичный логарифм там же. 
Возведение в степень — оператор ^.
Ответ — целое число. 
P.S. Что значит у вас нет настольного калькулятора?!

#### Решение
```{r}
log2(
  sin(
    atan(1)
  )^2
)
```

### 1.2.12
Бытует мнение, что если в скриптах попадаются куски одинакового кода длиной хотя бы в три строки, то надо срочно заводить функцию, а не копипастить одно и то же. Не берусь сказать, что это непреложная истина, но здравое зерно в таком принципе есть.  
Иными словами, пришло время потренироваться в написании функций.  
Напишите функцию, которая принимает на вход два числа и возвращает результат деления первого на второе.  
Оболочку я уже написал, с вас только тело функции.  
P.S. Как будет готово, поэкспериментируйте с вашей функцией: что будет, если вызвать

`divide(1, 0)`  
`divide(-99999, 0)`  
`divide(0, 0)`  
`divide(Inf, Inf)`  

Это тот результат, который вы ожидали?

#### Решение
```{r}
divide <- function(x, y) {
  x / y
}
```
Проверяем:
```{r}
divide(100, 10)
divide(1, 0)
divide(-99999, 0)
divide(0, 0)
divide(Inf, Inf)

```

### 1.2.13 Глоссарий
`?help`, `?help.search`  
`?"<-"`, `?ls`  
`?function`  
`?rm`  
`?rnorm`  

## 1.3 Векторы (часть 1)
### 1.3.1 План урока
В этом уроке мы

* рассмотрим ключевой объект языка -- вектор;
* посмотрим, какие есть удобные возможности для создания численных векторов;
* узнаем про типы векторов и правила их приведения;
* увидим, как действует принцип векторизации.

Вектора и векторизация -- это краеугольный камень языка R и ключ к написанию красивого и эффективного кода. Идеи, которые лежат в основе урока, редко встречаются в других языках программирования, так что будьте внимательны!

### 1.3.2
Представьте себе множество простых чисел от 1 до 100 или все слова английского языка начинающиеся на K. 

Какая мтруктура данных подходит для хранения такого рода объектов?

Разные языки программирования отвечают на это твопрос по разному.

* Вектор -- самая базовая структура данных в R
* На векторах основаниы более сложные структуры (матрицы, список, фактор, дата фрейм)
* Векторизация -- одна из ключевых концепций языка R

$$
f:
\begin{bmatrix}
  x_1 \\
  x_2 \\
  \vdots \\
  x_m
\end{bmatrix}
\longrightarrow
\begin{bmatrix}
  f(x_1) \\
  f(x_2) \\
  \vdots \\
  f(x_m)
\end{bmatrix}
$$

Представим, что у нас есть вектор длины $m$ и мы хотим получить другой вектор, который является результатом применения некоей функции $f$ к каждому элементу вектора. Если бы мы программировали на классическом императивном языке (C, C++), то на пришлось бы сделпть слеждующее:

* завести новую переменную
* указать ее длину (определить количество памяти под нее)
* указать тип
* завести цикл и применить к каждому элементу $x_i$ функцию $f$
* записат результат в конечный вектор

Так вот, для того, чтобы сделать тоже самое в R чаще всего прийдется написать $f(x)$ и все. И все эти действия будут призведены автоматически. 

#### Вектор
* Вектор -- **индексированный** набор данных **одного типа**
* R не делает различия между скалярными и векторными величинами, т.е. скаляр -- это вектор длины 1
* Индексация векторов начинается с единицы (не с нуля!)
* Для создания вектора можно использовать функцияю `vector`

Как бы мы сделали в обычном язык:
```{r}
x <- vector(length = 2) # задали длину ветора и его имя
x[1] <- 5               # задали первое значение
x[2] <- 8               # задали второе значение
x                       # вывели на экран
```

Но в R такая запись излишня (хотя и является абсолютно корректной).

#### Создание векторов: функция `c`
Вместо поэлементного присваивания используют компактную запись:
```{r}
x <- c(5, 8)
x
```

Функция `c` может быть вложенной и принимать переменные, и количество этих перменных может быть не ограничено:
```{r}
y <- c(x, 1, c(3, 4), x, NA)
y
```

#### Создание векторов: оператор `:`
Применение функции `с` требует перечисления всех элементов будущего вектора. Очень часто бывает так, что нам необходимо создать числовую последовательность с шагом 1.

Вот для создания такого рода последовательностей в `R` существует оператор двоеточие `:`:
```{r}
5:9
3:-1
1:pi    # именно челочисленный шаг
pi:1    # именно челочисленный шаг
```

#### Создание векторов: функция `seq`
Для создания последовательностей с шагом отличным от единицы:
```{r}
seq(1, 2, by = 0.25)       # от 1 до 2 с шагом 0.25
seq(3, 4, length.out = 5)  # от 3 до 4 с длиной вектора 5, шаг вычисляется автоматически
seq(3, 4, length = 5)      # не обязательно указывать имя аргумента целиком, достаточно тольуо уникального префикса

```

#### Создание векторов: функция `rep`
Повторение векторов
```{r}
rep(1:3, times = 3)       # повтор вектора три раза
rep(1:3, each = 3)        # повтор каждого элемента вектора три раза
rep(1:3, length.out = 5)  # для нецелого кол-ва повторений
```

### 1.3.3 Задача
В R существует множество операторов, как бинарных (требующих двух аргументов, например, `*`), так и унарных (требующих одного аргумента, например, `?`). Сопоставьте следующие бинарные операторы языка с их названиями.

К слову, приоритет операторов (порядок их действия) описан в справке `?Syntax`.

#### Ответы
* `<-` -- Оператор присваивания
* `<<-` -- Оператор глобального присваивания
* `<=` -- Меньше либо равно
* `^` -- Возведение в степень
* `:` -- Создание числовых векторов с шагом 1
* `/` -- Деление

### 1.3.4 Задача
Концепция *векторизации* подразумевает, что

#### Ответы
* при создании вектора не нужно указывать его тип.
* **некоторые функции и операторы действуют поэлементно.**
* для операций с векторами необходимо использовать циклы в явном виде.
* вместо поэлементного присваивания можно воспользоваться функцией c.
* индексация векторов начинается с единицы.

### 1.3.5 Решение задач
#### Традиции, традиции
```{r}
hello <- "Hello, world"   # в глобальном окружении сразу появилась переменная hello
print(hello)              # распечатаем
hello                     # в консоли работает и так; но есди мы в batch режиме то только через print
```

#### Трудности перевода
```{r}
c(1, 3, 5)   # нужно быть осторожным, чтобы не спутать раскладку клавиатуры
```

#### Особенность чисел double (плавающая точка):
```{r}
0.1 + 0.1 == 0.2    # выдаст TRUE
0.1 + 0.05 == 0.15  # выдаст FALSE
```
Числа с плавающей точкой хранятся особым образом, поэтому оператор двойного равенства здесь неуместен.

Для того чтобы корректно сравнивать числа `double`, нужна функция `all.equal()`, она сравнивает числа с некоторой точностью:
```{r}
all.equal(0.1 + 0.05, 0.15)
```

Эта особенность очень хорошо задокументрована:

* R FAQ 7.31
* google "R why are these numbers not equal"
* <https://stackoverflow.com/questions/9508518/why-are-these-numbers-not-equal>

#### Задача
Мы хотим создать вектор от 0 до 1, который содержит в себе все трети и все седьмые части; а так же этот вектор нужно упорядочить по возрастанию:
```{r}
u <- seq(0, 1, 1/3) # трети
v <- seq(0, 1, 1/7) # седьмые
w <- sort(c(u, v))  # сортировка
unique(w)           # убираем повторы
```

### 1.3.6 Задача
Вместе мы решили задачу про 1/3 и 1/7. Напишите функцию `get_fractions`, которая принимает на вход два числа, m и n, и возвращает аналогичный вектор, содержащий все дроби вида {i/m, i = 0, 1, ..., m} и  {j/n, j = 0, 1, ..., n}. Вектор не должен содержать повторов. И -- сюжетный поворот -- должен быть упорядочен в порядке убывания.

Подсказки: 

проверить функцию можно подстановкой m=3, n=7: должен получиться вектор из моего примера, только задом наперёд;
в R огромное количество функций, а у многих функций есть вспомогательные аргументы.

#### Решение
```{r}
get_fractions <- function(m, n) {
  a <- seq(0, 1, 1/m)
  b <- seq(0, 1, 1/n)
  sort(unique(c(a, b)), decreasing = T) # лучше сначала избавиться от лишних и только потом упорядочить
}
get_fractions(3, 7)
```

#### Подглядел в ответах
```{r}
get_fractions_2 <- function(m, n) {
    sort(unique(c(0:m/m, 0:n/n)), d = T) # помним, что : главнее /
}
get_fractions_2(3, 7)
```

### 1.3.7 Типы векторов
#### Типы векторов
Вектор это структура, которая может содержать данные только одного типа

Основные типы:

1. **logical** (TRUE/FALSE)
2. **integer** (целые числа)
3. **numeric/double** (числа с плавающей точкой)
4. **complex** (комплексные числа)
5. **character** (строки)
6. **raw** (байтовые последовательности)

Дляопределения типа вектора есть функция `typeof` и `is.*` (где `*` обозначает любой из типов):
```{r}
a <- c("Дуб", "Дерево", "Воробей")
typeof(a)
is.character(a)
is.logical(a)
```

#### Приведение типов
Естественным считается приведение слева направо по цепочке:

<center>logical --- integer --- double --- character</center>

```{r}
b <- c(FALSE, 1.5)
typeof(b)
b <- c(5, b, "abc")
typeof(b)
b
```

#### Принудительное приведение типов
Принудительное приведение типов осуществляется функциями `as.*`:
```{r}
# as.double(b) # или
as.numeric(b)  # 
as.integer(b)
```

#### Длина вектора: `length`
Помимо типа у любого вектора есть длина:
```{r}
x <- 1:100
length(x)
```

Длина определяется автоматически, но ее можно принудительно менять:
```{r}
length(x) <- 4; x # команды в одной строке нужно разделять точкой с запятой
length(x) <- 7; x
```

#### Именованые вектора
Для того, чтобы именовать вектор, нужно воспользоваться одним из двух способов:

##### 1. Имя = Значение как аргумент функции  `c`
```{r}
a <- c(uno = 1, dos = 2, "universal answer" = 42, 99) # у 42 в имени есть пробел - его в кавычки заключаем
names(a) # вызов имен 
```

##### 2. Переприсвоить вектору `names` другие значения имен
```{r}
names(a) <- c("one", "two", "forty two", "ninty nine") 
a
```

Чтобы избавиться от вектора имен, нужно присвоить `names(a)` пустоту или `NULL`
```{r}
names(a) <- NULL
```

#### Векторная арифментика
Арифметические операторы *векторизованы* (применяются поэлементно):
```{r}
1:3 + c(-1, 2, 0)
1:3 * c(-1, 2, 0)
c(T, T, T) & c(0, 1, 999)  # все что не ноль - это TRUE
```

#### Векторизация
Многие функции в R имеют встроенную поддержку векторизации:
```{r}
# векторизована
sqrt(1:4)
# векторизована
floor(seq(0, 3, by = 0.25)) # округление вниз до ближайщего целого
# не векторизована
sum(1:100)
```

### 1.3.8 Задача
К этому времени вы уже достаточно знаете про типы векторов и без труда укажете иерархию среди четырёх основных типов, выстроив их в порядке сверху вниз от самого "узкого" к самому "широкому".

* Логический (logical)
* Целочисленный (integer)
* Числа с плавающей точкой (numeric/double)
* Строковый (character)

### 1.3.9 Задача
Давайте экспериментировать с типами! Функции семейства `as.*` дают возможность устраивать форменные безобразия. Установите соответствие между вызовами слева и результатами справа.
Попробуйте пройти это задание, не пользуясь консолью `R`. 

* `1:1` -- `-1 0 1`
* `as.logical(-1:1)` -- `TRUE FALSE TRUE`
* `as.character(as.logical(-1:1))` -- `"TRUE" "FALSE" "TRUE"`
* `as.numeric(as.logical(-1:1))` -- `1 0 1`
* `as.character(as.numeric(as.logical(-1:1)))` -- `"1" "0" "1"`
* `as.numeric(as.character(as.logical(-1:1))` -- `NA NA NA`

### 1.3.9 Задача
Я упоминал, что большинство имён из букв и цифр в R являются валидными, то есть такими, которые можно использовать в качестве имён переменных или имён `names()` в векторах. Попробуйте придумать способ, с помощью которого можно проверять валидность имени и с его помощью отметьте только валидные имена из предложенного списка.

P.S. Строго описанные правила именования есть в R FAQ и на stackoverflow. Кто ищёт, тот всегда найдёт!

P.P.S. Пожалуйста, никогда не именуйте переменные похожим образом. Это учебный пример!

* next
* :smiley:
* **super_long_name_in_fact_so_long_i_cannot_stop_typing_please_help**
* **.hidden**
* 2b.or.not.2b
* function
* **xXx_TerM1Nat0R_xXx**

Искать надо *r variable naming rules*, найдется подобное:
* [R FAQ 7.14](http://cran.r-project.org/doc/FAQ/R-FAQ.html#What-are-valid-names_003f)
* [stackoverflow](https://stackoverflow.com/questions/9195718/variable-name-restrictions-in-r)

А еще можно использовать функцию `exists()`:
```{r}
exists('for')
exists('myvariable')
```

Либо проверять по списку зарезервироанных слов:

* `if` `else` `repeat` `while` `function` `for` `in` `next` `break`
* `TRUE` `FALSE` `NULL` `Inf` `NaN` `NA` `NA_integer_` `NA_real_` `NA_complex_` `NA_character_`

### 1.3.11 Глоссарий
`?c`, `?":"`
`?seq`, `?rep`
`?print`
`?all.equal`
`?typeof`
`?is.logical`, `?as.logical`, etc.
`?length`, `?names`

## 1.4 Управляющие конструкции, работа с пакетами
### 1.4.1 План урока
В этом уроке мы

* рассмотрим условные операторы и циклы;
* ужаснёмся, как легко "повесить" R, если забыть о векторизации;
* перестанем называть пакеты библиотеками;
* узнаем об установке и поддержке пакетов.

Условия и циклы всегда так или иначе присутствуют в реализациях хоть сколько-нибудь сложных алгоритмов. Для того, чтобы в этом убедиться, достаточно посмотреть в исходный код популярных пакетов. Вы ведь не успели забыть, что исходный код R и всех его пакетов полностью открыт?

### 1.4.2 
#### Конструкция `if` и `else`
Управляющие конструкции в R сильно похожи на управляющие конструкциив других языках.

`if (<condition>) {<do something>} else {<do another thing>}`

* Здесь \<condition\> -- это выражение, результатом которого будет догический вектор длины 1 (`TRUE` или `FALSE`; `NA` приведет к ошибке)
* \<do something\> и \<do something else\> -- проиизвольные команды
```{r}
if (sqrt(2) > 1.5) {
  print("Greather!")
} else {
  print("Less!")
  
}
```

Переносить `else` на следующую строчку **нельзя**!

#### Конструкция `ifelse`
А давайте поставим в условие вектор длиною больше 1:
```{r}
if (c(T, F)) print("Hmm...?")
```

И что тогда делать, если нам нужно проверить условие на целом векторе? Именно для этого и существует `ifelse`:
```{r}
ifelse(runif(8) > 0.5, "Орел", "Решка") # 
```

А если есть несколько условий?
```{r}
x <- runif(8)
ifelse(x > 2/3, "Камень",
       ifelse(x > 1/3, "Ножницы", "Бумага"))
```

#### Множественный выбор: `switch`
```{r}
switch("factorial",                 # строка на входе
       sum = 5 + 5,
       product = 5 * 5,
       factorial = factorial(5),
       0)
```

Используется очень редко!

#### Циклы: `repeat`
```{r}
i <- 0                # задаем начальное значение
repeat {
  i <- i + runif(1)   # прибавляем случайную величину от 0 до 1
  print(i)            # печатаем ее
  if (i > 5) break    # условие на выход
}
```

#### Циклы: `while`
```{r}
i <- 2^14
while (i > 1000) {   # отличие от repeat - тут условие в начале
  i <- i/2
  print(i)
}
```

Цикл `repeat` -- может быть выполнен хотя бы один раз, а `while` может и не разу.

#### Циклы: `for`
Синтаксис простой
```{r}
for (i in 1:10) {
  if (i %% 2 == 0) print(i) # %% - остатоr от деления
}
```

Пример с `next` и `break`
```{r}
for (i in letters) {
  if (i == "b") next
  if (i == "d") break
  print(i)
}
```

Внутри цикла необходимо **принудительно** вызывать `print` для распечатывания переменной!

#### `for` против векторизации
При неверном использовании цикла `for` можно буквально в две строчки написать громоздкий и неэффктивный код.

Нам нужно посчитать квадратные корни чисел от 1 до 10 000 000:
```{r}
v <- 1:1e7
t_x <- system.time({
  x <- 0                           # не указана длин арезультата 
  for (i in v) x[i] <- sqrt(v[i])
})
t_x
```

Почти `r round(t_x[3])` секунд. Это очень медленно. 
```{r}
t_y <- system.time({
  y <- sqrt(v)
})
t_y
```

А если использовать **силу векторизации ** то выйдет всего `r t_y[3]` секунды!

Проверим идентичность результатов:
```{r}
identical(x, y)
```

### 1.4.3 Задача
Если утверждение верное, поставьте галочку. Впрочем, это лишняя информация, смысл задания и так понятен.

* **ifelse -- это векторизованный вариант if.**
* %% -- это оператор целочисленного деления (integer division).
* Синтаксис цикла for зависит от типа вектора в условии.
* **Не стоит использовать цикл for, если есть возможность использовать векторизацию.**
* В цикле if можно переносить условие else на новую строку.

