---
title: "Основы программирования на R"
author: "Антон Антонов"
output: 
    html_document:
        highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = T)
```

# 1. Базовые структуры и понятия
## 1.1 Введение в курс
### 1.1.1 Введение
#### Немного об автор курса Антоне Антонове 
* Академическая математика (вычислительные стохастические методы)
* Количественная финансовая математике (алгоритмическая торговля)
* Open source contributions: [github.com/tonytonov](https://github.com/tonytonov)
* StackOverflow: [stackoverflow.com/users/1900149/tonytonov](https://stackoverflow.com/users/1900149/tonytonov)
* St. Petersburg R User Group: [vk.com/spbrug](https://vk.com/spbrug), [meetup.com/St-Petersburg-R-User-Group ](http://meetup.com/St-Petersburg-R-User-Group )

#### Почему R?
* Объемы данных растут
* Это настоящий язык программирования
* Он бесплатен, кроссплатформен, расширяем, у него огромное сообщество

#### Почему программирование?
Есть два типа знакомства с R:

* Первый тип знакомства с R: обучение конкретным методам
* Второй тип:
    + Как устроены объекты языка?
    + Почему они ведут себя имнно так?
    + Как их можно эффективно использовать?
    + Основная цель: ускорить переход от простого к сложному
    
Мы пойдем по **второму пути**!
    
#### Почему "основы"?
* Курс покрывает основные объекты и семантические принципы
* Рассматриваются типичные ошибки и сложности при работе с R
* Материал универсален и не заточен под специфику данных какой-то области

#### Материалы курса
* Все материалы доступны на [https://github.com/tonytonov/Rcourse](github.com/tonytonov/Rcourse)
* Рекомендуемые книги:
    + Norman Matloff "The Art of R Programming"
    + Richard Cotton "Learning R"
    + Hadley Wickham "Advanced R" (после года программирования)
    
#### Рекомендации по прохождению
* Сложность курса возрастает:
    + первая неделя -- "easy"
    + вторая неделя -- "normal"
    + третья неделя -- "hard"
* Задания можно пропускать и возвращаться к ним позже
* Если что-то непонятно, ищите аналогичные темы в справке, книгах и интернете
* Побольше экспериментов!
* Don't give up easily :)

## 1.2 Переменные, глобальное окружение, справка
### 1.2.1 План урока
В этом уроке мы

* узнаем, чем хорош (и не очень хорош) R;
* научимся использовать встроенную справку;
* будем создавать, изменять и удалять переменные в глобальном окружении;
* используем функции с аргументами и без;
* напишем свои собственные функции.

### 1.2.2
#### Что такое R
* R -- язык программирования для научных вычислений и анализ данных с упором на визуальзацию и воспроизводимость
* R -- свободное кросс-платформенное программное обеспечение с открытым исходным кодом
* R -- интерпретируемый язык с интерфейсом командной строки (его не нужно компилировать)
* R -- мультипарадигменный язык, сочетающий в себе
    1. функциональное 
    2. процедурное
    3. объектно-ориентированное
    4. рефлексивное программирование
    
#### Плюсы
* R беспалтен, его код открыт
* Огромное количество встроенных статических тестов, математических алгоритмов, функций для анализа данных в академических и отраслевых исследованиях
* Расширяемость: модульная система пакетов (packages)
* Обширное сообщество разработчиков
* Полностью программируемая высокоуровневая графика
* Кросс-плватформенность, воспроизводимость результатов
* R становится популярным: статьи, книги, конференции, юзер группы

#### Минусы
* R достаточно сложен как язык программирования
* Документация некоторых методов труднодоступна без глубокого знания математических методов и статистических процедур
* Легко написать плохой (медленный, неподдерживаемый, нечитаемый) код
* Пакеты дополнений устаревают
* Можно заметить некоторую непоследовательность в именовании переменных и реализации методов

#### Помогите, ничего не работает!
* Это нормально
* Внимательно читаем текст ошибок и предупреждений
* Встроенная справка: `help("sin")`, `help.search("logarithm")`
* <https://cran.r-project.org/doc/FAQ/R-FAQ.html>
* Пользуемся поисковыми системами
* R Mailing List Archive
* [stackoverflow.com](https://stackoverflow.com)

### 1.2.3 Задача
В этом тесте отметьте верные утверждения о характеристиках языка R.
Итак, правда ли, что R:

* это язык с проприетарным (закрытым) кодом?
* чрезвычайно прост в освоении?
* создан для коммерческого использования?
* требует компиляции перед исполнением кода?
* **сочетает в себе несколько различных стилей (парадигм) программирования?**
* **это язык с открытым исходным кодом?**

### 1.2.4 Задача

### 1.2.5 Запускаем Rstudio
#### Встроенная справка
```{r}
help("sin")
```

Справка состоит из нескольких частей:

* Description -- описание на человеческом языке
* Details -- важные детали и подробности
* Value -- возвращаемое значение
* Examples -- примеры использования

В `R` одинарные и двойные кавычки **равнозначны**:
```{r}
help('sin')
```

А для некторых функций можно вообще не укхывать имя в кавычках:
```{r}
help(sin)
```

Это правило не работает например для зарезервированных слов:
```{r}
# help(for) # выполнение кода выдаст ошибку
help("for")
```

Вместо функции `help` можно использовать знак вопроса `?`:
```{r}
?sin
```

Ну и если мы хотим спросить что-то "запретное":
```{r}
?"function"
```

Во вкладке `History` появилась история наших действий в консоли. Тут есть поиск, иногда это полезно.

### 1.2.6 Задача
Воодушевлённый предыдущим видео, я решил посмотреть справку по использованию оператора if. 

Что произойдёт, если я наберу в консоли 
`?if`
и нажму Enter?

#### Решение
* Справка не откроется, потому что Enter нужно нажать ещё раз.
* **Справка не откроется: if -- зарезервированное слово, которое надо заключать в кавычки.**
* Откроется справка по циклам.
* Откроется справка с перечнем зарезервированных слов.
* Справка не откроется, потому что такого оператора нет, вместо него есть оператор ifelse.
* Следующий шагРешить снова

### 1.2.7 Задача
В R есть функция, которая реализует алгоритм [быстрого преобразования Фурье](https://en.wikipedia.org/wiki/Fast_Fourier_transform). Круто, да?

Попробуйте найти название этой функции поиском по справке или в google. 

Подсказки:

* Название алгоритма на английском можно узнать по ссылке выше.
* R чувствителен к регистру, то есть функция cos существует, а `COS` или `cOs` -- нет.
* Ответ содержит не более шести символов.

#### Решение
`fft`

### 1.2.8
#### Основы основ
* R -- интерпретируемый язык
* Команды исполняются построчно
* Командная строка расположена во вкладке "Console" в RStudio
```{r}
2 + 1
sin(pi/6)
```

#### Переменные
Нам не очень интересно использоват R как калькулятор. Мы хотим использовать понятия переменной и функции. Начнем с переменных. Чтобы создать переменную необходимо использовать оператор присваивания `<-` (Alt + -).

Обычно в языках программирования опертором присваивания является знак равно `=`. В R он тоже используется, но немного в других случаях.

Предположим, что мы хотим посчитать количество питомце в доме. Создадим две переменные `cats` и `dogs`, а затем их сумму присвоим новой переменной `pets`.
```{r}
cats <- 5
dogs <- 2
pets <- cats + dogs
```

Напечатано ничего не будет, просто сохранится переменная. Проверим, сохранилась ли переменная `pets`. Для этого необходимо просто написать ее имя:
```{r}
pets
```

Не любое имя переменной считается валидным!

#### Глобальное окружение
Поговорим о том месте, где живут созданные нами переменные.

* Каждая переменная определяемая нами живет в собственном *окружении*
* Окружение переменной -- это пространство, где ее можно найти; то место где она считается определенной
* Те переменные, что мы создали ранее, попадают в *глобальное окружение*; это то окружение, которое создается и считается самым широким
* Переменные из глобального окружения доступны во вкладке "Environment" в RStudio
* Либо можно просто ввести команду `ls()` в консоли
```{r}
ls() # list objects
```

#### Вызов функции
Поподробнее остановимся на функцииях и их аргументах, как их можно указывать.

В R определно множество встроенных функций, например `rnorm`:
```{r}
?rnorm    # посмотрим на справку по этой функции
rnorm(15) # генерирует 15 случайных чисел из нормального распределения
```

Аргументы функции можно указать по имени, через запятую по правилу ключ --> значение.
```{r}
rnorm(15, mean = 5, sd = 3)
```

На этом примере видет принцип разделение присваивания (`<-` и `=`): если мы указываем значение для переменной, то `<-`, если указываем значение аргумента, то используем оператор `=`.

#### Написание функций
Не всегда мы будем использовать уже существующие функции. Мы захотим использовать свои функции!

Для определения новой функции существует ключевое слово `function`; в круглых скобках *аргументы* функции, в фигурных -- **тело** функции (её код):
```{r}
returnTwo <- function(){
  y <- 2                # переменная, созданная в локальном окружении
  return(y)             # для возвращения переменной
}
```

Использование нашей функции:
```{r}
returnTwo()
```

#### Окружение функции
Локальное окружение (внутри функции) и глобальное окружение (то где эта функция находится) -- оазные вещи. 

Напишем функцию, прибавляющую к любому числу поступившему на ее вход 10:
```{r}
addten <- function(x) {
  x <- x + 10
}
```

И применим ее к нашим кошкам (ДА! Больше кошек!):
```{r}
addten(cats)
cats
```

Котиков больше не стало, хнык. Это произошло потому что мы **переприсвоили значение переменной `x` в локальном окружении** и оно не попало в глобальное.

Для того чтобы функция повлияла на глобальное окружение, необходимо пользоваться ключевым словом `return`:
```{r}
morecats <- function(x) {
  return(x + 10)          # просто засунем в return увеличение на 10
}
```

Проверим:
```{r}
morecats(cats)
```

#### Оператор глобального присваивания
Существует оператор **глобального присваивания**, `<<-`. Мы могли бы завести в теле функции новую переменную `moreDogs`, куда бы мы сложили результат прибавления 10 к аргументу `x`. И использую символ `<<-` мы создаем перменную не в локальном окружении, а в глобальном. 
```{r}
addten_2 <- function(x) {
  moreDogs <<- x + 10
}

addten_2(dogs)
dogs            # значение не поменялось, т.к. мы создали переменную в глобальном окружении
moreDogs        # а вот и она, новая переменная
```

Функция обладающие свойством действовать на глобальное оокружение называются функциями со *сторонним эффектом* (side effect). 

Но такая практика является сомнительной, ибо дает право функции право менять объекты в глобальном окружении.

#### Удаление переменных из окружения
Давайте проверим состояние глобального окружения, вызовем функцию `ls()`:
```{r}
ls()
```

Вердикт -- надо чистить.
```{r}
rm(dogs)
rm(moreDogs)
ls()
```

Но можно удалить все одним махом%
```{r}
rm(list = ls())
ls()
```

Будьте аккуратны при удалении переменных!

#### Полезное из коментов. 
##### Вопрос про `rm()` vs `qs()`
**Илья Ильюшёнок**
Сталкивался с тем, что `rm()` удаляет переменные из окружения, но в памяти они продолжают занимать место. Недавно узнал о существовании функции `gc()`. Пробовал сочетание `rm(value)` и `gc()` - помогает. Возможно, есть ещё какие-то способы решения этой проблемы?

**Антон Антонов**
Хороший вопрос, спасибо. Вы всё делаете правильно. На самом деле, `rm` действительно не высвобождает память, а просто уничтожает имя переменной. Память освобождается сборщиком мусора, который вызывается либо самим R, либо вручную (`gc` -- garbage collector). Манипулирование памятью в R -- достаточно хитрый механизм, и, строго говоря, даже вызов gc вручную не всегда гарантирует освобождение памяти. Похожий вопрос есть на [stackoverflow](http://stackoverflow.com/questions/1467201/forcing-garbage-collection-to-run-in-r-with-the-gc-command).

### 1.2.9
Самые внимательные зрители могли заметить, что на последнем слайде я указал
?`function`
Зарезервированное слово окружено здесь не одинарными ('function') и не двойными ("function") кавычками, а символами backtick (на моей клавиатуре этот символ расположен на клавише с буквой ё).
Так тоже можно! А вот при работе со строками (на второй неделе) лучше использовать кавычки.

### 1.2.10
Если в функции используется оператор <<-, влияющий на объекты в глобальном окружении, то подобное поведение называется ...

* **сторонним эффектом (side effect)**
* функциональным программированием (functional programming)
* локальным окружением (local environment)
* возвращаемым значением (return value)

### 1.2.11
R может послужить хорошей заменой вашему настольному калькулятору. Например, посчитайте, чему равно значение двоичного логарифма от квадрата синуса арктангенса единицы. 
Подсказки:

Справку по тригонометрии мы вызывали неоднократно.
Я уже упоминал, как найти логарифм. Двоичный логарифм там же. 
Возведение в степень — оператор ^.
Ответ — целое число. 
P.S. Что значит у вас нет настольного калькулятора?!

#### Решение
```{r}
log2(
  sin(
    atan(1)
  )^2
)
```

### 1.2.12
Бытует мнение, что если в скриптах попадаются куски одинакового кода длиной хотя бы в три строки, то надо срочно заводить функцию, а не копипастить одно и то же. Не берусь сказать, что это непреложная истина, но здравое зерно в таком принципе есть.  
Иными словами, пришло время потренироваться в написании функций.  
Напишите функцию, которая принимает на вход два числа и возвращает результат деления первого на второе.  
Оболочку я уже написал, с вас только тело функции.  
P.S. Как будет готово, поэкспериментируйте с вашей функцией: что будет, если вызвать

`divide(1, 0)`  
`divide(-99999, 0)`  
`divide(0, 0)`  
`divide(Inf, Inf)`  

Это тот результат, который вы ожидали?

#### Решение
```{r}
divide <- function(x, y) {
  x / y
}
```
Проверяем:
```{r}
divide(100, 10)
divide(1, 0)
divide(-99999, 0)
divide(0, 0)
divide(Inf, Inf)

```

### 1.2.13 Глоссарий
`?help`, `?help.search`  
`?"<-"`, `?ls`  
`?function`  
`?rm`  
`?rnorm`  

## 1.3 Векторы (часть 1)
### 1.3.1 План урока
В этом уроке мы

* рассмотрим ключевой объект языка -- вектор;
* посмотрим, какие есть удобные возможности для создания численных векторов;
* узнаем про типы векторов и правила их приведения;
* увидим, как действует принцип векторизации.

Вектора и векторизация -- это краеугольный камень языка R и ключ к написанию красивого и эффективного кода. Идеи, которые лежат в основе урока, редко встречаются в других языках программирования, так что будьте внимательны!

### 1.3.2
Представьте себе множество простых чисел от 1 до 100 или все слова английского языка начинающиеся на K. 

Какая мтруктура данных подходит для хранения такого рода объектов?

Разные языки программирования отвечают на это твопрос по разному.

* Вектор -- самая базовая структура данных в R
* На векторах основаниы более сложные структуры (матрицы, список, фактор, дата фрейм)
* Векторизация -- одна из ключевых концепций языка R

$$
f:
\begin{bmatrix}
  x_1 \\
  x_2 \\
  \vdots \\
  x_m
\end{bmatrix}
\longrightarrow
\begin{bmatrix}
  f(x_1) \\
  f(x_2) \\
  \vdots \\
  f(x_m)
\end{bmatrix}
$$

Представим, что у нас есть вектор длины $m$ и мы хотим получить другой вектор, который является результатом применения некоей функции $f$ к каждому элементу вектора. Если бы мы программировали на классическом императивном языке (C, C++), то на пришлось бы сделпть слеждующее:

* завести новую переменную
* указать ее длину (определить количество памяти под нее)
* указать тип
* завести цикл и применить к каждому элементу $x_i$ функцию $f$
* записат результат в конечный вектор

Так вот, для того, чтобы сделать тоже самое в R чаще всего прийдется написать $f(x)$ и все. И все эти действия будут призведены автоматически. 

#### Вектор
* Вектор -- **индексированный** набор данных **одного типа**
* R не делает различия между скалярными и векторными величинами, т.е. скаляр -- это вектор длины 1
* Индексация векторов начинается с единицы (не с нуля!)
* Для создания вектора можно использовать функцияю `vector`

Как бы мы сделали в обычном язык:
```{r}
x <- vector(length = 2) # задали длину ветора и его имя
x[1] <- 5               # задали первое значение
x[2] <- 8               # задали второе значение
x                       # вывели на экран
```

Но в R такая запись излишня (хотя и является абсолютно корректной).

#### Создание векторов: функция `c`
Вместо поэлементного присваивания используют компактную запись:
```{r}
x <- c(5, 8)
x
```

Функция `c` может быть вложенной и принимать переменные, и количество этих перменных может быть не ограничено:
```{r}
y <- c(x, 1, c(3, 4), x, NA)
y
```

#### Создание векторов: оператор `:`
Применение функции `с` требует перечисления всех элементов будущего вектора. Очень часто бывает так, что нам необходимо создать числовую последовательность с шагом 1.

Вот для создания такого рода последовательностей в `R` существует оператор двоеточие `:`:
```{r}
5:9
3:-1
1:pi    # именно челочисленный шаг
pi:1    # именно челочисленный шаг
```

#### Создание векторов: функция `seq`
Для создания последовательностей с шагом отличным от единицы:
```{r}
seq(1, 2, by = 0.25)       # от 1 до 2 с шагом 0.25
seq(3, 4, length.out = 5)  # от 3 до 4 с длиной вектора 5, шаг вычисляется автоматически
seq(3, 4, length = 5)      # не обязательно указывать имя аргумента целиком, достаточно тольуо уникального префикса

```

#### Создание векторов: функция `rep`
Повторение векторов
```{r}
rep(1:3, times = 3)       # повтор вектора три раза
rep(1:3, each = 3)        # повтор каждого элемента вектора три раза
rep(1:3, length.out = 5)  # для нецелого кол-ва повторений
```

### 1.3.3 Задача
В R существует множество операторов, как бинарных (требующих двух аргументов, например, `*`), так и унарных (требующих одного аргумента, например, `?`). Сопоставьте следующие бинарные операторы языка с их названиями.

К слову, приоритет операторов (порядок их действия) описан в справке `?Syntax`.

#### Ответы
* `<-` -- Оператор присваивания
* `<<-` -- Оператор глобального присваивания
* `<=` -- Меньше либо равно
* `^` -- Возведение в степень
* `:` -- Создание числовых векторов с шагом 1
* `/` -- Деление

### 1.3.4 Задача
Концепция *векторизации* подразумевает, что

#### Ответы
* при создании вектора не нужно указывать его тип.
* **некоторые функции и операторы действуют поэлементно.**
* для операций с векторами необходимо использовать циклы в явном виде.
* вместо поэлементного присваивания можно воспользоваться функцией c.
* индексация векторов начинается с единицы.

### 1.3.5 Решение задач
#### Традиции, традиции
```{r}
hello <- "Hello, world"   # в шлобальном окружении сразу появилась переменная hello
print(hello)              # распечатаем
hello                     # в консоли работает и так; но есди мы в batch режиме то только через print
```

#### Трудности перевода
```{r}
c(1, 3, 5)   # нужно быть осторожным, чтобы не спутать раскладку клавиатуры
```

#### Особенность чисел double (плавающая точка):
```{r}
0.1 + 0.1 == 0.2    # выдаст TRUE
0.1 + 0.05 == 0.15  # выдаст FALSE
```
Числа с плавающей точкой хранятся особым образом, поэтому оператор двойного равенства здесь неуместен.

Для того чтобы корректно сравнивать числа `double`, нужна функция `all.equal()`:
```{r}
all.equal(0.1 + 0.05, 0.15)
```

Эта особенность очень хорошо задокументрована:

* R FAQ 7.31
* google "R why are these numbers not equal"
* <https://stackoverflow.com/questions/9508518/why-are-these-numbers-not-equal>










