---
title: "Введение в базы данных"
author: "Иван Савин"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=F)
```

# 1. Введение в базовые операции SQL
## 1.1 Термины и определения
### 1.1.3 
Из этого курса мы узнаем, как работае база данных, как спроектировать базу данных. Так же получим некие практические навыки работы с реляционными БД.

Для кого этот курс:

* Узнать об одном из наиболее популярных способов **персистентного** (длительного) хранения данных
* Что-то слышали или сталкивались с базами данных, но знания не **систематизированы**
* Хотели бы сменить профиль деятельности, стать **аналитиком**, **разработчиком**, системным администратором БД
* Хотите попробовать работу с БД, чтобы понять , интересно ли вам

### 1.1.4 План курса
1. **Базовые операции SQL** -- как стать на "ты" с базами данных
2. **Основы реляцилнных СУБД** -- как написать запрос любой сложности; составление более сложных запросов с использованием нескольких сужностей, выборке из нескольких таблиц
3. **Проектирование БД** -- от концепции до физической структуры; все этапы, начиная от концепций и заканчивая физическим воплощением
4. **Использование ORM** -- связь БД с концепциями ООП
5. **Администрирование MySQL и оптимизация запросов** - как стать системным администратором БД
6. **Нереляционные СУБД** -- когда и как сказать *"Not Only SQL"*

#### Технологии и инструменты
##### СУБД:

* **MySQL** -- доминирующая РСУБД среди свободного ПО
* **MongoDB** -- наиболее популярная документоориентированная СУБД; движок для проектирования баз с не четкой или часто меняющейся схемой
* **Redis** -- наиболее стабильная СУБД типа "ключ-значение"; основное преимущество - быстрый доступ к данным

##### Проектирование:

* **MySQL Workbench** -- популярный и свободный инструмент выполнения запросов и проектирования БД
* **Ваш любимый ORM** (*наш* - Django ORM)  -- на любом популярном языке есть несколько вариантов

### 1.1.5 Основные понятия БД

* **Сущность** (Entity) -- класс, хранящийся в базе данных, таблица
* **Объект**(Object)  -- экземпляр сущности
* **Атрибут** (Attribute) -- свойства, характеризуюшие сущность, название столбца в таблице
* **Кортеж** (Tuple) -- строка в таблице, набор значений конкретных атрибутов
* **Домен** (Data domain) -- набор допустимых значений атрибута
* **Идентификатор** (ID, Identifier) -- атрибут с уникальным значением для данной таблицы

### 1.1.6 Области применения БД

* **Банки, картотеки, любые крупные системы**, в которых нужно хранить и изменять данные, а также иметь доступ к ним с разными ролями (системы, где уже не обойтись *xls-файликом*). Файловая система - иерархическая БД, ее можеет не хватить.
* **Веб-сайты** -- сервер испольует БД для удобства управления информацией и взаимодействия с пользователем.
* **Приложения (мобильные и десктопные)** используют локальные базы для удобства хранения данных по некоторым правилам,
* **Любой программный продукт**, подразумевающий отделение бизнес-логики и уровня хранения данных

### 1.1.7 Архитектура Системы Управления Базой Данных
#### Основные компоненты

* **Ядро** -- оперирование процессами, сеть, взаимодействие с памятью, файловая система и т.д.
* **Диспетчер данных** -- транзакции, кэш, проверка доступа к данным
* **Диспетчер запросов** (*самый важный!*) -- парсер (он проверяет валидность запросов), оптимизатор запросов , исполнитель
* **Набор инструментов для служебных операций** -- резервное копирование, восстановление, мониторинг

### 1.1.8 Характеристики СУБД
#### Преимужества

* Простая схема данных для полльзователья
* Логическая и физическая независимость от данных
* Целостность и защищенность данных 
* Методологический подход к проктированию

#### Недостатки

* Относительная низкая скорость доступа к данным
* Не универсальное решение для любой предметной области
* Меньшая гибкость при добавлении своих типов данных и операций
 
### 1.1.9 Язык SQL
**SQL** Structured Query Language -- язык структурированных запросов; наиболее популярный язык используемый в СУБД

#### Диалекты
* Oracle
* MySQL
* PostgreSQL
* MS SQL
* SQLite
* Access

## 1.2 Базовые операции SQL
### 1.2.1 Полезная информация к уроку
В видеоуроках представлены в том числе скринкасты выполнения SQL-запросов в среде MySQL Workbench. Слушатели также могут использовать эту среду в целях обучения. Все тестовые примеры, используемые в уроках, доступны на [GitHub](https://github.com/amyasnov/stepic-db-intro) для ознакомления. Импорт примеров на локальные машины слушателей не является необходимым для выполнения заданий.

#### Важное пояснение
Все запросы в этом и следующем уроке нужно выполнять через браузер (шаги с заданиями). Ничего ставить на свои компьютеры для прохождения заданий не нужно.

При выполнении запросов через браузер следуйте правилам:

* База уже выбрана и дополнительно писать команду **use** не нужно.
* Система принимает один запрос за раз. Если вы хотите попробовать различные запросы, то выполняйте их по одному, но помните, что каждый раз запрос выполняется на изначальных данных.

#### Используемое ПО, установка
##### 1. Сервер  MySQL
В зависимости от используемой платформы (Windows, Linux, MacOS X) используются различные способы установки.

##### **MS Windows**
Необходимо скачать дистрибутив [отсюда](https://dev.mysql.com/downloads/mysql/).
Запустить скачанный установщик и следовать инструкциям мастера.

##### **Linux**
Необходимо установить пакет сервера MySQL с помощью пакетного менеджера системы (apt, yum и др.)
```{bash eval=F}
sudo apt-get install mysql-server
sudo apt-get install mysql-workbench
```

##### **Mac OS X**
Два варианта установки:

* Необходимо установить пакет сервера MySQL с помощью пакетного менеджера brew, MacPorts.
* Необходимо скачать дистрибутив [отсюда](https://dev.mysql.com/downloads/mysql/). Запустить скачанный установщик и следовать инструкциям мастера.

##### 2. Среда MySQL Workbench
Необходимо установить скачанный [отсюда](http://dev.mysql.com/downloads/workbench/) дистрибутив среды. После скачивания необходимо установить среду с помощью мастера установки или пакетного менеджера.

####  Импорт и работа с тестовыми БД
Для того, чтобы использовать тестовые БД необходимо выполнить следующие действия:

1. Клонировать на локальную машину или скачать в виде архива [репозиторий](https://github.com/amyasnov/stepic-db-intro) с примерами
2. Запустить среду MySQL Workbench
3. Создать новое соединение с установленным предварительно сервисом MySQL (для удобства можно использовать пользователя root)
4. Открыть в MySQL Workbench файл модели (например, **billing_simple.mwb**)
5. В меню Database выбрать пункт Forward Engineer, далее следовать по мастеру 
6. При выборе соединения - выбрать соединение, созданное на шаге 3; для добавления тестовых данных в БД выбрать пункт "Generate INSERT statements for tables"; при необходимости выбрать пункты удаления схемы БД и объектов БД; дождаться исполнения сгененированного скрипта, в процессе его выполнения не должно быть ошибок.
7. Закрыть вкладку с моделью.
8. На главной странице среды выбрать двойным кликом созданное на шаге 3 соединение.
9. В списке схем необходимо выбрать двойным щелчком интересующую для текущей работы.
10Создать новую вкладку для выполнения запроса в меню File пункт New Query Tab

В результате этих действий в среде должно быть активным соединение с одной из БД на сервере.

Ха! как бы не так! Читаем комменты, там все по-русски написано :)

#### Настройка Workbench от Владимира Семёнова

* Workbench загрузилась, тёмный экран приветствия, сверху одна закладка со значком домика, под ней строка меню, ниже три окна: MySQL Connections, Models, Shortcuts.

* В своём родном браузере качаем с <https://github.com/amyasnov/stepic-db-intro> папку week_1 (а пускай даже и кнопкой Download ZIP на гитхабе), сохраняем себе в папку

* В Workbench'е file->open model->свежескаченная week_1->billing_simple.mwb.

* Рядом со вкладкой домика открылась вкладка "MySQL Model". Теперь Database->Forward Engineer... Открылся мастер, нём:
  + Connection Options - здесь только если Ваш мастер-пасс ввести (кнопка Store in Keychain), так всё по умолчанию - 127.0.0.1; 3306... NEXT
  + Options - здесь ставим галочку Generate INSERT Statements for Tables... NEXT
  + Select Objects - NEXT
  + Review SQL Script -NEXT
  + Commit Progress - Как все галочки появятся, CLOSE

* Но мы ещё не подключены к своему серверу! Переходим на вкладку "домик", плюсик рядом с надписью MySQL Connections, вводим Connection name (fex test), OK. Появился квадратик с дельфинчиком, даблклик на него. открылась вкладка с названием подключения. Теперь, в этой вкладке File->New Query Tab, и вуаля! Следуем за лектором в волшебный и удивительный мир SQL-запросов. (Шорткаты для выполнения всего кода - Shft+Ctrl+Enter, текущая строка - Ctrl+Enter)

### 1.2.2 

бла-бла-бла

### 1.2.3 Простейшие запросы
Рассмотрим выборку данных из базы.

Нашим первым примером будет база платежной системы. Состоять она будет из одной таблицы "Платежи" (`billing`), которая будет хранить следующие атрибуты:

* Email отправителья -- `payer_email`
* Email получателя -- `recipient_email`
* Сумма платежа -- `sum`
* Валюта платежа -- `currency`
* Дата платежа -- `billing_date`
* Комментарий -- `comment`

```{r echo=F, eval=F}
library(DBI)
library(RMySQL)

# тчетная попытка присоединиться к локальной базе(((((
con_sql <- dbConnect(
  RMySQL::MySQL(), 
  database = 'billing_simple', 
  # database = 'sys', 
  host = "127.0.0.1",
  port = 3306,
  user = "root",
  password = "root"
)

# dbListTables(con_sql)

# в чанки с запросами при успешном присоединении добавить sql connection=con_sql
```

#### Ключевые слова `use`, `select`, `from`
Чтобы использовать конкретную базу данных, нужно перед ее менем написать ключевое слово `use`.

Выборка производится с помощью команды `select`, `*` означает все поля, `from` имя таблицы. Этоозначает, что выбирутся все поля из таблицы `billing` и отобразятся в результатах выборки. Мы видим все **атрибуты** (переменные, они же столбцы) и все **картежи** (наблюдения, они же строки)
```{sql eval=F}
use billing_simple;
select * from billing; 
```

Попробуем выбрать конкретный поля, например только имя отправителя и сумму:
```{sql}
use billing_simple;
select payer_email, sum from billing;
```

Атрибут `sum` неверно подсвечен как ключевое слово.

#### Ключевое слово `WHERE`
С помощью ключевого слова `WHERE` мы можем указыввать условия для выборк запроса, т.е. мы вернем картежи удовлетворяющие условию:
```{sql}
use billing_simple;
select * from billing WHERE sum>900;
```

#### Ключевое слово `AND`
Условия можно комбинировать при помощи ключевого слова `AND`:
```{sql}
use billing_simple;
select * from billing 
  WHERE sum>900 AND currency='CHF';
```

#### Ключевое слово `IN`
Чтобы указать несколько значений для атрибута, нужно использовать конструкцию IN, указав список возможных значений для нашей выборки:
```{sql}
use billing_simple;
select * from billing 
  WHERE sum>900 AND currency IN ('CHF', 'GBP');
```

Таким образом, мы выбрали все операции с суммой больше 900, в швейцарских франках и в английских фунтах.

#### Ключевое слово `NOT`
Добавив к конструкции слово `NOT` мы сможем инверсировать выборку:
```{sql}
use billing_simple;
select * from billing 
  WHERE sum>900 AND currency NOT IN ('CHF', 'GBP');
```

### 1.2.4
бла-бла-бла перед заданием

### 1.2.5 Задача
Необходимо вывести поступления денег от пользователя с email `vasya@mail.com`
```{sql}
use billing_simple;
select * from billing WHERE payer_email='vasya@mail.com'
```

### 1.2.6 Вставка данных
#### Вставка данных во все атрибуты
Чтобы добавить запись в таблицу необходимо использовать конструкцию `INSERT INTO`, и далее перечислить список значений атрибутов, причем в том же порядке, в котором они находятся в таблице:
```{sql}
use billing_simple;
INSERT INTO billing VALUES (
'alex@mail.com',
'leo@mail.com',
'500',
'MYR',
'2010-08-20',
'Here are some money for you'
);
```

Затем попробуем найти ее следующим запросом:
```{sql}
use billing_simple;
select * from billing 
  WHERE payer_email='alex@mail.com'
  AND recipient_email='leo@mail.com'
  AND sum=500.00;
```

#### Вставка данных не во все атрибуты
Для этого нужно перечислить те атрибуты, в которые мы хотим внести данные:
```{sql}
use billing_simple;
INSERT INTO billing (
  payer_email, recipient_email,
  sum, currency, billing_date
)
VALUES (
'alex@mail.com',
'leo@mail.com',
'500',
'MYR',
'2010-08-20'
);
```

Обратите внимание на конструкцию в скобках после имени таблицы, здесь идет перечисление атрибутов, в которые мы хотим вставить данные.

### 1.2.7 Обновление записей в таблице
#### Ключевые слова `UPDATE` и `SET`
Обновление записей в таблице происходит при помощи ключевого слова `UPDATE` и `SET`. Мы указываем какие именно **поля** и каким **значением** нужно изменить.

```{sql eval=F}
use billing_simple;
UPDATE billing SET currency='USD';
```

Данный запрос полностью обновит таблицу `billing` и установит для всех записей `currency` равной **USD**

Так делать не стоит))))

Поэтому нужно указать какие именно картежи мы хотим обновить!
```{sql}
use billing_simple;
UPDATE billing 
  SET currency='USD'
  WHERE payer_email='alex@mail.com'
    AND recipient_email='leo@mail.com'
    AND sum=500.00;
```

### 1.2.8 Задача
Добавьте в таблицу одну запись о платеже со следующими значениями:

* email платильщика: *'pasha@mail.com'*
* email получателя: *'katya@mail.com'*
* сумма: *300.00*
* валюта: *'EUR'*
* дата операции: *14.02.2016* 
* комментарии: *'Valentines day present)'*

```{sql}
use billing_simple;
INSERT INTO billing VALUES (
  'pasha@mail.com',
  'katya@mail.com',
  '300.00',
  'EUR',
  '2016-02-214',
  'Valentines day present)'
);
```

### 1.2.9 Задача
Измените адрес плательщика на *'igor@mail.com'* для всех записей таблицы, где адрес плательщика *'alex@mail.com'*.

```{sql}
use billing_simple;
UPDATE billing 
  SET payer_email='igor@mail.com'
  WHERE payer_email='alex@mail.com';
```

### 1.2.10 Задача
Удалите из таблицы записи, где адрес плательщика или адрес получателя установлен в неопределенное значение или пустую строку.
```{sql}
DELETE FROM billing 
WHERE (payer_email is null or payer_email = '') or
      (recipient_email is null or recipient_email = '');
```

## 1.3 Агрегация данных
### 1.3.1
Вводное бла-бла-бла

### 1.3.2
Агрегация данных является одним из самых мощных инструментов для работы с данными.

Примеры информационных потребностей:

* суммировать значения по указанному атрибуту для записейй с определенными условиями
* статистика в разрезе значений указанного атрибута

Рассмотрим новую базу -- **База услуг компании**:

Одна таблица с полями:

* Название проекта -- `project_name`
* Имя клиента -- `client_name`
* Срок начала работы (не указан, если проект не начат) -- `project_start`
* Срок сдачи -- `project_finish`
* Бюджет -- `budget`

#### Просто посмотрим на таблицу
```{sql}
use project_simple;
select * from project;
```

#### Подсчет количества строк; `COUNT`
Для начала, давайте просто подсчитаем кол-во строк в нашей таблице, для этого используем команду аггрегации `COUNT`. В качестве аргумента подставим любое значение
```{sql}
use project_simple;
select COUNT(1) from project;
```

#### Подсчет среднего значения; ``
Здесь в качестве аргумента нам нужно передат поле, по которому мы хотим посчитать среднее значение:
```{sql}
use project_simple;
select AVG(budget) from project;
```

#### Составление более сложного отчета
Найдем сколько в среднем дней уходит на выполнение проекта.

Для начала напишем запрос, который покажет нужные нам для отчета картежи:
```{sql}
use project_simple;
select 
   
from project;
```

В данном селекте

