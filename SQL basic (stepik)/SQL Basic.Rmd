---
title: "Введение в базы данных"
author: "Иван Савин"
output: 
  html_document:
    highlight: textmate
header-includes: \usepackage[english, russian]{babel}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = F)
```

# 1. Введение в базовые операции SQL
## 1.1 Термины и определения
### 1.1.3 Вводные слова
Из этого курса мы узнаем, как работае база данных, как спроектировать базу данных. Так же получим некие практические навыки работы с реляционными БД.

Для кого этот курс:

* Узнать об одном из наиболее популярных способов **персистентного** (длительного) хранения данных
* Что-то слышали или сталкивались с базами данных, но знания не **систематизированы**
* Хотели бы сменить профиль деятельности, стать **аналитиком**, **разработчиком**, системным администратором БД
* Хотите попробовать работу с БД, чтобы понять , интересно ли вам

### 1.1.4 План курса
1. **Базовые операции SQL** -- как стать на "ты" с базами данных
2. **Основы реляцилнных СУБД** -- как написать запрос любой сложности; составление более сложных запросов с использованием нескольких сужностей, выборке из нескольких таблиц
3. **Проектирование БД** -- от концепции до физической структуры; все этапы, начиная от концепций и заканчивая физическим воплощением
4. **Использование ORM** -- связь БД с концепциями ООП
5. **Администрирование MySQL и оптимизация запросов** - как стать системным администратором БД
6. **Нереляционные СУБД** -- когда и как сказать *"Not Only SQL"*

#### Технологии и инструменты
##### СУБД:

* **MySQL** -- доминирующая РСУБД среди свободного ПО
* **MongoDB** -- наиболее популярная документоориентированная СУБД; движок для проектирования баз с не четкой или часто меняющейся схемой
* **Redis** -- наиболее стабильная СУБД типа "ключ-значение"; основное преимущество - быстрый доступ к данным

##### Проектирование:

* **MySQL Workbench** -- популярный и свободный инструмент выполнения запросов и проектирования БД
* **Ваш любимый ORM** (*наш* - Django ORM)  -- на любом популярном языке есть несколько вариантов

### 1.1.5 Основные понятия БД

* **Сущность** (Entity) -- класс, хранящийся в базе данных, таблица
* **Объект**(Object)  -- экземпляр сущности
* **Атрибут** (Attribute) -- свойства, характеризуюшие сущность, название столбца в таблице
* **Кортеж** (Tuple) -- строка в таблице, набор значений конкретных атрибутов
* **Домен** (Data domain) -- набор допустимых значений атрибута
* **Идентификатор** (ID, Identifier) -- атрибут с уникальным значением для данной таблицы

### 1.1.6 Области применения БД

* **Банки, картотеки, любые крупные системы**, в которых нужно хранить и изменять данные, а также иметь доступ к ним с разными ролями (системы, где уже не обойтись *xls-файликом*). Файловая система - иерархическая БД, ее можеет не хватить.
* **Веб-сайты** -- сервер испольует БД для удобства управления информацией и взаимодействия с пользователем.
* **Приложения (мобильные и десктопные)** используют локальные базы для удобства хранения данных по некоторым правилам,
* **Любой программный продукт**, подразумевающий отделение бизнес-логики и уровня хранения данных

### 1.1.7 Архитектура Системы Управления Базой Данных
#### Основные компоненты

* **Ядро** -- оперирование процессами, сеть, взаимодействие с памятью, файловая система и т.д.
* **Диспетчер данных** -- транзакции, кэш, проверка доступа к данным
* **Диспетчер запросов** (*самый важный!*) -- парсер (он проверяет валидность запросов), оптимизатор запросов , исполнитель
* **Набор инструментов для служебных операций** -- резервное копирование, восстановление, мониторинг

### 1.1.8 Характеристики СУБД
#### Преимужества

* Простая схема данных для полльзователья
* Логическая и физическая независимость от данных
* Целостность и защищенность данных 
* Методологический подход к проктированию

#### Недостатки

* Относительная низкая скорость доступа к данным
* Не универсальное решение для любой предметной области
* Меньшая гибкость при добавлении своих типов данных и операций
 
### 1.1.9 Язык SQL
**SQL** Structured Query Language -- язык структурированных запросов; наиболее популярный язык используемый в СУБД

#### Диалекты
* Oracle
* MySQL
* PostgreSQL
* MS SQL
* SQLite
* Access

## 1.2 Базовые операции SQL
### 1.2.1 Полезная информация к уроку
В видеоуроках представлены в том числе скринкасты выполнения SQL-запросов в среде MySQL Workbench. Слушатели также могут использовать эту среду в целях обучения. Все тестовые примеры, используемые в уроках, доступны на [GitHub](https://github.com/amyasnov/stepic-db-intro) для ознакомления. Импорт примеров на локальные машины слушателей не является необходимым для выполнения заданий.

#### Важное пояснение
Все запросы в этом и следующем уроке нужно выполнять через браузер (шаги с заданиями). Ничего ставить на свои компьютеры для прохождения заданий не нужно.

При выполнении запросов через браузер следуйте правилам:

* База уже выбрана и дополнительно писать команду **USE** не нужно.
* Система принимает один запрос за раз. Если вы хотите попробовать различные запросы, то выполняйте их по одному, но помните, что каждый раз запрос выполняется на изначальных данных.

#### Используемое ПО, установка
##### 1. Сервер  MySQL
В зависимости от используемой платформы (Windows, Linux, MacOS X) используются различные способы установки.

##### **MS Windows**
Необходимо скачать дистрибутив [отсюда](https://dev.mysql.com/downloads/mysql/).
Запустить скачанный установщик и следовать инструкциям мастера.

##### **Linux**
Необходимо установить пакет сервера MySQL с помощью пакетного менеджера системы (apt, yum и др.)
```{bash eval=F}
sudo apt-get install mysql-server
sudo apt-get install mysql-workbench
```

##### **Mac OS X**
Два варианта установки:

* Необходимо установить пакет сервера MySQL с помощью пакетного менеджера brew, MacPorts.
* Необходимо скачать дистрибутив [отсюда](https://dev.mysql.com/downloads/mysql/). Запустить скачанный установщик и следовать инструкциям мастера.

##### 2. Среда MySQL Workbench
Необходимо установить скачанный [отсюда](http://dev.mysql.com/downloads/workbench/) дистрибутив среды. После скачивания необходимо установить среду с помощью мастера установки или пакетного менеджера.

####  Импорт и работа с тестовыми БД
Для того, чтобы использовать тестовые БД необходимо выполнить следующие действия:

1. Клонировать на локальную машину или скачать в виде архива [репозиторий](https://github.com/amyasnov/stepic-db-intro) с примерами
2. Запустить среду MySQL Workbench
3. Создать новое соединение с установленным предварительно сервисом MySQL (для удобства можно использовать пользователя root)
4. Открыть в MySQL Workbench файл модели (например, **billing_simple.mwb**)
5. В меню Database выбрать пункт Forward Engineer, далее следовать по мастеру 
6. При выборе соединения - выбрать соединение, созданное на шаге 3; для добавления тестовых данных в БД выбрать пункт "Generate INSERT statements for tables"; при необходимости выбрать пункты удаления схемы БД и объектов БД; дождаться исполнения сгененированного скрипта, в процессе его выполнения не должно быть ошибок.
7. Закрыть вкладку с моделью.
8. На главной странице среды выбрать двойным кликом созданное на шаге 3 соединение.
9. В списке схем необходимо выбрать двойным щелчком интересующую для текущей работы.
10Создать новую вкладку для выполнения запроса в меню File пункт New Query Tab

В результате этих действий в среде должно быть активным соединение с одной из БД на сервере.

Ха! как бы не так! Читаем комменты, там все по-русски написано :)

#### Настройка Workbench от Владимира Семёнова

* Workbench загрузилась, тёмный экран приветствия, сверху одна закладка со значком домика, под ней строка меню, ниже три окна: MySQL Connections, Models, Shortcuts.

* В своём родном браузере качаем с <https://github.com/amyasnov/stepic-db-intro> папку week_1 (а пускай даже и кнопкой Download ZIP на гитхабе), сохраняем себе в папку

* В Workbench'е file->open model->свежескаченная week_1->billing_simple.mwb.

* Рядом со вкладкой домика открылась вкладка "MySQL Model". Теперь Database->Forward Engineer... Открылся мастер, нём:
  + Connection Options - здесь только если Ваш мастер-пасс ввести (кнопка Store IN Keychain), так всё по умолчанию - 127.0.0.1; 3306... NEXT
  + Options - здесь ставим галочку Generate INSERT Statements for Tables... NEXT
  + SELECT Objects - NEXT
  + Review SQL Script -NEXT
  + Commit Progress - Как все галочки появятся, CLOSE

* Но мы ещё не подключены к своему серверу! Переходим на вкладку "домик", плюсик рядом с надписью MySQL Connections, вводим Connection name (fex test), OK. Появился квадратик с дельфинчиком, даблклик на него. открылась вкладка с названием подключения. Теперь, в этой вкладке File->New Query Tab, и вуаля! Следуем за лектором в волшебный и удивительный мир SQL-запросов. (Шорткаты для выполнения всего кода - Shft+Ctrl+Enter, текущая строка - Ctrl+Enter)

### 1.2.2 

бла-бла-бла

### 1.2.3 Простейшие запросы
Рассмотрим выборку данных из базы.

Подключаем модуль `billing_simple` взятый [здесь](https://github.com/amyasnov/stepic-db-intro/blob/master/week_1/billing_simple.mwb)

База состоит из одной таблицы "Платежи" (`billing`), которая хранит следующие атрибуты:

* Email отправителья -- `payer_email`
* Email получателя -- `recipient_email`
* Сумма платежа -- `sum`
* Валюта платежа -- `currency`
* Дата платежа -- `billing_date`
* Комментарий -- `comment`

```{r echo=F, eval=F}
library(DBI)
library(RMySQL)

# тчетная попытка присоединиться к локальной базе(((((
con_sql <- dbConnect(
  RMySQL::MySQL(), 
  database = 'billing_simple', 
  # database = 'sys', 
  host = "127.0.0.1",
  port = 3306,
  USEr = "root",
  password = "root"
)

# dbListTables(con_sql)

# в чанки с запросами при успешном присоединении добавить sql connection=con_sql
```

#### Ключевые слова `USE`, `SELECT`, `FROM`
Чтобы использовать конкретную базу данных, нужно перед ее менем написать ключевое слово `USE`.

Выборка производится с помощью команды `SELECT`, `*` означает все поля, `FROM` имя таблицы. Этоозначает, что выбирутся все поля из таблицы `billing` и отобразятся в результатах выборки. Мы видим все **атрибуты** (переменные, они же столбцы) и все **картежи** (наблюдения, они же строки)
```{sql eval=F}
USE billing_simple;
SELECT * FROM billing; 
```

Попробуем выбрать конкретный поля, например только имя отправителя и сумму:
```{sql}
USE billing_simple;
SELECT payer_email, sum FROM billing;
```

Атрибут `sum` неверно подсвечен как ключевое слово.

#### Ключевое слово `WHERE`
С помощью ключевого слова `WHERE` мы можем указыввать условия для выборк запроса, т.е. мы вернем картежи удовлетворяющие условию:
```{sql}
USE billing_simple;
SELECT * FROM billing WHERE sum>900;
```

#### Ключевое слово `AND`
Условия можно комбинировать при помощи ключевого слова `AND`:
```{sql}
USE billing_simple;
SELECT * FROM billing 
  WHERE sum>900 AND currency='CHF';
```

#### Ключевое слово `IN`
Чтобы указать несколько значений для атрибута, нужно использовать конструкцию IN, указав список возможных значений для нашей выборки:
```{sql}
USE billing_simple;
SELECT * FROM billing 
  WHERE sum>900 AND currency IN ('CHF', 'GBP');
```

Таким образом, мы выбрали все операции с суммой больше 900, в швейцарских франках и в английских фунтах.

#### Ключевое слово `NOT`
Добавив к конструкции слово `NOT` мы сможем инверсировать выборку:
```{sql}
USE billing_simple;
SELECT * FROM billing 
  WHERE sum>900 AND currency NOT IN ('CHF', 'GBP');
```

### 1.2.4
бла-бла-бла перед заданием

### 1.2.5 Задача
Необходимо вывести поступления денег от пользователя с email `vasya@mail.com`
```{sql}
USE billing_simple;
SELECT * FROM billing WHERE payer_email='vasya@mail.com'
```

### 1.2.6 Вставка данных
#### Вставка данных во все атрибуты
Чтобы добавить запись в таблицу необходимо использовать конструкцию `INSERT INTO`, и далее перечислить список значений атрибутов, причем в том же порядке, в котором они находятся в таблице:
```{sql}
USE billing_simple;
INSERT INTO billing VALUES (
'alex@mail.com',
'leo@mail.com',
'500',
'MYR',
'2010-08-20',
'Here are some money for you'
);
```

Затем попробуем найти ее следующим запросом:
```{sql}
USE billing_simple;
SELECT * FROM billing 
  WHERE payer_email='alex@mail.com'
  AND recipient_email='leo@mail.com'
  AND sum=500.00;
```

#### Вставка данных не во все атрибуты
Для этого нужно перечислить те атрибуты, в которые мы хотим внести данные:
```{sql}
USE billing_simple;
INSERT INTO billing (
  payer_email, recipient_email,
  sum, currency, billing_date
)
VALUES (
'alex@mail.com',
'leo@mail.com',
'500',
'MYR',
'2010-08-20'
);
```

Обратите внимание на конструкцию в скобках после имени таблицы, здесь идет перечисление атрибутов, в которые мы хотим вставить данные.

### 1.2.7 Обновление записей в таблице
#### Ключевые слова `UPDATE` и `SET`
Обновление записей в таблице происходит при помощи ключевого слова `UPDATE` и `SET`. Мы указываем какие именно **поля** и каким **значением** нужно изменить.

```{sql eval=F}
USE billing_simple;
UPDATE billing SET currency='USD';
```

Данный запрос полностью обновит таблицу `billing` и установит для всех записей `currency` равной **USD**

Так делать не стоит))))

Поэтому нужно указать какие именно картежи мы хотим обновить!
```{sql}
USE billing_simple;
UPDATE billing 
  SET currency='USD'
  WHERE payer_email='alex@mail.com'
    AND recipient_email='leo@mail.com'
    AND sum=500.00;
```

### 1.2.8 Задача
Добавьте в таблицу одну запись о платеже со следующими значениями:

* email платильщика: *'pasha@mail.com'*
* email получателя: *'katya@mail.com'*
* сумма: *300.00*
* валюта: *'EUR'*
* дата операции: *14.02.2016* 
* комментарии: *'Valentines day present)'*

```{sql}
USE billing_simple;
INSERT INTO billing VALUES (
  'pasha@mail.com',
  'katya@mail.com',
  '300.00',
  'EUR',
  '2016-02-214',
  'Valentines day present)'
);
```

### 1.2.9 Задача
Измените адрес плательщика на *'igor@mail.com'* для всех записей таблицы, где адрес плательщика *'alex@mail.com'*.

```{sql}
USE billing_simple;
UPDATE billing 
  SET payer_email='igor@mail.com'
  WHERE payer_email='alex@mail.com';
```

### 1.2.10 Задача
Удалите из таблицы записи, где адрес плательщика или адрес получателя установлен в неопределенное значение или пустую строку.
```{sql}
DELETE FROM billing 
WHERE (payer_email IS NULL OR payer_email = '') or
      (recipient_email IS NULL OR recipient_email = '');
```

## 1.3 Агрегация данных
### 1.3.1 План урока
В этом уоке мы рассмотрим такие функции как `DATEDIFF`, `AVG`, `MAX`, `MIN`, `GROUP BY`, `ORDER BY`, `DESC`

### 1.3.2 Основы агрегации данных
Агрегация данных является одним из самых мощных инструментов для работы с данными.

Примеры информационных потребностей:

* суммировать значения по указанному атрибуту для записейй с определенными условиями
* статистика в разрезе значений указанного атрибута

Рассмотрим новую базу -- **База услуг компании**; она находится [здесь](https://github.com/amyasnov/stepic-db-intro/blob/master/week_1/project_simple.mwb)

Одна таблица с полями:

* Название проекта -- `project_name`
* Имя клиента -- `client_name`
* Срок начала работы (не указан, если проект не начат) -- `project_start`
* Срок сдачи -- `project_finish`
* Бюджет -- `budget`

#### Просто посмотрим на таблицу
```{sql}
USE project_simple;
SELECT * FROM project;
```

#### Подсчет количества строк; `COUNT`
Для начала, давайте просто подсчитаем кол-во строк в нашей таблице, для этого используем команду аггрегации `COUNT`. В качестве аргумента подставим любое значение
```{sql}
USE project_simple;
SELECT COUNT(1) FROM project;
```

#### Подсчет среднего значения; `AVG`
Здесь в качестве аргумента нам нужно передат поле, по которому мы хотим посчитать среднее значение:
```{sql}
USE project_simple;
SELECT AVG(budget) FROM project;
```

#### Функция для вычисления разницы дат `DATEDIFF`
Найдем сколько в среднем дней уходит на выполнение проекта.

Для начала напишем запрос, который покажет нужные нам для отчета картежи:
```{sql}
USE project_simple;
SELECT
  project_finish,
  project_start,
  DATEDIFF(project_finish, project_start)
FROM project
```

В данном селекте используется функция `DATEDIFF` , которая показывает разницу между двумя датами. 

Далее в лекции сетуется на большое кол-во `NULL`  в полях с датами; в скачанной базе немного не так :(

Следующий запрос не учитывает `NULL`:
```{sql}
USE project_simple;
SELECT
  project_finish,
  project_start,
  DATEDIFF(project_finish, project_start)
FROM project WHERE project_finish IS NOT NULL;
```

Теперь из этого запроса нам нужно узнать среднее значене затраченных дней на проект. Просто добавим функцию `AVG` в троку с вычислением разницы дат.

```{sql}
USE project_simple;
SELECT
  AVG(DATEDIFF(project_finish, project_start))
FROM project WHERE project_finish IS NOT NULL;
```
```{sql}
USE project_simple;
SELECT
  AVG(DATEDIFF(project_finish, project_start))
FROM project WHERE project_finish IS NOT NULL;
```

#### Функции `MAX` и `MIN`
Давайте вычислим наибольшее и наименьшее значение:
```{sql}
USE project_simple;
SELECT
  MAX(DATEDIFF(project_finish, project_start))
  MIN(DATEDIFF(project_finish, project_start))
  AVG(DATEDIFF(project_finish, project_start))
FROM project WHERE project_finish IS NOT NULL;
```

#### Группировка данных `GROUP BY`
Для того, чтобы сделать наш отчет более детализированным, мы можем использовать группировку ранее аггрегированных данных по различным значениям какого-либо атрибута.

Давайте выясним наши показатели (среднее, минимально и максимальное) в разрезе каждого клиента. для этого добавим строку с `GROUP BY` в запрос, а так же наименование клиента в выборку:

```{sql}
USE project_simple;
SELECT
  client_name,
  MAX(datediff(project_finish, project_start)),
  MIN(datediff(project_finish, project_start)),
  AVG(datediff(project_finish, project_start))
FROM project WHERE project_finish IS NOT NULL
GROUP BY client_name;
```

#### Сортировка данных `ORDER BY`, `DESC`
Полезным будет сортировка данных, при помощи функции `ORDER BY`. В данном примере мы для наших показателей ввели псевдонимы (**alias**): `MAX_days`, `MIN_days`, `AVG_days`. Сортировка будет произведена от меньшего к большему:

```{sql}
USE project_simple;
SELECT
  client_name,
  MAX(datediff(project_finish, project_start)) AS MAX_days,
  MIN(datediff(project_finish, project_start)) AS MIN_days,
  AVG(datediff(project_finish, project_start)) AS AVG_days
FROM project WHERE project_finish IS NOT NULL
GROUP BY client_name
ORDER BY MAX_days;
```

Чтобы поменять порядок сортировки (на от большего к меньшему), нужно вставить `DESC` после переменной:
```{sql}
USE project_simple;
SELECT
  client_name,
  MAX(datediff(project_finish, project_start)) AS MAX_days,
  MIN(datediff(project_finish, project_start)) AS MIN_days,
  AVG(datediff(project_finish, project_start)) AS AVG_days
FROM project WHERE project_finish IS NOT NULL
GROUP BY client_name
ORDER BY MAX_days DESC;
```

#### Срез данных `LIMIT`
Эта функция показывает первые `n` кортежей (строк):
```{sql}
USE project_simple;
SELECT
  client_name,
  MAX(datediff(project_finish, project_start)) AS MAX_days,
  MIN(datediff(project_finish, project_start)) AS MIN_days,
  AVG(datediff(project_finish, project_start)) AS AVG_days
FROM project WHERE project_finish IS NOT NULL
GROUP BY client_name
ORDER BY MAX_days DESC
LIMIT 10;
```

#### Ошибки при составлении отчетов
Одной из частых ошибок, при составлении отчетов является некорректное указание параметров по которым группируется выражение. 

```{sql}
USE project_simple;
SELECT
  COUNT(1),
  AVG(budget),
  client_name
FROM project;
```

Данный запрос по словам лектора должен был выдать всего одну строку с рандомным клиентом. Но у меня выдает ошибку, мол не хватает `GROUP BY`; исправляем этот недочет:
```{sql}
USE project_simple;
SELECT
  COUNT(1),
  AVG(budget),
  client_name
FROM project
GROUP BY client_name;
```

Вот! Теперь выборка корректна!

### 1.3.3 База онлайн магазина
Подключаем модуль `store_simple.mwb` взятый [здесь](https://github.com/amyasnov/stepic-db-intro/blob/master/week_1/store_simple.mwb)

В данной базе находится одна таблица `store` с четыремя атрибутами:

* Название товара -- `product_name`
* Название категории -- `category`
* Цена -- `price`
* Количество продаж товара -- `sold_num`

Количество товаров в каждой категории:
```{sql}
USE store_simple;
SELECT category, COUNT(1) FROM store
GROUP BY category
ORDER BY category;
```

#### Комментарии в SQL
Чтобы закомментировать текст в запросе, его нужно поместить между `/*`  и `*/`
```{sql}
/*
закомментированная строка
еще одна
*/
```

### 1.3.4 Задача
База `project_simple`.

Выведите общее количество заказов компании.

```{sql}
USE project_simple;
SELECT COUNT(1) FROM project;
```

### 1.3.5 Задача
База `store_simple`.

Выведите количество товаров в каждой категории. Результат должен содержать два столбца: 

* название категории, 
* количество товаров в данной категории.

```{sql}
USE store_simple;
SELECT category, COUNT(1) FROM store
GROUP BY category;
```

### 1.3.6 Задача
База `store_simple`.

Выведите 5 категорий товаров, продажи которых принесли наибольшую выручку. Под выручкой понимается сумма произведений стоимости товара на количество проданных единиц. Результат должен содержать два столбца: 

* название категории,
* выручка от продажи товаров в данной категории.

```{sql}
USE store_simple;
SELECT 
  category, 
  SUM(price*sold_num) AS sum_cat
FROM store
GROUP BY category
ORDER BY sum_cat DESC
LIMIT 5;
```

### 1.3.7 Задача
База `project_simple`.

Выведите в качестве результата одного запроса общее количество заказов, сумму стоимостей (бюджетов) всех проектов, средний срок исполнения заказа в днях.

NB! Для вычисления длительности проекта удобно использовать встроенную функцию [datediff()](https://dev.mysql.com/doc/refman/5.5/en/date-and-time-functions.html#function_datediff).

```{sql}
USE project_simple;
SELECT
  COUNT(1),
  SUM(budget),
  AVG(DATEDIFF(project_finish, project_start))
FROM project
```


## 2.1 Введение в реляционную модель данных
### 2.1.1 План урока

* Модель данных
* Общее описание реляционной модели. Структурная часть. Тип данных, домен.
* Структурная часть. Атрибут, кортеж.
* Структурная часть. Схема отношения, отношение, свойства.
* Манипуляционная часть
* Ограничение целостности сущности
* Ограничение ссылочной целостности
* Преимущества и недостатки РМД

### 2.1.2 Введение
В первую очередь мы рассмотри реляционную модель базы данных, все ее ключевые моменты и приемущества.

Во-вторых немного поговорим об архитектуре ansys???? `Spark` и рекомендаци данного комитета по построению баз данных. 

Основную практическую часть модуля займет написание sql-запросов, таких же как и в реальных базах данных. В частности мы будем широко использовать объединение данных, полученных из разных запросов  использовать операторы `join` и `union`.

В конце мы немноо поговорим о триггерах и хранимых процедурах, как о важных компонентах поддержания целостности данных и возможности процедурной обработки внутри самой СУБД.

### 2.1.3 Модель данных
Модель данных описывается некоторыми частями. 

* Первая часть (структурная) -- **понятия** (объекты), характерные для данной модели данных;
* Вторая часть -- это набор **операций** и операторов, использующихся для работы с этими объектами
* Третья часть -- это **структурные ограничения** или ограничения доступа к данным в рамках этой модели

Именно об этом говорит **Кристофер Дейт**, описывая модель данных как набор из трех частей:

* **Структурная часть** -- например в иерархической БД это будет описание схемы данных в виде графа (дерева)
* **Манипуляционная часть** -- набор операторов, которые могут быть использованы для работы с данными
* **Ограничения целостности** -- это такие ограничения, котрые всегда будут выполняться в рамках одной модели

Оговоримся, что в рамках рассмотрения реляционных баз данных мы будем немного смешивать понятия реляционной БД и SQL модели данных. Делать мы это будем осознанно, для того, чтобы проще было понять набор объектов, набор операций и ограничений, которые имеются в реляционной БД.

А вконце мы как раз поговорим об их отличиях!

### 2.1.4 Вопрос
Укажите, пожалуйста, какое из описаний не относится к определению модели данных,

* Структурная часть
* **Процедурная часть**
* Ограничения целостности
* Манипуляционная часть

### 2.1.5 Реляционная модель данных
В данном уроке мы рассмотрим РМД сначала с формальной стороны, а затем уже на примерах.

План на степ:

* Структурная часть
    + Набор понятий, родовая структура
* Манипуляционная часть
    + Операции над данными
* Ограничение целостности
    + Средства поддержания структуры и содержимого БД в соответствии модели данных

#### РМД. Структурная часть

* **Типы данных**. Согласно классической реляционной модели, все элементы (хранящиеся в БД реляционного типа) должны быть строго типизированы. Типы данных очень схожи сосвоимим родственниками из языков программирования. 
    + они определяются как некий набор **множества значений**, которые может принимать переменная
    + набор **операций**, которые могут применяться к элементам данного типа данных
    + и набор **литералов** для описания элементов
    
    Примеры:
    - **Целочисленные**: `INT`, `BIGINT`, `SMALLINT` и т.д.
    - **Данные с дробной частью:** `NUMERIC/DECIMAL`, `FLOAT/DOUBLE`
    - **Строковые:** `CHAR`, `VARCHAR`, `STRING`
    - **Календарные типы:** `DATE`, `TIME`, `DATETIME`, `TIMESTAMP`
    - **NULL:** такой тип данных явно используется, для указания отсутствия значения в некоей ячейке
    - **Другие:** `XML`, `JSON`
* **Домен**. 





