---
title: "Анализ данных в R. Часть 2"
author: "Анатолий Карпов"
output:
  html_document:
    highlight: tango
  pdf_document: default
header-includes: \usepackage[english, russian]{babel}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = F, # отрубаем всякие не шибко нужные сообщения
                      cache = T)   # врубаем сохранение кэша, ибо данные тяжеловаты и долго пересчитываются
library(Hmisc)
```

# 2 Подробнее о визуализации
## 2.1 Грамматика ggplot2, функция qplot
### 2.1.1 План урока
В этом уроке мы:

* познакомимся с основными элементами графической грамматики пакета ggplot2;
* научимся пользоваться функцией qplot для построения базовых графиков.

### 2.1.2 Теоретические материалы
В этом шаге я бы хотел собрать все теоретические материалы, на которые буду ссылаться в уроках:

* Самый хороший учебник [Cookbook for R](http://www.cookbook-r.com/Graphs/), в котором разобраны наиболее важные вопросы с примерами кода.
* [Документация](http://docs.ggplot2.org/current/) пакета ggplot2 с примерами кода для построения основных типов графиков.

Различные графические параметры:

* [типы точек](http://sape.inf.usi.ch/quick-reference/ggplot2/shape);
* [типы линий](http://sape.inf.usi.ch/quick-reference/ggplot2/linetype); 
* [цвета](http://sape.inf.usi.ch/quick-reference/ggplot2/colour).

### 2.1.3 Общие вводные слова

### 2.1.4 Основные грамматические конструкции ggplot2
Основная идея пакета заключается в том, что мы можем рассматривать процесс построения графика как последовательный процесс перемещения данных в графический вид, состоящий из нескольких этапов. Каждый этап является "грамматической единицей" построения графиков. Комбинируя эти грамматические единицы мы и получим график. Давайте разберемся что же это за этапы. 

#### Основные принципы (грамматические конструкции) ggplot2:
* **Aestetic attributes** - определяют какие данные будут на графике и где;
* **Geometric objects** - определяют, как именно будут отражены данные (линии, точки, столбики и т.д.);
* **Statistical transformation** - определяют, какие трансформации с данными будут отображены на графике (регрессионаая прямая или сглаживание) - не обязательно;
* **Scales** - какие именно значения (и как) будут отображены на графике (шкалы, сетки);
* **Coordinates** - система координат;
* **Faceting** - группировка данных (разбивка на фасетки).

В этом  заключается основная идея построения графика. Поэтапное конструирование.

### 2.1.5 Начало работы, qplot
Подгрузим библиотеку ggplot2:
```{r}
library(ggplot2)
```

#### Быстрый график qplot - quick plot
Подгрузим данный diamonds из пакетв ggplot2:
```{r}
data("diamonds")
```

Начнем с функции `qplot` которая ближе к базовой графике, чем к идеи `ggplot2`. Потому что она позволяет очень быстро нарисовать самые простые взаимосвязи, как бы угадывая за нас что мы хотим от данных. 

Разберем самый простой пример; посмотрим какие аргументы есть в функции. Это `x, y, data`. И построим график, в котором по оси `x` будеть переменная `price`, ну а данные - `diamonds`. Мы не сказали функции ни при помощи какого geom-а собирались строить график, в каком геометрическом пространстве, ни про какие доп настройки. И такая функция по умолчанию построит гистограмму:
```{r}
qplot(x = price, data = diamonds)
```

Т.е. если на вход `qplot` подать одну количественную переменную, то получится гистограмма.

Теперь добавим `y`. Если на входе две количественные переменные, то выйдет обычная диаграмма рассеивания:
```{r}
qplot(x = price, y = carat, data = diamonds)
```

А теперь отложим по оси `x` фактор (качественную переменную): `cut`. Пакет `ggplot2` не растеряется и отложит по оси `х` группы переменных, объединенных фактором `cut`:
```{r}
qplot(x = cut, y = carat, data = diamonds)
```

Еще одна особенность `qplot`, в качестве минимального аргументьа функции может быть поставлен вектор:
```{r}
v <- diamonds$carat
qplot(v)
```

Вот такой вот минимум настроек функции `qplot`. Видно, что не обязательно прописывать название аргумента, они идут по порядку (TAB'овая подсказка). 

### 2.1.6 Задача
Используя функцию `qplot`, постройте гистограмму переменной `depth` из данных `diamonds`. Сохраните график в переменную `depth_hist`.

#### Решение
```{r}
(depth_hist <- qplot(diamonds$depth))
```

### 2.1.7 Структура переменной графика qplot
Вот эта идея, что можно напрямую обращаться к переменной дата-фрейма, так же распространяется и на диаграмму рассеивания:
```{r}
qplot(diamonds$price, diamonds$carat)
```

При этом функция `qplot` является частью пакета `ggplot2` и обладает большим кол-вом преимуществ над базовой графикой `R`. Это и большее количество настроек и что более важно, возможность сохранять графики в переменные. 

Вот такой код создаст переменную `my_plot`:
```{r}
my_plot <- qplot(qplot(x = price,        # переменная на ось x
                       y = carat,        # переменная на ось y
                       data = diamonds)) # из какого дата-фрейма берем переменные
str(my_plot)
```

Этот список хранит в себе информацию о всех графических элементах составляющих график.

### 2.1.8 Еще пара важных особенностей функции qplot
Давайте разукрасим наш график. Это достигается всего-лишь добавлением одной строчки:
```{r}
qplot(x = price,
      y = carat,
      color = color, # добавляем цвет, через аргумент color
      data = diamonds)
```

Тут появляется некая двойственность записи, название аргумента совпадает со значением переменной :)

Давайте вручную пропишем, каким геометрическим объектом мы хотим отрисовать наши данные:
```{r}
qplot(x = price,
      y = carat,
      color = color, 
      data = diamonds,
      geom = "point") # указываем каким геометрическим объектом отрисовать наши данные
```

У точки есть параметры: размер `size` и форма `shape`:
```{r}
qplot(x = price,
      y = carat,
      color = color,
      shape = cut,     # форма точки - варианты огранки бриллиантов (cut)
      data = diamonds,
      geom = "point")
```

Предыдущий график получился слегка перегруженным, поэтому давайте посмотрим эти характеристики на меньшем дата-фрейме `mtcars`:
```{r}
qplot(mpg,
      hp,
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am), # добавим цвет с помощью переменной am
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl), # изменяем форму точек по кол-ву цилиндров в авто
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl),
      size = I(3),         # изменили размер точки; см справку по ф-ии I()
      data = mtcars)
```

### 2.1.9 Задача
Теперь давайте отобразим сразу три переменные на одном графике! 

Постройте диаграмму рассеивания `scatter plot` как в указанном ниже примере, результат сохраните в переменную `price_carat_clarity_points`.

* данные - `diamonds`
* ось x - `carat`
* ось y - `price`
* цвет точек - `clarity`

#### Решение
```{r}
(price_carat_clarity_points <- qplot(data = diamonds,
                                    x = carat,
                                    y = price,
                                    color = clarity))
```

### 2.1.10 Продолжаем накачивать qplot
Добавим прозрачности точкам:
```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl),
      size = I(5),        # немного увеичил размер точки для наглядности
      alpha = I(0.7),     # изменяем прозрачность точки
      data = mtcars)
```

Вернемся к гистограмме и явно пропишем её `geom`:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram")
```

Изменим цвет и заливку столбиков:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram",
      fill = I("white"),  # заливка
      col = I("black"))   # рамка
```

```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram",
      fill = color,       # заливка переменной
      col = I("black"))   
```

Немного поменяем способ отображения столбцов изменив `geom`:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "density",  # сменили geom
      fill = color,
      col = I("black"))   
```

```{r}
qplot(data = diamonds,
      x = price,
      geom = "density",
      fill = color,
      alpha = I(0.3),    # добавили прозрачность для наглядности 
      col = I("black"))   
```

#### Примечание
В лекции не сказано, но можно использовать совершенно любые `HEX` цвета, просто записывая их внутри функции `I( )`, что очень удобно :) Например `I('#66cc66')`.

### 2.1.11 Задача
Используя функцию `qplot`, постройте график плотности переменной `x` из данных `diamonds`. Сохраните график в переменную `x_density`.

#### Решение
```{r}
(x_density <- qplot(data = diamonds,
                   x = x,
                   geom = "density"))
```

### 2.1.12 Задача
Усложним задачу, постройте график плотности переменной `x` для каждой группы наблюдений по переменной `cut` из данных `diamonds`. Таким образом за цвет графика теперь отвечает переменная `cut`. Сохраните результат в переменную `x_cut_density`.

#### Решение
```{r}
(x_density <- qplot(data = diamonds,
                   x = x,
                   col = cut,
                   geom = "density"))
```

### 2.1.13 Задача
Давайте знакомиться с различными `geoms`. Документация пакета и весь список с примерами использования доступен [здесь](http://ggplot2.tidyverse.org/reference/). Вообще обратите внимание на документацию `ggplot2`, очень подробное описание основных возможностей пакета!

Давайте построим график `violin plot` для переменной `price` в каждой группе наблюдений по переменной `color`. Сохраните результа в переменную `price_violin`.

#### Решение
```{r}
(price_violin <- qplot(data = diamonds,
                       geom = "violin",
                       y = price,
                       x = color))
```

### 2.1.14 Заключение урока
Бла-бла-бла

## 2.2. Функция ggplot и различные geoms
### 2.2.1 План урока
В этом уроке мы:

* познакомимся поближе с функцией `ggplot`;
* разберем различные примеры `geoms`;
* поговорим подробнее о функции `stat_summary`;

### 2.2.2 Функция ggplot
Функция `ggplot` является самой главной заготовкой нашего графика. И требует на вход данные, которые мы хотим визуализировать; на самом деле этого достаточно:
```{r}
ggplot(diamonds)
```

Появилась некая заготовка графика. Мы пока просто создали холст для графика.

Теперь мы хотим сказать какие переменные будут отображены на графике. Для этого используется функция `aes()`. Давайте построим самый простой график, где по оси `x` будет отложена переменная `price`:
```{r}
ggplot(diamonds, aes(x = price))
```

На холсте появилась шкала значений переменной `price`. Он пустой, т.к. мы ничего не сказали про то, каким образом отобразить данные. Третьим этапом нам необходимо добавить некий геометрический объект или `geom`; это будет новый слой графика:
```{r}
ggplot(diamonds, aes(x = price)) +
  geom_histogram()
```

#### Минимальный набор атрибутов для построения графика:

* `ggplot(diamonds)` - чистый холст;
* `aes(x = price)` - какие переменный из diamonds мы хотим показать;
* `geom_histogram` - каким способом мы это хотим сделать.

#### График с несколькими переменными
```{r}
ggplot(diamonds, aes(price, carat)) # x и y можно опустить
```

Добавим geom с точками:
```{r}
ggplot(diamonds, aes(price, carat)) + 
  geom_point()
```

Основная фишка `ggplot` - мы не ограничены количеством `geom`'ов
```{r}
ggplot(diamonds, aes(price, carat)) + 
  geom_point() + 
  geom_smooth()
```

Все переменные, которые мы хотим перенести на график, на оси, в цвете, мы должны прописать в `aes`. Причем `aes` мы можем прописать как в заглавной `ggplot` (они будут работать на все `geom`'ы), так и в отдельных `geom`'ах (индивидуално). 
```{r}
ggplot(diamonds) + 
  geom_point(aes(price, carat)) + 
  geom_smooth(aes(price, carat))  # так тоже можно
```

Добавим переменную в `aes` для обозначения цветат точек:
```{r}
ggplot(diamonds, aes(x = price,
                    y = carat,
                    color = cut)) + # добавили переменную для цвета
  geom_point() + 
  geom_smooth()
```

Заметим, что наша переменная `color` разбивает на группы и точки и линии сглаживания. Однако, что делать, если мы хотим сохранить всего одну линию тренда? Нужно перенести переменную отвечающую за цвет только в нужный нам `geom`.
```{r}
ggplot(diamonds, aes(x = price,
                    y = carat)) + 
  geom_point(aes(color = cut)) +    # прописываем цвет только в этом geom'е
  geom_smooth()
```

### 2.2.3 
Поэтому внутри функци `ggplot` мы указываем данные и только те переменны, которые будут общими для всех `geom`'ов. А если хотим изменить что-то лишь для одного `geom`'а то эти изменения нужно прописывать именно в нем:

```{r}
ggplot(diamonds, aes(x = price,
                    y = carat)) + 
  geom_point(aes(color = cut),
             size = 0.5,      # размер точки; без I()
             alpha = .3) +    # прохрачность; без I(); десятичную дробь можно писать без нуля
  geom_smooth(size = 2,
              color = "red")
```

Настройки прописанные внутри одного `geom`'а никак не переходят на другой `geom`.

### 2.2.4 Набор данных airquality
Давайте посмотрим на данные `airquality`:
```{r}
str(airquality)
```

```{r}
library(dplyr)
glimpse(airquality) # этакий расширенный str() из пакета tibble
```

Для каждого месяца есть показатель температуры, давайте создадим новый дата-фрейм, в котором данные будут сгруппированы по месяцам, а затем схлопнем эти данные со средней температурой и средней скорости ветра:
```{r}
gr_airquality <- group_by(airquality, Month)
(t <- summarise(gr_airquality, 
                mean_temp = mean(Temp),
                mean_wind = mean(Wind)))
```

А теперь нарисуем график:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_point(aes(size = mean_wind)) + # размер точек вынесен отдельно
  geom_line()                         # линии для соединения точек
```

Линия показывает некий тренд температуры, а размер точек скорость ветра.

```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_point(aes(size = mean_wind),
             color = "red") + # покарсим точки в красный
  geom_line()
```

Наблюдаем нахлест линий на точки. Как это исправить? Просто поменять порядок `geom`'ов:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_line() +                      # поставили его первым
  geom_point(aes(size = mean_wind),
             color = "red")          # точки закроют линии
```

Есть такие `geom`'ы, котрые не зависят от `aes()` прописанных в `ggplot()`. Предположим, что мы хотим добавить на график горизонтальную линию на уровне $75$:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_line() +
  geom_point(aes(size = mean_wind),
             color = "red") +
  geom_hline(yintercept = 75,
             linetype = "dotted", 
             size = 1.2,
             color = "blue")      # эта линия не зависит от aes(Month, mean_temp); ну кроме границ
```

### 2.2.5 Рассмотрим geom_errorbar и geom_pointrange
Посмотрим описание `?geom_errorbar`. `Geom` ожидает от нас две переменные `ymax` и `ymin`, которые и будут означать минимальную и максимальную грпницу ошибки. `geom_errorbar` требует небольшой подготовки данных, а именно нужна группирующая переменная. `geom_pointrange` еще и среднюю точку нарисует.

Для начала сгруппируем и преобразуем данные:
```{r}
gr_mtcars <- group_by(mtcars, am)
(se_data <- summarise(gr_mtcars,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),  # вехняя граница ошибки
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg)))) # нижняя граница ошибки
```
А теперь нарисуем все это:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_errorbar(aes(ymin = y_min, 
                    ymax = y_max)) # здесь необходим aes, чтобы подтянуть данные из дата-фрейма
```

Изменим ширину и добавим средние точки:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) + # уменьшим ширину границ 
  geom_point(size = 3,        # размер
             shape = 21,      # форма точки
             fill = "white")  # цвет заливки
```

А теперь все то же самое, только `geom_pointrange`:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max))
```

Поколдуем над настройками:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max),
                  color = "red")
```

Добавим в изначальный дата-фрейм еще одну группировку:
```{r}
gr_mtcars_2 <- group_by(mtcars, am, vs)     # добавили vs
(se_data_2 <- summarise(gr_mtcars_2,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),  # вехняя граница ошибки
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg)))) # нижняя граница ошибки
```

Теперь у нас четыре группы данных. Нарисуем их:
```{r}
ggplot(se_data_2, aes(x = factor(am), y = mean_mpg)) +           # заменили se_data_2
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Но пока не понятно, где на этом графике переменная `vs`. Давайте добавим ее в `aes()` в качестве цвета:
```{r}
ggplot(se_data_2, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(vs))) +                     # теперь vs будет отображена цветом
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Не хватает линии соединяющей точки. Для ее построения необходимо в `aes` прописать группировку по переменной; в данном случае она совпадает с переменной цвета `vs`:
```{r}
ggplot(se_data_2, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(vs),
                      group = factor(vs))) +                    # группируем по цвету
  geom_line() +                                                 # добавляем линии связи
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Если бы мы группировали по большему числу значений переменных (возьмем `cyl`), то ничего не поменялось бы:
```{r}
gr_mtcars_3 <- group_by(mtcars, am, cyl)     # поменяли vs на cyl
(se_data_3 <- summarise(gr_mtcars_3,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg))))
```

```{r}
ggplot(se_data_3, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(cyl),      # поменяли vs на cyl
                      group = factor(cyl))) +   # поменяли vs на cyl
  geom_line() +
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Попробуем этот же дата-фрейм с `geom_pointrange`:
```{r}
ggplot(se_data_3, aes(x = factor(am),
                    y = mean_mpg,
                    color = factor(cyl),
                    group = factor(cyl))) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max)) +
  geom_line()  # тут порядок линий и точек не важен
```

### 2.2.6 Статистические трансформации внутри ggplot
А что если предобработку запихнуть внутрь `ggplot`?

Для начала просто отрисуем необходимые данные: 
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  geom_point()
```

Заменим `geom_point` на `stat_summary` и получим полный аналог `geom_pointrange`, но без предобработки:
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary()                       # тут пока еще чего-то не хватает :)
```

Функция `mean_cl_boot` (на ее вход подается вектор) возвращает данные, необходимые для построения доверительного интервала (`y` - среднее, `ymin` - минимум и `ymax` - максимум) при помощи `bootstrap`'а.
```{r}
mean_cl_boot(mtcars$mpg)
```

Эти результаты вычислений мы помещаем как аргументы `stat_summary`; эта функция по-умолчанию работает с `y`. 
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary(fun.data = mean_cl_boot) # в ф-ию mean_cl_boot попадают данный по y 
```

Внутри `stat_summary` можно прописать нужный нам `geom` (`point` идет по-умолчанию):
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",       # поменяли geom
               width = 0.3) +           # немного сжали усы
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point", # добавили средние точки
               size = 2)
```

Добавим разбивку по `vs`:
```{r}
ggplot(mtcars, aes(factor(am), mpg, col = factor(vs))) + # добавили цвет vs-ом
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2)
```

Соединим теперь средние точки линией. Нужно соединить только средние значения:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(vs), 
                   group = factor(vs))) + # добавили группирующую переменную
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "line") # предыдующая команда, только geom - линия
```

Последнюю команду, соединяющуюу линиями средние точки можно немног оупростить:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(vs), 
                   group = factor(vs))) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,   # в fun.y передаем среднее значение и соединяем линией
               geom = "line")
```

Измения группирующую (она же цветовая) переменную:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),       # поменяли vs на cyl
                   group = factor(cyl))) +  # поменяли vs на cyl
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,
               geom = "line")
```

Плюсом такого метода является отсутствие предобработки данных; все вычисления на себя берет `ggplot`. А так же можно использовать какую-то свою функцию вместо `mean_cl_boot`. Вот такую например:
```{r}
# данная ф-ия рассчитывает среднее значение +/- стандартное отклонение
sd_error <- function(x){
  c(y = mean(x),
    ymin = mean(x) - sd(x),
    ymax = mean(x) + sd(x))
}
```

Подставим эту функцию в предыдущую выкладку:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),
                   group = factor(cyl))) +
  stat_summary(fun.data = sd_error,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = sd_error,    # подставили сюда свою функцию 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,
               geom = "line")
```

Зеленый график наехал на синий - решаемо:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),
                   group = factor(cyl))) +
  stat_summary(fun.data = sd_error,
               geom = "errorbar",
               width = 0.3,
               position = position_dodge(0.2)) +  # сдвиг
  stat_summary(fun.data = sd_error,
               geom = "point",
               size = 2,
               position = position_dodge(0.2)) +  # сдвиг
  stat_summary(fun.y = mean,
               geom = "line",
               position = position_dodge(0.2))    # сдвиг
```

### 2.2.7 Задача
Давайте потренируемся комбинировать различные geoms на одном графике. Используя данные `mtcars` скомбинируем два варианта отображения количественных данных `boxplot` и `violin plot`.

* ось x - `am` (нужен фактор)
* ось y - `mpg`

Сохраните график в переменную `my_plot`.

Обратите внимание, я сделал `boxplot` чуть уже, чтобы ящики полностью оказались внутри `violin plot`: `geom_boxplot(width = 0.2)`

#### Решение
```{r}
ggplot(mtcars, aes(factor(am), mpg)) + 
  geom_violin() +
  geom_boxplot(width = 0.2)
```

### 2.2.8 Условие задачи
Для закрепления результатов поработаем с [вымышленными данными](https://stepic.org/media/attachments/course/724/sales.csv) о доходах в нескольких магазинах:

```{r}
sales = read.csv("https://stepic.org/media/attachments/course/724/sales.csv",
                 encoding =  "UTF-8")
str(sales)
```

* sale - число проданных товаров
* shop - номер магазина
* date - год, за который велась статистика
* season - время года
* income - доход магазина

### 2.2.9 Задача
Отобразите взаимосвязь между доходом `income` и числом продаж `sale`, цветом точек указав номер магазина `shop`. Сохраните график в переменную `my_plot`. Обратите внимание, что линия тренда одна для всех наблюдений. Данные хранятся в переменной `sales`.

#### Решение
```{r}
(my_plot <- ggplot(sales, aes(income, sale)) +
  geom_point(aes(color = shop)) +
  geom_smooth()
 )
```

### 2.2.10 Задача
При помощи функции `stat_summary` постройте график с доверительными интервалами для демонстрации различий в доходах двух магазинов с учетом времени года:

* переменная `shop` - ось x;
* переменная `income` - ось y;
* переменная `season` - цвет;
* geom pointrange.

Сохраните график в переменную `my_plot`, дополнив предложенный код. Обратите внимание, что доверительные интервалы не накладываются друг на друга! 

#### Решение
```{r}
(my_plot <- ggplot(sales, aes(shop, income, color = season)) +
   stat_summary(fun.data = mean_cl_boot,
                # geom = "pointrange",     # эту команду можно не писать, она по-умолчанию стоит
                position = position_dodge(0.2))
)
```

### 2.2.11 Задача
Теперь давайте отобразим на графике различия в продажах (переменная `sale`), в зависимости от:

* года (date) - ось x;
* и номера магазина (shop) - цвет.

Дополните предложенный код, чтобы получился график как в примере ниже. Используйте функцию `mean_cl_boot` для построения доверительных интервалов.Вам также понадобится использовать три `geoms`: `errorbar`, `point`, `line`. Используйте их прямо внутри функции `stat_summary()`. 

#### Решение
```{r}
ggplot(sales, aes(date, sale, color = shop, group = shop)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               position = position_dodge(0.2)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "point",
               position = position_dodge(0.2)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "line",
               position = position_dodge(0.2))
```

## 2.3 Facet - способы группировки данных на графике
### 2.3.1 План урока
В этом уроке мы:

* научимся разбивать график на несколько подграфиков;
* узнаем в чем разница между `facet_grid()` и `facet_wrap()`;
* Поговорим о кино!

### 2.3.2 Вводные слова

### 2.3.3 Facet-grid
Пакет, а точнее функция `ggplot` позволяет поместить в график очень много информации. Он к этому располагает :)
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(am), size = disp,
       shape = factor(cyl))) +
  geom_point()
```

Но зачастую не стоит злоупотреблять этой возможностью. Рано или поздно график станет очень перегруженным и какие-то важные взаимосвязи будет трудно наблюдать. Поэтому если мы хотим показать некий эффект на разных уровнях какого-либо фактора, то нужно использовать `facet`.

`facet` - это разбивка нашего графика на несколько подграфиков по какой-либо переменной. Есть несколько видов фасета, давайте посмотрим на наиболее типичные из них.

Пример графика с большим кол-вом уровней фактора:
```{r}
ggplot(diamonds, aes(carat, fill = color)) +
  geom_density()
```

Даже если добавить прозрачность `alpha=0.2`, то все равно график очень перегружен и хорошо понять распределение пременных очень тяжело. Поэтому в таких случаях лучше использовать `facet`. 

`facet-grid()` разбивает график на группы в виде матрицы. Можно задействовать сразу несколько переменных. 
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(color ~ cut) # разбивка по двум переменным
```

Если нам нужно разбить данные только по одному фактору, то вместо второго ставим просто точку:
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(. ~ cut) # в качестве столбцов
```

```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(cut ~ .) # в качестве строк
```

### 2.3.4 Facet-grid продолжение
Воспользуемся более маленьким набором данных `mtcars`, чтобы посмотреть еще одну особенность `facet-grid()`. Только для начала преобразуем две переменные в факторы:
```{r}
mtcars <- mutate(mtcars,
                 am = factor(am, labels = c("A", "M")),
                 vs = factor(vs, labels = c("V", "S")))
ggplot(mtcars, aes(hp)) +
  geom_dotplot() +
  facet_grid(am ~ vs, margins = T) # margins - добавляет сумму по строкам и столбцам
```

Добавим в эстетику еще одну переменную:
```{r}
ggplot(mtcars, aes(hp, mpg)) +            # добавили mpg 
  geom_point(aes(color = factor(cyl))) +  # поменяли geom и добавили цвет
  facet_grid(am ~ vs, margins = T)
```

Уберем из фасета одну переменную и добавим сглаживание:
```{r}
ggplot(mtcars, aes(hp, mpg)) +
  geom_point(aes(color = factor(cyl))) +
  facet_grid(. ~ am) +
  geom_smooth(method = "lm")
```

### 2.3.5 Facet-wrap
Основная идея `facet-grid()` - разбить график на несколько подграфиков в виде матрицы. 

В `facet-wrap` мы строим несколько независимых графиков подряд, с перебором всех факторв.
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap(~ color + cut) # всегда начинается с тильды, а дальше просто перечисляем факторы
```

Нет деления на столбики и столбцы, на каждом графике есть свое название. Так же здесь очень легко задавать форму вывода графика - можно задавать число столбиков и столбцов.
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap(~ color + cut, nrow = 5) # кол-во строк 
```

Для фасета достаточно одной факторной переменной:
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap( ~ cut)          # оставили всего одну переменную 
```

#### Без фасета
```{r}
ggplot(diamonds, aes(carat, price, col = color)) +
  geom_smooth()
```

#### Фасет спешит на помощь!
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_smooth() +
  facet_wrap(~ color) # просто переместили переменную из эстетики в фасет
```

```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_smooth() +
  facet_grid(color ~ .) # просто переместили переменную из эстетики в фасет
```

### 2.3.6 Заключительные слова
Совет: три переменный, это максимум для одного графика. А в фасет можно закинуть сразу два фактора.

### 2.3.7 Задача
Потренируемся с разбиением графика на подгруппы! Используя `facet_grid()` постройте следующий график и сохраните его в переменную `mpg_facet`.

* ось `x` - переменная mpg
* `facet` - переменная `am` по строчкам и `vs` по столбцам

#### Решение
```{r}
(mpg_facet <- ggplot(mtcars, aes(mpg)) +
  geom_dotplot() +
  facet_grid(am ~ vs)
 )
```

### 2.3.8 Задача
Используя данные `iris`, постройте график плотности для переменной `Sepal.Length`. Разбейте график на части по переменной `Species` при помощи `facet_wrap`. Результат сохраните в переменную `sl_wrap`.

#### Решение
```{r}
(sl_wrap <- ggplot(iris, aes(Sepal.Length)) +
  geom_density() +
  facet_wrap(~ Species)
 )
```

### 2.3.9 Задача
Используя данные `iris`, постройте график, иллюстрирующий взаимосвязь переменных `Sepal.Length` и `Sepal.Width` внутри каждого вида (переменной `Species`), при помощи `facet_wrap()`.

В этом задании вам потребуется использовать два `geom`:

* `geom_point` - для отображения отдельных наблюдений,
* `geom_smooth` - для добавления сглаживания.

Сохраните график в переменную `my_plot`.

#### Решение
```{r}
(my_plot <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
   geom_point() +
   geom_smooth() +
   facet_wrap(~ Species)
  
)
```

### 2.3.10 Задача
«Отряд самоубийц» уже посмотрели? Пишите в комментариях, как вам! У меня вот смешанные чувства вызвала эта команда суперзлодеев. Собрали самых интересных персонажей вселенной и отправили их в одну локацию весь фильм ходить , перебрасываясь односложными фразами. Джокера совсем не показали, все так ждали Джареда Лето в этой роли, а он появился, считайте, в двух эпизодах! К чему это я? Поговорим о кино!

Вы можете скачать данные myMovieData (жмите на [ссылку](https://stepik.org/media/attachments/course/724/myMovieData.csv)), в которых представлена различная информация о голливудских фильмах с 2002 по 2005: тип жанр, бюджет и год выхода на экраны. Давайте построим следующий график, чтобы выяснить есть ли различия в бюджетах фильмов разного жанра из года в год. Cохраните результат в переменную `my_plot`.

* ось `x` - переменная `Type`
* ocь `y` - переменная `Budget`
* `facet` - переменная `Year` (используйте `facet_grid`)

В примере графика я отобразил название жанров вертикально, чтобы все уместилось на графике и не перекрывалось. В коде, который вы отправляете на проверку, это необязательно, но вот как это можно было бы сделать:

`ggplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1))`

Про настройку таких моментов мы поговорим далее.

#### Решение
```{r}
myMovieData <- read.csv("https://stepik.org/media/attachments/course/724/myMovieData.csv")
# glimpse(myMovieData)
ggplot(myMovieData, aes(Type, Budget)) +
  geom_boxplot() +
  facet_wrap(~ Year) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

## 2.4 Scale и Theme: оси, легенда, внешний вид графика