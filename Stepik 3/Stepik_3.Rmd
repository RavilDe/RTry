---
title: "Анализ данных в R. Часть 2"
author: "Анатолий Карпов"
output:
  html_document:
    highlight: tango
  pdf_document: default
header-includes: \usepackage[english, russian]{babel}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = F, # отрубаем всякие не шибко нужные сообщения
                      cache = T)   # врубаем сохранение кэша, ибо данные тяжеловаты и долго пересчитываются
```

# 2 Подробнее о визуализации
## 2.1. Грамматика ggplot2, функция qplot
### 2.1.1. План урока
В этом уроке мы:

* познакомимся с основными элементами графической грамматики пакета ggplot2;
* научимся пользоваться функцией qplot для построения базовых графиков.

### 2.1.2. Теоретические материалы
В этом шаге я бы хотел собрать все теоретические материалы, на которые буду ссылаться в уроках:

* Самый хороший учебник [Cookbook for R](http://www.cookbook-r.com/Graphs/), в котором разобраны наиболее важные вопросы с примерами кода.
* [Документация](http://docs.ggplot2.org/current/) пакета ggplot2 с примерами кода для построения основных типов графиков.

Различные графические параметры:

* [типы точек](http://sape.inf.usi.ch/quick-reference/ggplot2/shape);
* [типы линий](http://sape.inf.usi.ch/quick-reference/ggplot2/linetype); 
* [цвета](http://sape.inf.usi.ch/quick-reference/ggplot2/colour).

### 2.1.3. Общие вводные слова

### 2.1.4. Основные грамматические конструкции ggplot2
Основная идея пакета заключается в том, что мы можем рассматривать процесс построения графика как последовательный процесс перемещения данных в графический вид, состоящий из нескольких этапов. Каждый этап является "грамматической единицей" построения графиков. Комбинируя эти грамматические единицы мы и получим график. Давайте разберемся что же это за этапы. 

#### Основные принципы (грамматические конструкции) ggplot2:
* **Aestetic attributes** - определяют какие данные будут на графике и где;
* **Geometric objects** - определяют, как именно будут отражены данные (линии, точки, столбики и т.д.);
* **Statistical transformation** - определяют, какие трансформации с данными будут отображены на графике (регрессионаая прямая или сглаживание) - не обязательно;
* **Scales** - какие именно значения (и как) будут отображены на графике (шкалы, сетки);
* **Coordinates** - система координат;
* **Faceting** - группировка данных (разбивка на фасетки).

В этом  заключается основная идея построения графика. Поэтапное конструирование.

### 2.1.5 Начало работы, qplot
Подгрузим библиотеку ggplot2:
```{r}
library(ggplot2)
```

#### Быстрый график qplot - quick plot
Подгрузим данный diamonds из пакетв ggplot2:
```{r}
data("diamonds")
```

Начнем с функции **qplot** которая ближе к базовой графике, чем к идеи **ggplot2**. Потому что она позволяет очень быстро нарисовать самые простые взаимосвязи, как бы угадывая за нас что мы хотим от данных. 

Разберем самый простой пример; посмотрим какие аргументы есть в функции. Это **x, y, data**. И построим график, в котором по оси **x** будеть переменная **price**, ну а данные - **diamonds**. Мы не сказали функции ни при помощи какого geom-а собирались строить график, в каком геометрическом пространстве, ни про какие доп настройки. И такая функция по умолчанию построит гистограмму:
```{r}
qplot(x = price, data = diamonds)
```

Т.е. если на вход **qplot** подать одну количественную переменную, то получится гистограмма.

Теперь добавим **y**. Если на входе две количественные переменные, то выйдет обычная диаграмма рассеивания:
```{r}
qplot(x = price, y = carat, data = diamonds)
```

А теперь отложим по оси **x** фактор (качественную переменную): **cut**. Пакет ggplot2 не растеряется и отложит по оси **х** группы переменных, объединенных фактором **cut**:
```{r}
qplot(x = cut, y = carat, data = diamonds)
```

Еще одна особенность **qplot**, в качестве минимального аргументьа функции может быть поставлен вектор:
```{r}
v <- diamonds$carat
qplot(v)
```
Вот такой вот минимум настроек функции **qplot**. Видно, что не обязательно прописывать название аргумента, они идут по порядку (TAB'овая подсказка). 

### 2.1.6 Задача
Используя функцию **qplot**, постройте гистограмму переменной **depth** из данных **diamonds**. Сохраните график в переменную **depth_hist**.
```{r}
(depth_hist <- qplot(diamonds$depth))
```

### 2.1.7. Структура переменной графика qplot
Вот эта идея, что можно напрямую обращаться к переменной дата-фрейма, так же распространяется и на диаграмму рассеивания:
```{r}
qplot(diamonds$price, diamonds$carat)
```

При этом функция **qplot** является частью пакета **ggplot2** и обладает большим кол-вом преимуществ над базовой графикой **R**. Это и большее количество настроек и что более важно, возможность сохранять графики в переменные. 

Вот такой код создаст переменную **my_plot**:
```{r}
my_plot <- qplot(qplot(x = price,        # переменная на ось x
                       y = carat,        # переменная на ось y
                       data = diamonds)) # из какого дата-фрейма берем переменные
str(my_plot)
```

Этот список хранит в себе информацию о всех графических элементах составляющих график.

### 2.1.8. Еще пара важных особенностей ф-ии qplot
Давайте разукрасим наш график. Это достигается всего-лишь добавлением одной строчки:
```{r}
qplot(x = price,
      y = carat,
      color = color, # добавляем цвет, через аргумент color
      data = diamonds)
```

Тут появляется некая двойственность записи, название аргумента совпадает со значением переменной :)

Давайте вручную пропишем, каким геометрическим объектом мы хотим отрисовать наши данные:
```{r}
qplot(x = price,
      y = carat,
      color = color, 
      data = diamonds,
      geom = "point") # указываем каким геометрическим объектом отрисовать наши данные
```

У точки есть параметры: размер (size) и форма (shape):
```{r}
qplot(x = price,
      y = carat,
      color = color,
      shape = cut,     # форма точки - варианты огранки бриллиантов (cut)
      data = diamonds,
      geom = "point")
```

Предыдущий график получился слегка перегруженным, поэтому давайте посмотрим эти характеристики на меньшем дата-фрейме **mtcars**:
```{r}
# пустой график
qplot(mpg,
      hp,
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am), # добавим цвет с помощью переменной am
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl), # изменяем форму точек по кол-ву цилиндров в авто
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl),
      size = I(3),         # изменили размер точки; см справку по ф-ии I()
      data = mtcars)
```

### 2.1.9. Задача
Теперь давайте отобразим сразу три переменные на одном графике! 

Постройте диаграмму рассеивания (scatter plot) как в указанном ниже примере, результат сохраните в переменную price_carat_clarity_points.

* данные - diamonds
* ось x - carat
* ось y - price
* цвет точек - clarity
```{r}
(price_carat_clarity_points <- qplot(data = diamonds,
                                    x = carat,
                                    y = price,
                                    color = clarity))
```

### 2.1.10. Продолжаем накачивать qplot
Добавим прозрачности точкам:
```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl),
      size = I(5),        # немного увеичил размер точки для наглядности
      alpha = I(0.7),     # изменяем прозрачность точки
      data = mtcars)
```

Вернемся к гистограмме и явно пропишем её geom:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram")
```

Изменим цвет и заливку столбиков:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram",
      fill = I("white"),  # заливка
      col = I("black"))   # рамка
```

```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram",
      fill = color,       # заливка переменной
      col = I("black"))   
```

Немного поменяем способ отображения столбцов изменив **geom**:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "density",  # сменили geom
      fill = color,
      col = I("black"))   
```

```{r}
qplot(data = diamonds,
      x = price,
      geom = "density",
      fill = color,
      alpha = I(0.3),    # добавили прозрачность для наглядности 
      col = I("black"))   
```

### 2.1.11. Задача
Используя функцию **qplot**, постройте график плотности переменной **x** из данных **diamonds**. Сохраните график в переменную **x_density**.

```{r}
(x_density <- qplot(data = diamonds,
                   x = x,
                   geom = "density"))
```

### 2.1.12. Задача
Усложним задачу, постройте график плотности переменной **x** для каждой группы наблюдений по переменной **cut** из данных **diamonds**. Таким образом за цвет графика теперь отвечает переменная **cut**. Сохраните результат в переменную **x_cut_density**.

```{r}
(x_density <- qplot(data = diamonds,
                   x = x,
                   col = cut,
                   geom = "density"))
```

### 2.1.13. Задача
Давайте знакомиться с различными **geoms**. Документация пакета и весь список с примерами использования доступен [здесь](http://ggplot2.tidyverse.org/reference/). Вообще обратите внимание на документацию **ggplot2**, очень подробное описание основных возможностей пакета!

Давайте построим график **violin plot** для переменной **price** в каждой группе наблюдений по переменной **color**. Сохраните результа в переменную **price_violin**.
```{r}
(price_violin <- qplot(data = diamonds,
                       geom = "violin",
                       y = price,
                       x = color))
```

### 2.1.14. Заключение урока
Бла-бла-бла