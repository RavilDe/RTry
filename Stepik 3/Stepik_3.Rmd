---
title: "Анализ данных в R. Часть 2"
author: "Анатолий Карпов, Антон Антонов"
output:
  html_document:
    highlight: tango
    toc: yes
    # toc_float: yes
  pdf_document: default
header-includes: \usepackage[english, russian]{babel}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(message = F, # отрубаем всякие не шибко нужные сообщения
                      cache = T)   # врубаем сохранение кэша, ибо данные тяжеловаты и долго пересчитываются
library(dplyr)
library(ggplot2)
library(Hmisc)
library(lazyeval)
```

# 1. Продвинутая предобработка данных
## 1.5 Работа с данными при помощи dplyr
### 1.5.1 План урока
В этом уроке мы:

* познакомимся с пакетом dplyr и крайне полезными функциями для работы с данными;
* при помощи функций из этого пакета научимся отбирать нужные нам наблюдения, сортировать данные, менять имена колонок в dataframe и многое другое;
* узнаем, что произойдет, если вы нажмете `Ctrl + Shift + m` в RStudio. 

### 1.5.2 Пакет dplyr
Библиотека `dplyr` -- специально создана для прикладной работы с данными. 

Она позволяет: 

* быстро аггрегировать наши таблицы
* рассчитывать различные описательные статистики по группам 
* делать быстрые и удобные сабсеты по колонкам или по строчкам
* фильтровать наши наблюдения
* сортировать наши наблюдения 
* и многое-многое другое

Другими словами, это такой набор инструментов, который точно пригодится человеку для обработки данных. 

Почему же мы говорим о стороней библиотеке? Ведь функции семейства `apply`, `subset`, `aggregate` решают все  необходимые задачи. Прочто иногда это выглядит не очень симпатично, с длинным кодом и не шибко быстро.

Если работать с очень большими массивами данных, то даже очень простые задачи (аггрегация или фильтрация) могут занимать значительное количество времени. Поэтому есть дополнительные библиотеки, оптимизирующие код и ускоряющие его.

Две из них (наиболее популярные):

* `dplyr`
* `data.table`

Немного забегая вперед: если работать с большими данными, то лучше подойдет `data.table`; в то время как `dplyr` делает работу с данными в R более удобной и понятной.

### 1.5.3 Функция data_frame
Установка и подключение пакета:
```{r eval=F}
install.packages("dplyr")
library(dplyr)
```

#### Различия между data.frame и data_frame
Создадим простенький дата-сет двумя способами:
```{r}
my_data <- data_frame(x = rnorm(10000),
                      y = rnorm(10000),
                      f = factor(rep(1:2, 5000)))

my.data <- data.frame(x = rnorm(10000),
                      y = rnorm(10000),
                      f = factor(rep(1:2, 5000)))
```

Если вывести в консоль `my.data` то мы ее полномтью замусорим!

А вот что будет выведено при вызове `my_data`:
```{r echo=F}
my_data
```

Во-первых прерван излишний вывод, выведена только шапка дата-фрейма; во-вторых есть небольшое описание дата-фрейма.

#### Преобразование as_data_frame
Можно уже имеющиеся дата-cеты преобразовывать в вид `data_frame`:
```{r}
diamonds <- as_data_frame(diamonds)
diamonds
```

### 1.5.4 Функция data_frame продолжение
#### Пробел в имени переменной
В синтаксисе `dplyr`:
```{r}
my_data_2 <- data_frame("My var" = rnorm(10))
my_data_2
my_data_2$`My var`    # оригинальные кавычки при обращении к переменной в названии которой есть пробел
```

А в базовом `R`:
```{r}
my.data.2 <- data.frame("My var" = rnorm(10))
my.data.2     # базовый R не допускает пробелов в названии переменной
```

#### Рекурсивное задание перменных
```{r}
my_data_3 <- data_frame(x  = rnorm(10), y = abs(x)) # рекурсия
my_data_3
```

В базовом R была бы ошибка!

### 1.5.5 Функция select
Теперь давайте посмотрим как при помощи пакета `dplyr` можно обращаться к строчками и колонкам дата-фрейма.

```{r echo=F}
diamonds <- as_data_frame(diamonds)
```


Для этого существует две функции:

* `select()` -- для выбора колонок
* `slice()` -- для выбора строк

#### Выбор колонок (переменных)
```{r}
select(diamonds, cut)    # такая команда выведет только переменную cut
```

Казалось бы, зачем усложнять, когда можно просто выборать колонку:
```{r}
head(diamonds$cut, 25)    # вывод колонки средствами базововго R
```

Во-первых вывод такой команды полностью заполнит окно, а во-вторых еще она не может выводить больше одной переменной за раз. А `select` может:
```{r}
select(diamonds, cut, price)   # перечисляем через запятую переменные, которые хотим вывести
```

Эквивалент такой записи в базовом R был бы таким:
```{r}
diamonds[ , c("cut", "price")]
```

Вариант из `dplyr` немного проще.

#### Выбор нескольких колонок
А теперь давайте выберем все перменные от `cut` до `price`:
```{r}
select(diamonds, cut:price)   # не нужно знать номера колонок и не нужно перечислять все переменные
```

#### Выбор всех колонок кроме одной (нескольких)
```{r}
select(diamonds, -cut)
```

#### Выбор колонок по номерам
```{r}
select(diamonds, 1:3, 5)
```

#### Дополнительные аргументы функции `select`
```{r}
# ?select   # много полезностей
select(diamonds, starts_with("c"))

```

### 1.5.6 Функция slice
Эта функция выбирает строчки:
```{r}
slice(diamonds, 2)             # просто вторая строка
slice(diamonds, 2:10)          # строки со второй по десятую
slice(diamonds, c(1, 4, 6))    # выборочные строки 
```

В базовом R это выглядело бы так:
```{r}
diamonds[c(1, 4, 6), ]
```

### 1.5.7 Функция filter
Эта функция делает некий `subset` данных по условию:
```{r}
filter(diamonds, carat > 0.3)   # главный аргумент - это условие
```

Сдандартная запись требует довольно громоздкой конструкции:
```{r}
diamonds[diamonds$carat > 0.3, ]    # слишком громоздко
```

Добавим еще одно условие:
```{r}
filter(diamonds, carat > 0.3, color == "J")
```

В базовом R запись приняла бы вид:
```{r}
diamonds[diamonds$carat > 0.3 & diamonds$color == "J", ]    # громоздко
subset(diamonds, carat > 0.3 & color == "J")    # отличие от filter только в перечислении условий
```

Добавление условия ИЛИ в функции `filter`:
```{r}
filter(diamonds, carat > 0.3 | color == "J")
```

### 1.5.8 Функция arrange
Эта функция сортирует дата-фрейм по какой-либо переменной:
```{r}
arrange(diamonds, price)   # по умолчанию от меньшего к большему
arrange(diamonds, price, depth)   # сначала по стоимости потом по глубине
```

В базовом R все сложнее:
```{r}
order(c(0, 2, 1, -1, 3))   # выводит индексы уборядоченного вектора 
sort(c(0, 2, 1, -1, 3))    # выводит упорядоченный вектор

diamonds[order(diamonds$price), ] # здесь нужен имеено order, он выдает индексы; чтобы все колонки тоже отсортировались
diamonds[order(diamonds$price, diamonds$depth), ] # упорядочивание по двум переменным
```

Сортировка в обратном направлении:
```{r}
arrange(diamonds, desc(price))    # спец функция для обратной сортировки
```

### 1.5.9 Функция rename и mutate
#### Функция rename
Эта функция переименовывает колонку (переменную) в нашем дата-фрейме.
```{r}
rename(diamonds, new_cut = cut)
```

В базовом R можно сделать как-то так:
```{r}
names(mtcars)[1] <- "new_mpg"   # тут нужно точно знать порядковый номер переменной 
names(mtcars)
```

Переименовка сразу нескольких переменных:
```{r}
rename(diamonds, new_cut = cut, new_carat = carat)   # просто перечисляем чере запятую
```

В базовом R прийдется заводить вектор:
```{r}
names(mtcars)[c(1, 4)] <- c("new_mpg", "new_hp")   # тут нужно точно знать порядковый номер переменной 
names(mtcars)
```

А если бы мы не знали на каком месте стоит переменная, то предварительно нужно было его найти, например таким образом:
```{r}
which(names(mtcars) == "disp")
```

#### Функция mutate
Функция необходима для тренсформации переменных:
```{r}
mutate(diamonds, sqrt_price = sqrt(price))  # команда выведет дата-фрейм с новой переменной sqrt_price
```

Естественно, можно преобразовывать сразу несколько переменных:
```{r}
mutate(diamonds,
       sqrt_price = sqrt(price),
       log_carat = log(carat))
```

В датафрейме mtcars переменные am и vs не являются факторами, так давайте переделаем их в факторы:
```{r}
mutate(as_data_frame(mtcars), am = factor(am), vs = factor(vs)) # замена уже существующих переменных
```

### 1.5.10 Задача
Давайте потренируемся обращаться к данным. Вы можете использовать базовый синтаксис, функции из пакета dplyr или data.table. 

Поработаем с данными diamonds из пакета ggplot2. 

В переменную d сохраните только нeчетные строчки исходных данных diamonds. 

Обратите внимание на функцию seq(). Она может вам пригодиться вам не только в этой задаче.

#### Решение
```{r}
slice(diamonds, seq(1, nrow(diamonds), 2))
```

### 1.5.11 Про конвеер pipe `%>%`
Функции для работы с данными очень часто используются вместе. Предположим, мы хотим отсортировать данные iris по переменной Sepal.Length, при этом оставить только те наблюдения, для которых значения переменной Petal.Length больше 1.7, а также оставить только две переменные Sepal.Length и  Petal.Length.

Мы могли бы решить эту задачу следующим образом:
```{r eval=F}
select(arrange(filter(iris, Petal.Length > 1.7), Sepal.Length), Sepal.Length, Petal.Length)
```

Согласитесь, выглядит слегка громоздко. Проблема в том, что внутри функции select мы используем функции arrange и filter, в результате можно не сразу сообразить, к какой функции принадлежат два последних аргумента, Sepal.Length, Petal.Length. Также, несмотря на то, что функция select первая в строчке, мы выполним ее в последнюю очередь только после того, как проведем фильтрацию и сортировку. Таким образом, чтобы разобраться в последовательности операций, нам как бы нужно прочитать код в обратном порядке. 

Мы могли бы сделать код более читаемым, подчеркнув также порядок действий, создавая промежуточные переменные для каждого этапа:

```{r eval=F}
filtered_iris <- filter(iris, Petal.Length > 1.7)
arranged_iris <- arrange(filtered_iris, Sepal.Length)
selected_iris <- select(arranged_iris, Sepal.Length, Petal.Length)
selected_iris
```

Однако, такой подход создает много лишних переменных, которые возможно и не понадобятся нам в дальнейшем.

Специально для решения это проблемы в пакете dplyr есть оператор %>% (Ctrl + Shift + m), при помощи которого можно отправить результат выполнения одной команды в следующую, смотрите, как это работает.
```{r eval=F}
iris %>% 
  filter(Petal.Length > 1.7) %>% 
  arrange(Sepal.Length) %>% 
  select(Sepal.Length, Petal.Length)
```

Оператор %>% в прямом смысле слова перетаскивает то, что написано перед ним в качестве аргумента, в следующую функцию. На первом этапе мы отправляем данные iris в функцию filter, в которой теперь достаточно указать только условие фильтрации. Далее результат фильтрации мы отправляем на сортировку по переменной Sepal.Length. И на последнем этапе уже отфильтрованные и отсортированные данные мы отправляем в функцию select, чтобы отобрать нужные колонки.

Результат: код становится более последовательным, мы на каждом этапе видим, какие аргументы в какой функции, прощай забор скобок, не создаем промежуточных переменных.

Такая запись, возможно, является слегка экзотической, и если ваш коллега не пользуется dplyr, то такой код может ввести его в замешательство. Однако к %>% быстро привыкаешь, особенно в контексте dplyr.

### 1.5.12 Задача
Потренируемся использовать изученные функции. Из данных mtcars отберите только четыре переменные: mpg, hp, am, vs. Оставьте только те наблюдения, для которых значения mpg > 14 и hp > 100. Отсортируйте получившиеся данные по убыванию переменной mpg и возьмите только первые 10 строчек. Переменную mpg переименуйте в Miles per gallon, а переменную hp в  Gross horsepower (обратите внимание, dplyr позволит нам создать пременные с пробелами в названии). Получившийся dataframe сохраните в переменную my_df. 

#### Решение
```{r}
data(mtcars)
mtcars %>% 
  select(mpg, am, vs, hp) %>% 
  filter(mpg > 14,  hp > 100) %>%
  arrange(desc(mpg)) %>% 
  slice(1:10) %>% 
  rename("Miles per gallon" = mpg,
         "Gross horsepower" = hp)
  
```

## 1.6 Работа с данными при помощи dplyr. Продолжение
### 1.6.1 План урока
В этом уроке мы продолжим разговор о `dplyr` и:

* научимся эффектно преобразовывать данные при помощи функции `mutate`.
* научимся делать различные преобразования с данными при помощи функций `group_by` и `summarize`.

### 1.6.2 Функция mutate_each
Преобразование всех переменных.
```{r}
d <- as_data_frame(matrix(rnorm(30), ncol = 5))
mutate_each(d, funs(abs))    # два аргумента - данные и функция для преобразования, обернутая в funs
```


#### Базовый R
Пример посложнее: заменить все отрицательные значения на ноль:
```{r}
as.data.frame(                        # матрицу преобразуем в дата-фрейм
  sapply(                             # на выходе sapply выдает матрицу
    d,                                # данные
    function(x) ifelse(x < 0, 0, x)   # анонимная функция заменяющая нулями отрицательные значения
    )
  )
```

У `sapply` есть преимущество -- мы можем прописать функцию на ходу.

#### А в dplyr?
Тут есть тонкий нюанс. В анонимной функции мы заменяли колонки данных `d` переменной `x`. А в `funs()` эту рольвыполняет точка `.`:
```{r}
mutate_each(d, funs(ifelse(. < 0, 0, .)))  # точка как бы вместо переменной; и благодаря векторизации 
```

#### Важное из комментов
Начиная с версии dplyr 0.5.0, реализована функция **mutate_all**, которая заменяет **mutate_each**. 
Как указано в справке функции, **mutate_each** в будущем будет упразднена. 
Аналогично обстоят дела с функцией **summarise_each**.

Пруфлинк: <https://blog.rstudio.com/2016/06/27/dplyr-0-5-0/>

Текущая версия dplyr -- `r packageVersion("dplyr")`

### 1.6.3 Задача
Напишите функцию, all_to_factor, которая преобразует dataframe, переводя все его переменные в фактор.

#### Решение
```{r}
str(
  mutate_all(d, funs(factor))
  )
```

### 1.6.4 Задача
В этом задании от вас потребуется написать функцию для предобработки данных log_transform. В статистике часто трансформируют исходные переменные. Например, используют значение натурального логарифма исходной переменной.

Ваша задача написать функцию, которая получает на вход dataframe  с произвольным числом переменных разных типов. На первом этапе функция должна выполнить предобработку числовых переменных. Т.к. значение логарифма мы можем рассчитать только для положительных чисел. Для этого сделаем центрирование всех переменных ([Rescaling](https://en.wikipedia.org/wiki/Feature_scaling)), только еще добавим **единичку**, чтобы у нас не осталось нулей:

$$
  x=\frac{x-x_{min}}{x_{max}-x_{min}} + 1
$$
После того как мы масштабировали каждую переменную, осталось рассчитать значение натурального логарифма каждого наблюдения (функция log) и вернуть новый dataframe.

#### Решение
```{r}
test_data <- data_frame(V1 = c(1.5, -0.1, 2.5, -0.3, -0.8),
                        V2 = c(-0.9, -0.3, -2.4, 0.0, 0.4),
                        V3 = c(-2.8, -3.1, -1.8, 2.1, 1.9),
                        V4 = c("A", rep("B", 4)))
test_data %>% 
  mutate_if(is.numeric, funs(log((. - min(.)) / (max(.) - min(.)) + 1)))
```


#### Подсмотрено в комментах
```{r eval=F}
# Лучшее
test_data %>% 
  mutate_if(is.numeric, funs(log(scales::rescale(.) + 1))) # для всего найдется функция

# Оказалось, что в mutate_each можно передавать как дополнительный аргумент список индексов колонок
test_data %>% 
  mutate_each(funs(log((. - min(.)) / (max(.) - min(.)) + 1)), which(sapply(., is.numeric)))
```

### 1.6.5 Бла-бла-бла
Общие слова о комфортном синтаксисе dplyr и подведение к более сложным функциям семейств `group_by` и `summarize`.

### 1.6.6 Функция group_by и sample_n
Эта функция очень похожа на `by()`, с одним лишь отличием --  это функция замедленного действия.

Функция получает на вход дата-фрейм и название **номинативной** переменной по которой мы хотим сгруппировать наши наблюдения. 
```{r}
# на выходе получим точно такой же дата-фрейм, НО с меткой о группировке по фактору cut
# Groups:   cut [5]
group_by(diamonds, cut)   
```

Получается R знает, что в этом дата-фрейме есть группировка по переменной cut. Что это значит на практике?

В dplyr есть замечательная функция `sample_n()` -- она просто выбирает n случайных наблюдений из наших данных:
```{r}
sample_n(diamonds, 2)   # случайные две строчки 
slice(diamonds, 1)      # перая строка дата-фрейма
```

А что произойдет, если мы в `sample_n()` подставим сгруппированные данные?
```{r}
diamonds %>% 
  group_by(cut) %>% 
  sample_n(2)        # мы получим по два случайных наблюдения из каждой группы
```

Все команды применяемые к сгруппированному дата-фрейму, будут применяться к каждой подгруппе данных которые у нас есть. Если наши данные о бриллиантах сгруппированы по переменной cut, то мы сначала применим `sample_n(2)` к первой подгруппе (категории cut), затем ко второй и т.д. 

```{r}
diamonds %>% 
  group_by(cut) %>% 
  slice(1)           # первые строки каждой подгруппы
```

### 1.6.7 Симбиоз group_by и summarise
Функция `summarise()` верная спутница `group_by()`; она преобразовывает множество значений в одно.
```{r}
mtcars %>% 
  summarise(mean(disp))    # получим одно среднее значение; схлопывание данных
```

Можно расситывать не одно, а сразу несколько разных значений:
```{r}
mtcars %>% 
  summarise(mean(disp), sd(disp))    # два результата
```
Этим получаемым значениям  можно присвоить свои имена:
```{r}
mtcars %>% 
  summarise(Mean = mean(disp), SD = sd(disp))    # поменяди имена
```

#### Совмеща group_by и summarise
Очень часто нас интересуют описательные статистики в разных группах, поэтому крайне удобно импользовать функции summarise() и group_by() совместно:
```{r}
diamonds %>% 
  group_by(cut) %>% 
  summarise(mean(price))   # схлопывание по группам
```

А теперь посчитаем несколько описательных статистик:
```{r}
diamonds %>% 
  group_by(cut) %>% 
  summarise(Mean_price = mean(price),
            Mean_x = mean(x),
            Median_y = median(y),
            Min_y = min(y))    # для разных групп рассчитали показательи по разнвм переменным
```

### 1.6.8 Симбиоз group_by и summarise. Продолжение.
Сгруппируем данные по нескольким переменным:
```{r}
diamonds %>% 
  group_by(cut, color) %>% 
  summarise(Mean_price = mean(price),
            Mean_x = mean(x),
            Median_y = median(y),
            Min_y = min(y))       # получим небольшую сводную таблицу (:
```

#### Функция n() -- подсчет элементов
Очень удобная встроенная в `dplyr` функция `n()` позволяет подсчитывать количество элементов:
```{r}
diamonds %>% 
  group_by(cut, color) %>% 
  summarise(n = n(),              # посчет элементов каждой подшруппе
            Mean_price = mean(price),
            Mean_x = mean(x),
            Median_y = median(y),
            Min_y = min(y))
```

Добавим переменную с количеством бриллиантов дороже 5000: 
```{r}
diamonds %>% 
  group_by(cut, color) %>% 
  summarise(n = n(),
            Mean_price = mean(price),
            Mean_x = mean(x),
            Median_y = median(y),
            Min_y = min(y),
            great_price = sum(price > 5000))  # подсчет кол-ва бриллиантов по условию
```

Давайте проверим подсчитанное количество в первой строчке -- 39:
```{r}
diamonds %>% 
  filter(cut == "Fair", color == "D", price > 5000) %>% 
  nrow()
```

Другой вариант проверки:
```{r}
sum(filter(diamonds, cut == "Fair", color == "D")$price > 5000)
```

### 1.6.9 Функция summarise_all
Эта функция аналогична `summarise` с одним лишь отличием -- схлопывание производится по всем переменным.
```{r}
mtcars %>% 
  group_by(am, vs) %>%      # сгруппируем по am и vs
  summarise_all(funs(mean)) # выдаст среднее значение по всем переменным, сгруппированным по am vs
```

Сколько наблюдений в переменнйо по каждой группе больше десяти: 
```{r}
mtcars %>% 
  group_by(am, vs) %>%             # сгруппируем по am и vs
  summarise_all(funs(sum(. > 10))) # кол-во наблюдений со значением больше 10; функция прописана на ходу
```

### 1.6.10 Функция summarise_all. Продолжение
Имена колонок создаются автоматически:
```{r}
group_by(iris, Species) %>% 
    summarise_all(funs(sd, mean))
```

### 1.6.11 А если мы не знаем имена переменных в данных, но хотим применять dplyr?
В завершении необходимо разобрать продвинутую, но очень важную тему: использование стандартного вычисления **SE (standard evaluation)** и нестандартного вычисления **NSE (nonstandard evaluation)**, используемого в функциях пакета dplyr.

Давайте рассмотрим простой пример применения функции select:
```{r eval=F}
select(mtcars, am, hp)
```

Обратите внимание, что все аргументы написаны без кавычек, но R понимает, что первый аргумент mtcars - это имя переменной в рабочем окружении, что не удивительно, если мы просто напишем mtcars в консоль, то выведем уже знакомый нам набор данных. При этом am и hp, написанные без кавычек, не вызывают никаких ошибок. То есть функция select понимает, что первый аргумент - это имя переменной, а последующие аргументы это не переменные в нашем рабочем окружении, а именно имена колонок в данных. Поясню, если мы попытаемся исполнить такой код:

```{r eval=F}
mtcars[, am] 
```

то получим ошибку **Ошибка в `[.data.frame`(mtcars, , am) :объект 'am' не найден**. Т.к. R не поймет, что am - это имя колонки в данных, и попытается найти переменную с именем am.  Для корректной работы нам было бы необходимо поместить имя столбика в кавычки:
```{r eval=F}
mtcars[, "am"]
```

Однако, в контексте функции select и других изученных функций из пакета dplyr такой ошибки не произойдет. Возможность использовать имена колонок в данных без кавычек обуславливается нестандартным вычислением (NSE) подробнее смотри [тут](http://adv-r.had.co.nz/Computing-on-the-language.html).

Эта особенность позволяет писать быстрый и удобный код, однако имеет серьезный недостаток. Все разобранные функции мы можем применять к данным только в том случае, если знаем название колонок в данных. Но что делать, если нам необходимо написать собственную функцию для работы с данными, в которых мы заранее не знаем имена колонок?

На этот случай, в dplyr существуют братья близнецы изученных функций, которые имеют такие же названия только с нижним подчеркиванием в конце:
```{r eval=F}
slice_()
filter_()
group_by_()
mutate_()
# и прочие
```

Все эти функции выполняют те же самые операции, однако, используют стандартное вычисление (standard evaluation), позволяющее записывать имена колонок данных в кавычках, и как результат -  динамически вычислять имена тех колонок, которые мы хотим использовать в качестве аргументов функций dplyr. Однако, умелое использование этих функций (со стандартным вычислением) требует знания продвинутых приемов программирования в R. Давайте разберемся в этой теме подробнее.

Начнем с простого примера и разберем работу функции select_():
```{r eval=F}
var_to_select <- "hp"
select_(mtcars, var_to_select)
```

Таким образом, мы в процессе работы с данными можем определить, какую именно переменную мы хотим отобрать при помощи функции select_, сохранить имя этой переменой в var_to_select, а затем уже использовать var_to_select в качестве аргумента функции select_().

#### Пример с применением .dots
Еще один пример: часто возникает необходимость сгруппировать набор данных по нескольким факторным переменным, названия которых мы не знаем заранее, или таких переменных довольно много и писать их вручную не самый удобный вариант. 

Для решения такой задачи можно использовать вектор с именами - строками интересующих нас переменных:
```{r eval=F}
mtcars$am <- factor(mtcars$am)
mtcars$vs <- factor(mtcars$vs)

factor_vars <- names(which(sapply(mtcars, is.factor))) # сохраним имена факторов в вектор
mtcars %>% 
  group_by_(.dots = factor_vars) %>% 
  summarise(n = n())
```

Функция group_by_, поддерживает передачу вектора с именами для группировки. Синтаксис очень простой, внутри функции group_by_ мы должны явно сказать, что будем использовать вектор с именами, используя аргумент **.dots**. Таким образом, мы сначала сохранили в переменную имена факторных переменных и использовали их для группировки исходных данных.

#### А если мы не знаем имя переменной?
Однако сложности могут начаться далее. Мы знаем, такие функции как filter и mutate позволяют писать сложные выражения для преобразования данных, например:
```{r eval=F}
mutate(mtcars, new_var = (hp - mean(hp)) / sd(hp))
```

Таким образом мы создадим новую переменную в данных, а именно, стандартизированную переменную hp. Но что делать, если мы заранее не знаем, как называется переменная, которую мы хотим стандартизировать? 

Рассмотрим такой пример:
```{r eval=F}
mini_mtcars <- select(mtcars, hp, am, vs)
mini_mtcars <- mini_mtcars %>% mutate(am = factor(am), 
                                      vs = factor(vs))
```

Теперь в данных mini_mtcars одна количественная переменная и две факторные, предположим, мы хотим написать код, который стандартизирует количественную переменную в данных, однако не обращается к ней по имени на прямую, а вычисляет ее динамически, то есть если бы мы взяли другой набор данных, с другими названиями переменных, все также сработало. Обратите внимание, нам теперь необходимо написать целое выражение с неизвестной заранее переменной.

#### Варианты решения:
Очевидно нам понадобится функция mutate_. Существует несколько способов написать выражение, которое будет выполнено функцией mutate_:

1. Поместить выражение в строку:
```{r eval=F}
mutate_(mini_mtcars, new_var = "(hp - mean(hp)) / sd(hp)")
```

2. Использовать запись через формулу:
```{r eval=F}
mutate_(mini_mtcars, new_var = ~ (hp - mean(hp)) / sd(hp))
```

3. Использовать функцию quote():
```{r eval=F}
mutate_(mini_mtcars, new_var =  quote((hp - mean(hp)) / sd(hp)))
```

У вас может возникнуть законный вопрос, чем же это нам поможет? Ведь мы все еще используем имя переменной hp. Однако все эти три варианта позволяют нам без труда, заменить hp на любое другое имя переменной, которое мы могли вычислить заранее. И в этом нам поможет функция interp из пакета lazyeval. Ох, как же все непросто!) И так давайте уже напишем финальный код:

```{r eval=F}
library(lazyeval)
num_var <- names(which(sapply(mini_mtcars, is.numeric)))
mutate_(mini_mtcars, new_var = interp(~(var - mean(var)) / sd(var), var = as.name(num_var)))
```

Функция interp позволяет подставить на место желаемой переменной строку с нужным нам названием колонки в данных. Единственный нюанс, если имя желаемой переменной - это строка, ее нужно обернуть функцией as.name(). Мы также могли использовать любой из двух оставшихся методов передачи нашей переменной в вычисляемое выражение:
```{r eval=F}
interp("(var - mean(var)) / sd(var)", var = as.name(num_var))
interp(quote((var - mean(var)) / sd(var)), var = as.name(num_var))
```

Ну вот и все, таким образом, мы поместили в вычисляемое выражение имя переменной, которое мы определили ранее, и в данных с другими именами колонок наш код тоже будет работать.

#### Еще пример
Этот подход мы можем использовать и при работе с другими функциями dplyr:
```{r eval=F}
library(lazyeval)
var_for_group <- c("am", "vs")
var_for_filter <- "hp"
var_for_arrange <- "mpg"
var_for_mutate <- "qsec"
var_for_summirise <- "cyl"
group_by_(mtcars, .dots = var_for_group) %>% 
  filter_(interp(~var > 100, var = as.name(var_for_filter))) %>% 
  arrange_(var_for_arrange) %>% 
  mutate_(new_var = interp(~ifelse(var > mean(var), 1, 0), 
                           var = as.name(var_for_mutate))) %>% 
  summarise_(max = interp(~max(var), var = as.name(var_for_summirise)))
```

Возможно, сейчас такой подход кажется довольно запутанным, однако, к нему быстро привыкаешь, и после этого не составляет труда использовать функции dplyr для написания собственных функций!

#### Важно!!!
```{r echo=F}
# Где-то выше мынемного изменили mtcars! Возвращаем дата-сету его исходный вид
# Если этого не сделать, то при компиляции файла в следующем чанке вылезет ошибка
data("mtcars")
```


P.S. из трех предложенных способов записи: в кавычках, через формулу и при помощи функции quote, лучше  всегда использовать запись через тильду, т.к. оставшиеся два варианта могут привести к ошибке (смотри [обсуждение](https://github.com/tidyverse/dplyr/issues/1323) этой особенности с автором пакета dplyr):

```{r}
# 09-10-2017 все три комнды возвращают результат!!!
summarise_(mtcars, ~shapiro.test(mpg)$p.value)
summarise_(mtcars, "shapiro.test(mpg)$p.value")
summarise_(mtcars, quote(shapiro.test(mpg)$p.value))
```

### 1.6.12 Семейства mutate_??? и summarise_???
Обратите внимание на несколько продвинутых приемов для преобразования данных. Описание подготовил [Федор Малышкин](https://stepic.org/users/18363849).

Отдельно вне лекции хочется обратить внимание на методы пакета dplyr, которые позволяют выполнять выборочное изменение или суммирование (mutate_??? или summarise_???), в отличии от методов mutate_each и summarise_each.

Принципы их работы проще всего понять на примерах.

Возьмем известный нам набор Iris и сгруппируем его по видам растений:
```{r}
by_species <- iris %>% 
  group_by(Species)
```

Потом с помощью метода summarise_if получим среднее значение каждого числового показателя:
```{r}
by_species %>% 
  summarise_if(is.numeric, mean)
```

При этом разумеется можно выставить любые другие условия, проверяющие как тип данные, так и их значения. Например, расчет среднего только для численных значение со средним больше 2 в общей выборке:
```{r}
by_species %>% 
  summarise_if(function(col){ if (!is.numeric(col)) return(FALSE) else mean(col) > 2},mean)
```

Кроме того, можно осуществить сбор итоговой статистики для столбцов, совпадающих по имени или подпадающих под определенные критерии (с помощью вспомогательной функции vars):
```{r}
by_species %>% 
  summarise_at(vars(Petal.Width), mean)
by_species %>% 
  summarise_at(vars(matches("Width")), mean)
```

Или конкретно указывать их номера и имена (без вспомогательной функции vars):
```{r}
by_species %>% 
  summarise_at(c("Sepal.Width", "Petal.Width"), mean)
by_species %>% 
  summarise_at(c(1, 3), mean)
```

Также не забывайте про возможность их совместного использования с ранее изученными способами суммирования данных:
```{r}
by_species %>% 
  summarise_at(vars(Petal.Width, Sepal.Width), funs(min, max))
by_species %>% 
  summarise_at(vars(matches("Width")), funs(min, max))
```

Стоит также обратить внимание на функцию select_if, которая позволяет отбирать колонки по условию. Давайте решим уже знакомую задачу - отберем только числовые колонки в данных и рассчитаем для них sd:
```{r}
select_if(iris, is.numeric) %>% 
    summarise_all(funs(sd))
```

### 1.6.13 Задача
В ситуации, когда у нас есть несколько факторов все наши наблюдения разбиваются на столько групп, сколько возможно комбинации уровней факторов. Например, если у нас есть данные, где количественная переменная - размер зарплаты, а два фактора это пол (мужчины и женщины) и национальность (англичане и французы), то два эти фактора разбивают наблюдения на четыре группы:  мужчины французы, женщины француженки, мужчины англичане и женщины англичанки.  В общем число всех возможных групп равняется произведению числа градацией факторов.

И так, ваша задача будет написать функцию descriptive_stats, которая рассчитывает основные описательные статистики в каждой группе наблюдений для описанного выше примера. Функция получает на вход dataframe с тремя переменными salary - значение заработной платы, gender - фактор с двумя градациями (male, female), country - фактор с двумя градациями (England, France).

Функция должна возвращать dataframe с описательными статистиками и количеством NA, рассчитанными в каждой группе: количеств наблюдений, среднее значение, стандартное отклонение, медиана, первый квартиль, третий квартиль, число пропущенных значений.

Воспользуйтесь функцией quantile() для расчета квартилей в данных.

Пример работы функции и формата dataframe c описательными статистиками.

```{r}
test_data <- read.csv("https://stepic.org/media/attachments/course/724/salary.csv")

test_data %>% 
  group_by(gender, country) %>% 
  summarise(n = n(),
            mean = mean(salary, na.rm = T),
            sd = sd(salary, na.rm = T),
            median = median(salary, na.rm = T),
            first_quartile = quantile(salary, 0.25, na.rm = T),
            third_quartile = quantile(salary, 0.75, na.rm = T),
            na_values = sum(is.na(salary)))
```

### 1.6.14 Бла-бла-бла

### 1.6.15 Задача
Напишите функцию, to_factors, которая получает на вход dataframe  с произвольным числом количественных переменных и вектор с номерами колонок, которые нужно перевести в фактор.

Для перевода числовых колонок в фактор будем использовать следующий принцип, если наблюдение больше среднего всей переменной то 1, иначе 0.
```{r}
to_factors <- function(data, factors) {
  data[factors] <- mutate_all(.tb = data[factors], 
                             .funs = funs(factor(. < mean(.), labels = 0:1)))
  return(data)
}
to_factors(mtcars[1:4], c(1, 3))

# Эта команда 
# mtcars %>%
#   mutate_each(funs(factor(. < mean(.), labels = 0:1)), c(1,3))
```

### 1.6.16 Задача
Применим полученные знания на практике. Возьмем данные diamonds для работы в этой задаче. Создайте новый dataframe с именем high_price, в котором будут хранится только 10 самых дорогих бриллиантов каждого цвета. Также в итоговом datafrmae должны храниться только две переменные color и price.

```{r}
diamonds %>% 
  group_by(color) %>% 
  select(color, price) %>% 
  arrange(color, -price) %>% 
  slice(1:10)
```

# 2. Подробнее о визуализации
## 2.1 Грамматика ggplot2, функция qplot
### 2.1.1 План урока
В этом уроке мы:

* познакомимся с основными элементами графической грамматики пакета `ggplot2`;
* научимся пользоваться функцией `qplot` для построения базовых графиков.

### 2.1.2 Теоретические материалы
В этом шаге я бы хотел собрать все теоретические материалы, на которые буду ссылаться в уроках:

* Самый хороший учебник [Cookbook for R](http://www.cookbook-r.com/Graphs/), в котором разобраны наиболее важные вопросы с примерами кода.
* [Документация](http://docs.ggplot2.org/current/) пакета `ggplot2` с примерами кода для построения основных типов графиков.

Различные графические параметры:

* [типы точек](http://sape.inf.usi.ch/quick-reference/ggplot2/shape)
* [типы линий](http://sape.inf.usi.ch/quick-reference/ggplot2/linetype) 
* [цвета](http://sape.inf.usi.ch/quick-reference/ggplot2/colour)

### 2.1.3 Общие вводные слова

### 2.1.4 Основные грамматические конструкции ggplot2
Основная идея пакета заключается в том, что мы можем рассматривать процесс построения графика как последовательный процесс перемещения данных в графический вид, состоящий из нескольких этапов. Каждый этап является "грамматической единицей" построения графиков. Комбинируя эти грамматические единицы мы и получим график. Давайте разберемся что же это за этапы. 

#### Основные принципы (грамматические конструкции) ggplot2:
* **Aestetic attributes** -- определяют какие данные будут на графике и где;
* **Geometric objects** -- определяют, как именно будут отражены данные (линии, точки, столбики и т.д.);
* **Statistical transformation** -- определяют, какие трансформации с данными будут отображены на графике (регрессионаая прямая или сглаживание) -- не обязательно;
* **Scales** -- какие именно значения (и как) будут отображены на графике (шкалы, сетки);
* **Coordinates** -- система координат;
* **Faceting** -- группировка данных (разбивка на фасетки).

В этом  заключается основная идея построения графика. Поэтапное конструирование.

### 2.1.5 Начало работы, qplot
Подгрузим библиотеку `ggplot2`:
```{r eval=F}
library(ggplot2)
```

#### Быстрый график qplot -- quick plot
Подгрузим данный `diamonds` из пакетв `ggplot2`:
```{r}
data("diamonds")
```

Начнем с функции `qplot` которая ближе к базовой графике, чем к идеи `ggplot2`. Потому что она позволяет очень быстро нарисовать самые простые взаимосвязи, как бы угадывая за нас что мы хотим от данных. 

Разберем самый простой пример; посмотрим какие аргументы есть в функции. Это `x, y, data`. И построим график, в котором по оси `x` будеть переменная `price`, ну а данные -- `diamonds`. Мы не сказали функции ни при помощи какого geom-а собирались строить график, в каком геометрическом пространстве, ни про какие доп настройки. И такая функция по умолчанию построит гистограмму:
```{r}
qplot(x = price, data = diamonds)
```

Т.е. если на вход `qplot` подать одну количественную переменную, то получится гистограмма.

Теперь добавим `y`. Если на входе две количественные переменные, то выйдет обычная диаграмма рассеивания:
```{r}
qplot(x = price, y = carat, data = diamonds)
```

А теперь отложим по оси `x` фактор (качественную переменную): `cut`. Пакет `ggplot2` не растеряется и отложит по оси `х` группы переменных, объединенных фактором `cut`:
```{r}
qplot(x = cut, y = carat, data = diamonds)
```

Еще одна особенность `qplot`, в качестве минимального аргументьа функции может быть поставлен вектор:
```{r}
v <- diamonds$carat
qplot(v)
```

Вот такой вот минимум настроек функции `qplot`. Видно, что не обязательно прописывать название аргумента, они идут по порядку (TAB'овая подсказка). 

### 2.1.6 Задача
Используя функцию `qplot`, постройте гистограмму переменной `depth` из данных `diamonds`. Сохраните график в переменную `depth_hist`.

#### Решение
```{r}
(depth_hist <- qplot(diamonds$depth))
```

### 2.1.7 Структура переменной графика qplot
Вот эта идея, что можно напрямую обращаться к переменной дата-фрейма, так же распространяется и на диаграмму рассеивания:
```{r}
qplot(diamonds$price, diamonds$carat)
```

При этом функция `qplot` является частью пакета `ggplot2` и обладает большим кол-вом преимуществ над базовой графикой `R`. Это и большее количество настроек и что более важно, возможность сохранять графики в переменные. 

Вот такой код создаст переменную `my_plot`:
```{r}
my_plot <- qplot(qplot(x = price,        # переменная на ось x
                       y = carat,        # переменная на ось y
                       data = diamonds)) # из какого дата-фрейма берем переменные
str(my_plot)
```

Этот список хранит в себе информацию о всех графических элементах составляющих график.

### 2.1.8 Еще пара важных особенностей функции qplot
Давайте разукрасим наш график. Это достигается всего-лишь добавлением одной строчки:
```{r}
qplot(x = price,
      y = carat,
      color = color, # добавляем цвет, через аргумент color
      data = diamonds)
```

Тут появляется некая двойственность записи, название аргумента совпадает со значением переменной :)

Давайте вручную пропишем, каким геометрическим объектом мы хотим отрисовать наши данные:
```{r}
qplot(x = price,
      y = carat,
      color = color, 
      data = diamonds,
      geom = "point") # указываем каким геометрическим объектом отрисовать наши данные
```

У точки есть параметры: размер `size` и форма `shape`:
```{r}
qplot(x = price,
      y = carat,
      color = color,
      shape = cut,     # форма точки - варианты огранки бриллиантов (cut)
      data = diamonds,
      geom = "point")
```

Предыдущий график получился слегка перегруженным, поэтому давайте посмотрим эти характеристики на меньшем дата-фрейме `mtcars`:
```{r}
qplot(mpg,
      hp,
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am), # добавим цвет с помощью переменной am
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl), # изменяем форму точек по кол-ву цилиндров в авто
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl),
      size = I(3),         # изменили размер точки; см справку по ф-ии I()
      data = mtcars)
```

### 2.1.9 Задача
Теперь давайте отобразим сразу три переменные на одном графике! 

Постройте диаграмму рассеивания `scatter plot` как в указанном ниже примере, результат сохраните в переменную `price_carat_clarity_points`.

* данные -- `diamonds`
* ось x -- `carat`
* ось y -- `price`
* цвет точек -- `clarity`

#### Решение
```{r}
(price_carat_clarity_points <- qplot(data = diamonds,
                                    x = carat,
                                    y = price,
                                    color = clarity))
```

### 2.1.10 Продолжаем накачивать qplot
Добавим прозрачности точкам:
```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl),
      size = I(5),        # немного увеичил размер точки для наглядности
      alpha = I(0.7),     # изменяем прозрачность точки
      data = mtcars)
```

Вернемся к гистограмме и явно пропишем её `geom`:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram")
```

Изменим цвет и заливку столбиков:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram",
      fill = I("white"),  # заливка
      col = I("black"))   # рамка
```

```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram",
      fill = color,       # заливка переменной
      col = I("black"))   
```

Немного поменяем способ отображения столбцов изменив `geom`:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "density",  # сменили geom
      fill = color,
      col = I("black"))   
```

```{r}
qplot(data = diamonds,
      x = price,
      geom = "density",
      fill = color,
      alpha = I(0.3),    # добавили прозрачность для наглядности 
      col = I("black"))   
```

#### Примечание
В лекции не сказано, но можно использовать совершенно любые `HEX` цвета, просто записывая их внутри функции `I( )`, что очень удобно :) Например `I('#66cc66')`.

### 2.1.11 Задача
Используя функцию `qplot`, постройте график плотности переменной `x` из данных `diamonds`. Сохраните график в переменную `x_density`.

#### Решение
```{r}
(x_density <- qplot(data = diamonds,
                   x = x,
                   geom = "density"))
```

### 2.1.12 Задача
Усложним задачу, постройте график плотности переменной `x` для каждой группы наблюдений по переменной `cut` из данных `diamonds`. Таким образом за цвет графика теперь отвечает переменная `cut`. Сохраните результат в переменную `x_cut_density`.

#### Решение
```{r}
(x_density <- qplot(data = diamonds,
                   x = x,
                   col = cut,
                   geom = "density"))
```

### 2.1.13 Задача
Давайте знакомиться с различными `geoms`. Документация пакета и весь список с примерами использования доступен [здесь](http://ggplot2.tidyverse.org/reference/). Вообще обратите внимание на документацию `ggplot2`, очень подробное описание основных возможностей пакета!

Давайте построим график `violin plot` для переменной `price` в каждой группе наблюдений по переменной `color`. Сохраните результа в переменную `price_violin`.

#### Решение
```{r}
(price_violin <- qplot(data = diamonds,
                       geom = "violin",
                       y = price,
                       x = color))
```

### 2.1.14 Заключение урока
Бла--бла--бла

## 2.2. Функция ggplot и различные geoms
### 2.2.1 План урока
В этом уроке мы:

* познакомимся поближе с функцией `ggplot`;
* разберем различные примеры `geoms`;
* поговорим подробнее о функции `stat_summary`;

### 2.2.2 Функция ggplot
Функция `ggplot` является самой главной заготовкой нашего графика. И требует на вход данные, которые мы хотим визуализировать; на самом деле этого достаточно:
```{r}
ggplot(diamonds)
```

Появилась некая заготовка графика. Мы пока просто создали холст для графика.

Теперь мы хотим сказать какие переменные будут отображены на графике. Для этого используется функция `aes()`. Давайте построим самый простой график, где по оси `x` будет отложена переменная `price`:
```{r}
ggplot(diamonds, aes(x = price))
```

На холсте появилась шкала значений переменной `price`. Он пустой, т.к. мы ничего не сказали про то, каким образом отобразить данные. Третьим этапом нам необходимо добавить некий геометрический объект или `geom`; это будет новый слой графика:
```{r}
ggplot(diamonds, aes(x = price)) +
  geom_histogram()
```

#### Минимальный набор атрибутов для построения графика:

* `ggplot(diamonds)` -- чистый холст;
* `aes(x = price)` -- какие переменный из diamonds мы хотим показать;
* `geom_histogram` -- каким способом мы это хотим сделать.

#### График с несколькими переменными
```{r}
ggplot(diamonds, aes(price, carat)) # x и y можно опустить
```

Добавим geom с точками:
```{r}
ggplot(diamonds, aes(price, carat)) + 
  geom_point()
```

Основная фишка `ggplot` -- мы не ограничены количеством `geom`'ов
```{r}
ggplot(diamonds, aes(price, carat)) + 
  geom_point() + 
  geom_smooth()
```

Все переменные, которые мы хотим перенести на график, на оси, в цвете, мы должны прописать в `aes`. Причем `aes` мы можем прописать как в заглавной `ggplot` (они будут работать на все `geom`'ы), так и в отдельных `geom`'ах (индивидуално). 
```{r}
ggplot(diamonds) + 
  geom_point(aes(price, carat)) + 
  geom_smooth(aes(price, carat))  # так тоже можно
```

Добавим переменную в `aes` для обозначения цветат точек:
```{r}
ggplot(diamonds, aes(x = price,
                    y = carat,
                    color = cut)) + # добавили переменную для цвета
  geom_point() + 
  geom_smooth()
```

Заметим, что наша переменная `color` разбивает на группы и точки и линии сглаживания. Однако, что делать, если мы хотим сохранить всего одну линию тренда? Нужно перенести переменную отвечающую за цвет только в нужный нам `geom`.
```{r}
ggplot(diamonds, aes(x = price,
                    y = carat)) + 
  geom_point(aes(color = cut)) +    # прописываем цвет только в этом geom'е
  geom_smooth()
```

### 2.2.3 Aesthetics
Поэтому внутри функци `ggplot` мы указываем данные и только те переменны, которые будут общими для всех `geom`'ов. А если хотим изменить что-то лишь для одного `geom`'а то эти изменения нужно прописывать именно в нем:

```{r}
ggplot(diamonds, aes(x = price,
                    y = carat)) + 
  geom_point(aes(color = cut),
             size = 0.5,      # размер точки; без I()
             alpha = .3) +    # прохрачность; без I(); десятичную дробь можно писать без нуля
  geom_smooth(size = 2,
              color = "red")
```

Настройки прописанные внутри одного `geom`'а никак не переходят на другой `geom`.

### 2.2.4 Набор данных airquality
Давайте посмотрим на данные `airquality`:
```{r}
str(airquality)
```

```{r}
library(dplyr)
glimpse(airquality) # этакий расширенный str() из пакета tibble
```

Для каждого месяца есть показатель температуры, давайте создадим новый дата-фрейм, в котором данные будут сгруппированы по месяцам, а затем схлопнем эти данные со средней температурой и средней скорости ветра:
```{r}
gr_airquality <- group_by(airquality, Month)
(t <- summarise(gr_airquality, 
                mean_temp = mean(Temp),
                mean_wind = mean(Wind)))
```

А теперь нарисуем график:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_point(aes(size = mean_wind)) + # размер точек вынесен отдельно
  geom_line()                         # линии для соединения точек
```

Линия показывает некий тренд температуры, а размер точек скорость ветра.

```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_point(aes(size = mean_wind),
             color = "red") + # покарсим точки в красный
  geom_line()
```

Наблюдаем нахлест линий на точки. Как это исправить? Просто поменять порядок `geom`'ов:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_line() +                      # поставили его первым
  geom_point(aes(size = mean_wind),
             color = "red")          # точки закроют линии
```

Есть такие `geom`'ы, котрые не зависят от `aes()` прописанных в `ggplot()`. Предположим, что мы хотим добавить на график горизонтальную линию на уровне $75$:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_line() +
  geom_point(aes(size = mean_wind),
             color = "red") +
  geom_hline(yintercept = 75,
             linetype = "dotted", 
             size = 1.2,
             color = "blue")      # эта линия не зависит от aes(Month, mean_temp); ну кроме границ
```

### 2.2.5 Рассмотрим geom_errorbar и geom_pointrange
Посмотрим описание `?geom_errorbar`. `Geom` ожидает от нас две переменные `ymax` и `ymin`, которые и будут означать минимальную и максимальную грпницу ошибки. `geom_errorbar` требует небольшой подготовки данных, а именно нужна группирующая переменная. `geom_pointrange` еще и среднюю точку нарисует.

Для начала сгруппируем и преобразуем данные:
```{r}
gr_mtcars <- group_by(mtcars, am)
(se_data <- summarise(gr_mtcars,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),  # вехняя граница ошибки
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg)))) # нижняя граница ошибки
```
А теперь нарисуем все это:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_errorbar(aes(ymin = y_min, 
                    ymax = y_max)) # здесь необходим aes, чтобы подтянуть данные из дата-фрейма
```

Изменим ширину и добавим средние точки:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) + # уменьшим ширину границ 
  geom_point(size = 3,        # размер
             shape = 21,      # форма точки
             fill = "white")  # цвет заливки
```

А теперь все то же самое, только `geom_pointrange`:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max))
```

Поколдуем над настройками:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max),
                  color = "red")
```

Добавим в изначальный дата-фрейм еще одну группировку:
```{r}
gr_mtcars_2 <- group_by(mtcars, am, vs)     # добавили vs
(se_data_2 <- summarise(gr_mtcars_2,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),  # вехняя граница ошибки
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg)))) # нижняя граница ошибки
```

Теперь у нас четыре группы данных. Нарисуем их:
```{r}
ggplot(se_data_2, aes(x = factor(am), y = mean_mpg)) +           # заменили se_data_2
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Но пока не понятно, где на этом графике переменная `vs`. Давайте добавим ее в `aes()` в качестве цвета:
```{r}
ggplot(se_data_2, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(vs))) +                     # теперь vs будет отображена цветом
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Не хватает линии соединяющей точки. Для ее построения необходимо в `aes` прописать группировку по переменной; в данном случае она совпадает с переменной цвета `vs`:
```{r}
ggplot(se_data_2, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(vs),
                      group = factor(vs))) +                    # группируем по цвету
  geom_line() +                                                 # добавляем линии связи
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Если бы мы группировали по большему числу значений переменных (возьмем `cyl`), то ничего не поменялось бы:
```{r}
gr_mtcars_3 <- group_by(mtcars, am, cyl)     # поменяли vs на cyl
(se_data_3 <- summarise(gr_mtcars_3,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg))))
```

```{r}
ggplot(se_data_3, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(cyl),      # поменяли vs на cyl
                      group = factor(cyl))) +   # поменяли vs на cyl
  geom_line() +
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Попробуем этот же дата-фрейм с `geom_pointrange`:
```{r}
ggplot(se_data_3, aes(x = factor(am),
                    y = mean_mpg,
                    color = factor(cyl),
                    group = factor(cyl))) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max)) +
  geom_line()  # тут порядок линий и точек не важен
```

### 2.2.6 Статистические трансформации внутри ggplot
А что если предобработку запихнуть внутрь `ggplot`?

Для начала просто отрисуем необходимые данные: 
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  geom_point()
```

Заменим `geom_point` на `stat_summary` и получим полный аналог `geom_pointrange`, но без предобработки:
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary()                       # тут пока еще чего-то не хватает :)
```

Функция `mean_cl_boot` (на ее вход подается вектор) возвращает данные, необходимые для построения доверительного интервала (`y` -- среднее, `ymin` -- минимум и `ymax` -- максимум) при помощи `bootstrap`'а.
```{r}
mean_cl_boot(mtcars$mpg)
```

Эти результаты вычислений мы помещаем как аргументы `stat_summary`; эта функция по-умолчанию работает с `y`. 
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary(fun.data = mean_cl_boot) # в ф-ию mean_cl_boot попадают данный по y 
```

Внутри `stat_summary` можно прописать нужный нам `geom` (`point` идет по-умолчанию):
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",       # поменяли geom
               width = 0.3) +           # немного сжали усы
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point", # добавили средние точки
               size = 2)
```

Добавим разбивку по `vs`:
```{r}
ggplot(mtcars, aes(factor(am), mpg, col = factor(vs))) + # добавили цвет vs-ом
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2)
```

Соединим теперь средние точки линией. Нужно соединить только средние значения:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(vs), 
                   group = factor(vs))) + # добавили группирующую переменную
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "line") # предыдующая команда, только geom - линия
```

Последнюю команду, соединяющуюу линиями средние точки можно немног оупростить:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(vs), 
                   group = factor(vs))) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,   # в fun.y передаем среднее значение и соединяем линией
               geom = "line")
```

Измения группирующую (она же цветовая) переменную:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),       # поменяли vs на cyl
                   group = factor(cyl))) +  # поменяли vs на cyl
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,
               geom = "line")
```

Плюсом такого метода является отсутствие предобработки данных; все вычисления на себя берет `ggplot`. А так же можно использовать какую-то свою функцию вместо `mean_cl_boot`. Вот такую например:
```{r}
# данная ф-ия рассчитывает среднее значение +/- стандартное отклонение
sd_error <- function(x){
  c(y = mean(x),
    ymin = mean(x) - sd(x),
    ymax = mean(x) + sd(x))
}
```

Подставим эту функцию в предыдущую выкладку:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),
                   group = factor(cyl))) +
  stat_summary(fun.data = sd_error,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = sd_error,    # подставили сюда свою функцию 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,
               geom = "line")
```

Зеленый график наехал на синий -- решаемо:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),
                   group = factor(cyl))) +
  stat_summary(fun.data = sd_error,
               geom = "errorbar",
               width = 0.3,
               position = position_dodge(0.2)) +  # сдвиг
  stat_summary(fun.data = sd_error,
               geom = "point",
               size = 2,
               position = position_dodge(0.2)) +  # сдвиг
  stat_summary(fun.y = mean,
               geom = "line",
               position = position_dodge(0.2))    # сдвиг
```

### 2.2.7 Задача
Давайте потренируемся комбинировать различные geoms на одном графике. Используя данные `mtcars` скомбинируем два варианта отображения количественных данных `boxplot` и `violin plot`.

* ось x -- `am` (нужен фактор)
* ось y -- `mpg`

Сохраните график в переменную `my_plot`.

Обратите внимание, я сделал `boxplot` чуть уже, чтобы ящики полностью оказались внутри `violin plot`: `geom_boxplot(width = 0.2)`

#### Решение
```{r}
ggplot(mtcars, aes(factor(am), mpg)) + 
  geom_violin() +
  geom_boxplot(width = 0.2)
```

### 2.2.8 Условие задачи
Для закрепления результатов поработаем с [вымышленными данными](https://stepic.org/media/attachments/course/724/sales.csv) о доходах в нескольких магазинах:

```{r}
sales = read.csv("https://stepic.org/media/attachments/course/724/sales.csv",
                 encoding =  "UTF-8")
str(sales)
```

* sale -- число проданных товаров
* shop -- номер магазина
* date -- год, за который велась статистика
* season -- время года
* income -- доход магазина

### 2.2.9 Задача
Отобразите взаимосвязь между доходом `income` и числом продаж `sale`, цветом точек указав номер магазина `shop`. Сохраните график в переменную `my_plot`. Обратите внимание, что линия тренда одна для всех наблюдений. Данные хранятся в переменной `sales`.

#### Решение
```{r}
(my_plot <- ggplot(sales, aes(income, sale)) +
  geom_point(aes(color = shop)) +
  geom_smooth()
 )
```

### 2.2.10 Задача
При помощи функции `stat_summary` постройте график с доверительными интервалами для демонстрации различий в доходах двух магазинов с учетом времени года:

* переменная `shop` -- ось x;
* переменная `income` -- ось y;
* переменная `season` -- цвет;
* geom pointrange.

Сохраните график в переменную `my_plot`, дополнив предложенный код. Обратите внимание, что доверительные интервалы не накладываются друг на друга! 

#### Решение
```{r}
(my_plot <- ggplot(sales, aes(shop, income, color = season)) +
   stat_summary(fun.data = mean_cl_boot,
                # geom = "pointrange",     # эту команду можно не писать, она по-умолчанию стоит
                position = position_dodge(0.2))
)
```

### 2.2.11 Задача
Теперь давайте отобразим на графике различия в продажах (переменная `sale`), в зависимости от:

* года (date) -- ось x;
* и номера магазина (shop) -- цвет.

Дополните предложенный код, чтобы получился график как в примере ниже. Используйте функцию `mean_cl_boot` для построения доверительных интервалов.Вам также понадобится использовать три `geoms`: `errorbar`, `point`, `line`. Используйте их прямо внутри функции `stat_summary()`. 

#### Решение
```{r}
ggplot(sales, aes(date, sale, color = shop, group = shop)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               position = position_dodge(0.2)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "point",
               position = position_dodge(0.2)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "line",
               position = position_dodge(0.2))
```

## 2.3 Facet -- способы группировки данных на графике
### 2.3.1 План урока
В этом уроке мы:

* научимся разбивать график на несколько подграфиков;
* узнаем в чем разница между `facet_grid()` и `facet_wrap()`;
* Поговорим о кино!

### 2.3.2 Вводные слова

### 2.3.3 Facet-grid
Пакет, а точнее функция `ggplot` позволяет поместить в график очень много информации. Он к этому располагает :)
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(am), size = disp,
       shape = factor(cyl))) +
  geom_point()
```

Но зачастую не стоит злоупотреблять этой возможностью. Рано или поздно график станет очень перегруженным и какие-то важные взаимосвязи будет трудно наблюдать. Поэтому если мы хотим показать некий эффект на разных уровнях какого-либо фактора, то нужно использовать `facet`.

`facet` -- это разбивка нашего графика на несколько подграфиков по какой-либо переменной. Есть несколько видов фасета, давайте посмотрим на наиболее типичные из них.

Пример графика с большим кол-вом уровней фактора:
```{r}
ggplot(diamonds, aes(carat, fill = color)) +
  geom_density()
```

Даже если добавить прозрачность `alpha=0.2`, то все равно график очень перегружен и хорошо понять распределение пременных очень тяжело. Поэтому в таких случаях лучше использовать `facet`. 

`facet-grid()` разбивает график на группы в виде матрицы. Можно задействовать сразу несколько переменных. 
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(color ~ cut) # разбивка по двум переменным
```

Если нам нужно разбить данные только по одному фактору, то вместо второго ставим просто точку:
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(. ~ cut) # в качестве столбцов
```

```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(cut ~ .) # в качестве строк
```

### 2.3.4 Facet-grid продолжение
Воспользуемся более маленьким набором данных `mtcars`, чтобы посмотреть еще одну особенность `facet-grid()`. Только для начала преобразуем две переменные в факторы:
```{r}
mtcars <- mutate(mtcars,
                 am = factor(am, labels = c("A", "M")),
                 vs = factor(vs, labels = c("V", "S")))
ggplot(mtcars, aes(hp)) +
  geom_dotplot() +
  facet_grid(am ~ vs, margins = T) # margins - добавляет сумму по строкам и столбцам
```

Добавим в эстетику еще одну переменную:
```{r}
ggplot(mtcars, aes(hp, mpg)) +            # добавили mpg 
  geom_point(aes(color = factor(cyl))) +  # поменяли geom и добавили цвет
  facet_grid(am ~ vs, margins = T)
```

Уберем из фасета одну переменную и добавим сглаживание:
```{r}
ggplot(mtcars, aes(hp, mpg)) +
  geom_point(aes(color = factor(cyl))) +
  facet_grid(. ~ am) +
  geom_smooth(method = "lm")
```

### 2.3.5 Facet-wrap
Основная идея `facet-grid()` -- разбить график на несколько подграфиков в виде матрицы. 

В `facet-wrap` мы строим несколько независимых графиков подряд, с перебором всех факторв.
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap(~ color + cut) # всегда начинается с тильды, а дальше просто перечисляем факторы
```

Нет деления на столбики и столбцы, на каждом графике есть свое название. Так же здесь очень легко задавать форму вывода графика -- можно задавать число столбиков и столбцов.
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap(~ color + cut, nrow = 5) # кол-во строк 
```

Для фасета достаточно одной факторной переменной:
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap( ~ cut)          # оставили всего одну переменную 
```

#### Без фасета
```{r}
ggplot(diamonds, aes(carat, price, col = color)) +
  geom_smooth()
```

#### Фасет спешит на помощь!
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_smooth() +
  facet_wrap(~ color) # просто переместили переменную из эстетики в фасет
```

```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_smooth() +
  facet_grid(color ~ .) # просто переместили переменную из эстетики в фасет
```

### 2.3.6 Заключительные слова
Совет: три переменный, это максимум для одного графика. А в фасет можно закинуть сразу два фактора.

### 2.3.7 Задача
Потренируемся с разбиением графика на подгруппы! Используя `facet_grid()` постройте следующий график и сохраните его в переменную `mpg_facet`.

* ось `x` -- переменная mpg
* `facet` -- переменная `am` по строчкам и `vs` по столбцам

#### Решение
```{r}
(mpg_facet <- ggplot(mtcars, aes(mpg)) +
  geom_dotplot() +
  facet_grid(am ~ vs)
 )
```

### 2.3.8 Задача
Используя данные `iris`, постройте график плотности для переменной `Sepal.Length`. Разбейте график на части по переменной `Species` при помощи `facet_wrap`. Результат сохраните в переменную `sl_wrap`.

#### Решение
```{r}
(sl_wrap <- ggplot(iris, aes(Sepal.Length)) +
  geom_density() +
  facet_wrap(~ Species)
 )
```

### 2.3.9 Задача
Используя данные `iris`, постройте график, иллюстрирующий взаимосвязь переменных `Sepal.Length` и `Sepal.Width` внутри каждого вида (переменной `Species`), при помощи `facet_wrap()`.

В этом задании вам потребуется использовать два `geom`:

* `geom_point` -- для отображения отдельных наблюдений,
* `geom_smooth` -- для добавления сглаживания.

Сохраните график в переменную `my_plot`.

#### Решение
```{r}
(my_plot <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
   geom_point() +
   geom_smooth() +
   facet_wrap(~ Species)
  
)
```

### 2.3.10 Задача
«Отряд самоубийц» уже посмотрели? Пишите в комментариях, как вам! У меня вот смешанные чувства вызвала эта команда суперзлодеев. Собрали самых интересных персонажей вселенной и отправили их в одну локацию весь фильм ходить , перебрасываясь односложными фразами. Джокера совсем не показали, все так ждали Джареда Лето в этой роли, а он появился, считайте, в двух эпизодах! К чему это я? Поговорим о кино!

Вы можете скачать данные myMovieData (жмите на [ссылку](https://stepik.org/media/attachments/course/724/myMovieData.csv)), в которых представлена различная информация о голливудских фильмах с 2002 по 2005: тип жанр, бюджет и год выхода на экраны. Давайте построим следующий график, чтобы выяснить есть ли различия в бюджетах фильмов разного жанра из года в год. Cохраните результат в переменную `my_plot`.

* ось `x` -- переменная `Type`
* ocь `y` -- переменная `Budget`
* `facet` -- переменная `Year` (используйте `facet_grid`)

В примере графика я отобразил название жанров вертикально, чтобы все уместилось на графике и не перекрывалось. В коде, который вы отправляете на проверку, это необязательно, но вот как это можно было бы сделать:

`ggplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1))`

Про настройку таких моментов мы поговорим далее.

#### Решение
```{r}
myMovieData <- read.csv("https://stepik.org/media/attachments/course/724/myMovieData.csv")
# glimpse(myMovieData)
ggplot(myMovieData, aes(Type, Budget)) +
  geom_boxplot() +
  facet_wrap(~ Year) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

## 2.4 Scale и Theme: оси, легенда, внешний вид графика
### 2.4.1 План урока
В этом уроке мы:

* поработаем с настройками `scales`;
* научимся видоизменять внешний вид графика.

```{r, echo = F}
data(mtcars) # заново подгружаем датасет, т.к. ранее мы его немного изменили
```


### 2.4.2 Функция scale
При помощи функции sсale мы получаем контроль над значениями на осях и в легенде. На графике ниже каждая точка имеет три значения: по `x`, по `y` и цвет:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point()
```

Начнем с оси `x`. Подберем из огромного списка функций начинающихся на scale именну ту, которая контролирует ось x: `scale_x_continuous` т.к. переменная у нас континуальная:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",         # подпись x*
                     breaks = c(10, 20, 30, 31, 32, 33)) # вектор из последовательности делений
```

Если нужно поменть на оси только название, то есть более быстрый способ это сделать с помощью `xlab`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  xlab("Miles/(US) gallon")        # точечная смена имени оси х
```

Но если на оси x нужно менять больше одного параметра, то лучше сразу заносить все изменения под `scale_x_continuous`.

Поиграем с делениями шкалы:
```{r}
seq_x <- round(seq(min(mtcars$mpg),
                   max(mtcars$mpg),
                   length.out = 15))               # переменная для делений шкалы

ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = seq_x)
```

### 2.4.3 Функция scale. Продолжение.
Занесем переменную внутрь `ggplot`'а:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)))  # НО единица не входит в диапазон данных (
```

Но у нас ничего не вышло, шкала НЕ начинается единицы. Необходимо задать лимиты `limits`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35))             # укажем лимиты явно
```

Короткая запись для лимитов:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  xlab("Miles/(US) gallon") +
  xlim(c(1, 35))               # прямая функция для смены лимитов шкалы
```

Отступы в графике от крафних данных -- `expand`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(expand = c(1, 1))
```

Сузим пространство графика еще сильнее:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(expand = c(2, 2))
```

Все то же самое справедливо и для оси `Y`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35)) +
  scale_y_continuous(limits = c(50, 400))          # поднимем слегка график   
```

### 2.4.4 Меняем scale по цвету, заливке, размеру и виду точек
#### Настройка легенды переменной "цвета" -- scale_color
Вот мы и добрались до нашей третьей переменной, до цвета. За цвет отвечает `scale_color`, а дальше в зависимости от переменной; если она дискретная (фактор), то это будет функция `scale_color_discrete`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35)) +
  scale_y_continuous(limits = c(50, 400)) +
  scale_color_discrete(name = "Transmission")         # поменяли имя легенды
```

Поменяем названия внутри легенды:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35)) +
  scale_y_continuous(limits = c(50, 400)) +
  scale_color_discrete(name = "Transmission",
                       labels = c("Auto", "Manual"))
```

**Очень полезная возможность, не нужно менять сами данные, ради двух подписей на графике!!!**

Давайте теперь вручную выберем цвета легенды с помощью функции `scale_color_manual`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35)) +
  scale_y_continuous(limits = c(50, 400)) +
  scale_color_manual(values = c("Red", "Blue"),
                       name = "Transmission",
                       labels = c("Auto", "Manual"))
```

#### Настройка легенды переменной "заливки" -- scale_fill
Рассмотрим пример с одной переменной на графике, чтобы явно показать настройку легенды при заливке цветом: 
```{r}
ggplot(mtcars, aes(hp, fill = factor(am))) + # фактор на заливке
  geom_density(alpha = 0.3) +
  scale_fill_discrete(name = "Transmission") # дискретная, т.к. у нас фактор отвечает за заливку
```

```{r}
ggplot(mtcars, aes(hp, fill = factor(am))) +
  geom_density(alpha = 0.3) +
  scale_fill_manual(name = "Transmission",
                    values = c("Red", "Green"))
```

#### Настройка легенды переменной "размера" -- scale_size
Рассмотрим пример с непрерывной переменной в качестве размера точки:
```{r}
ggplot(mtcars, aes(hp, mpg, size = disp)) +
  geom_point(alpha = 0.7)     # много наложений точек; прозрачность улучшает читаемость
```

Чтобы изменить легенду переменной отвечающий за размер точки, необходима функция `scale_size_continuaus`:
```{r}
ggplot(mtcars, aes(hp, mpg, size = disp)) +
  geom_point(alpha = 0.7) +
  scale_size_continuous(name = "Объем движка",      # меняем название легенды
                        breaks = seq(100, 400, 40)) # увеличим градацию в легенде
```


#### Настройка легенды переменной "формы точки" -- scale_shape
Добавим в график еще одну переменную, отвечающую за форму точки:
```{r}
ggplot(mtcars, aes(hp, mpg, size = disp, shape = factor(vs))) +
  geom_point(alpha = 0.7) +
  scale_size_continuous(name = "Объем движка",
                        breaks = seq(100, 400, 40))
```

Теперь чтобы настроить легенду формы нужна функция `scale_shape`:
```{r}
ggplot(mtcars, aes(hp, mpg, size = disp, shape = factor(vs))) +
  geom_point(alpha = 0.7) +
  scale_size_continuous(name = "Объем движка",
                        breaks = seq(100, 400, 40)) +
  scale_shape_discrete(name = "Форма движка",         # discrete т.к. перменная факторная
                       labels = c("V", "рядный"))
```

#### Еще пример
Рассмотрим пример с факторной (качественной) переменной на оси **X** и континуальной (количественной) на оси **Y**. Для изменения подписи под осью для факторных переменных необходима функция `scale_x_discrete`:
```{r}
ggplot(mtcars, aes(factor(am), hp)) +
  geom_boxplot() +
  scale_y_continuous(name = "Мощность, лс") +    # вектор
  scale_x_discrete(name = "Трансмиссия",         # фактор
                   labels = c("Авто",
                              "Ручная"))
```

### 2.4.5 Промежуточные итоги
бла-бла-бла

### 2.4.6 Задача
В этом задании мы построим график используя данные Iris. Наша цель отобразить взаимосвязь переменных Sepal.Length (ось X) и Petal.Length (ось Y) внутри трех групп по переменной Species. Для этого постройте `scaterplot`, отобразите цветом значения переменной Species и добавьте линейное сглаживание в каждой группе.

Далее от вас потребуется привести график к более завершенному виду. Мы переведем на русский название осей, название легенды и ее расшифровку:

* Ось X -- "Длина чашелистика".
* Ось Y -- "Длина лепестка".
* Название легенды -- "Вид цветка".
* Расшифровка легенды: "Ирис щетинистый", "Ирис разноцветный", "Ирис виргинский".

Также мы чуть измени отображение значений по осям. 

* Значения по оси X должны начинаться с 4 и заканчиваться на 8 с шагом в единицу.
* Значения по оси Y должны начинаться с 1 и заканчиваться на 7 с шагом в единицу.

#### Решение
```{r}
ggplot(iris, aes(Sepal.Length, Petal.Length, color = Species)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_continuous(name = "Длина чашелистика",
                     breaks = seq(4, 8, 1),
                     limits = c(4, 8)) +
  scale_y_continuous(name = "Длина лепестка",
                     breaks = seq(1, 7, 1),
                     limits = c(1, 7)) +
  scale_color_discrete(name = "Вид цветка",
                       labels = c("Ирис щетинистый",
                                  "Ирис разноцветный",
                                  "Ирис виргинский"))
```

### 2.4.7 scale_fill_brewer
В описании к функции `scale_fill_brewer` есть ссылка на замечательный сайт [http://colorbrewer2.org/](http://colorbrewer2.org/), этот сайт поможет нам сформировать палитру цветов для нашего графика.

#### До
Ну, поехали! Сначала отрисуем график без дополнительных вмешательств:
```{r}
ggplot(mtcars, aes(factor(am), hp, fill = factor(cyl))) +
  geom_boxplot()
```

#### После
А теперь откроем страничку [http://colorbrewer2.org/](http://colorbrewer2.org/) и подберем следующие параметры:

* **Number of data classes** -- 3
* **Nature of your data** -- qualitative
* **Pick a color scheme** -- 2

Остальное не трогаем. Теперь пропишем парамеры `qualitative` и номер **второй** палитры для количества переменных равным **трем**:
```{r}
ggplot(mtcars, aes(factor(am), hp, fill = factor(cyl))) +  # три переменных
  geom_boxplot() +
  scale_fill_brewer(type = "qual",       # "Nature of your data"" из colorbrewer (“div”, “qual”, “seq”)
                    palette = 2)         # номер палитры (color scheme) из "Pick a color scheme""
```

#### Пример с scale_color_brewer
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  scale_color_brewer(type = "qual",
                     palette = 6) +
  theme_bw()
```

### 2.4.8 Продолжаем работать с функцией theme
Для начала поизучеем справку по функции`theme`. Офигеваем от кол-ва настроек.

#### Классическая тема
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  scale_color_brewer(type = "qual",
                     palette = 6) +
  theme_classic()                    # убирает линии штриховки и фон 
```

#### Темная тема
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  scale_color_brewer(type = "qual",
                     palette = 6) +
  theme_dark()                    # немного затемнимся
```

### 2.4.9 Пакет ggthemes
Существует много сторонних пакетов с различными `themes`. Установим один из таких под названием `ggthemes`
```{r}
library(ggthemes)
```

Cправка по этому пакету находится на [GitHub'е](https://github.com/jrnold/ggthemes).

Переберем несколько тем:
#### ggthemes: theme_economist
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  theme_economist()
```

#### ggthemes: theme_solarized
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  theme_solarized()
```

#### ggthemes: theme_stata
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  theme_stata()
```

## 2.5 Пример решения практическоой задачи
### 2.5.1 План урока
В этом уроке:

* мы поэтапно разберем построение графика с нуля до итогового результата, когда график можно вставлять в отчет или в презентацию.

### 2.5.2 Постройка базового графика
Подгрузим датасет  который мы хотим визуализировать:
```{r}
d <- read.csv("https://stepic.org/media/attachments/course/724/example_data.csv")
glimpse(d)
```
#### Базовый график
Отрисуем базу нашего графика -- данные **d** и настройки мэппинга, а именно:

* ось X -- date
* ось Y -- percent
* color -- system
* group -- system (для отрисовки линий)
```{r}
ggplot(d, aes(date, percent, color = system,
              group = system)) +  # группируем для geom_line
  geom_point() +
  geom_line()                     # geom_line соединяет все точки в каждой группе
```

#### Добавим вертикальную линию -- geom_vline
Вспомним, что у фактора в `R` есть уровни `levels`:
```{r}
d$date
```
Каждый уровень фактора закодирован целым числом:
```{r}
str(d$date)
```

Поэтому на нашем графике **Now** это **8**, а **2011** это **7**. И чтобы нарисовать линию между 7 и 8 делениями фактора, нужно просто присвоить аргументу `xintercept` значение **7.5**:
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = 7.5)     # линия ровно между 7-м и 8-м уровнем фактора
```

#### Меняем точки
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_line() +
  geom_point(shape = 21,         # форма точки
             size = 5,           # ее размер
             stroke = 1.5) +     # толщина обводки
  geom_vline(xintercept = 7.5)
```

#### Меняем цвет линий графика
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_color_manual(values = c("springgreen2",
                                "cyan",
                                "red",
                                "yellow1",
                                "orangered1"))
```

#### Убираем задний фон
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  theme_classic()
```

### 2.5.3 Продолжаем изменять график
#### Меняем надписи на шкале Y
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),        # добавили отметку 0.15
                     limits = c(0, .15)) +                     # добавили лимиты (0, 0.15)   
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  theme_classic()
```

#### Меняем десятичную шкалу на процентную
В пакете `scales` есть чудесная функция `percent` изменяющая аргумент на процент:
```{r}
scales::percent(0.4)
```

Пропишем его в качестве аргумента к функции `labels`:
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +                # превращаем десятичную шкалу в процентную
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  theme_classic()
```

#### Убираем подписи осей
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  xlab("") +      # просто пустые строки вместо значений
  ylab("") +      # просто пустые строки вместо значений
  theme_classic()
```

#### Перемещаем легенду вверх
Сохраним наш график в переменную и просто будем прибавлять к нму наши будущие изменения:
```{r}
p <- ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  xlab("") +
  ylab("") +
  theme_classic()
```

Убиреаем подпись легенды:
```{r}
p + theme(legend.title = element_blank()) # отрисовка пустого объекта
```

Перенос легенды:
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top") # перенос легенды наверх
```

#### Заливка фона графика
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          plot.background = element_rect(color = "black",  # окантовка
                                         fill = "black"))  # весь задний фон графика 
```

#### Цвет шрифта
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          plot.background = element_rect(color = "black",
                                         fill = "black"),
          text = element_text(color = "white"))           # цвет шрифта только в легенде
```

#### Цвет фона самого графика
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          plot.background = element_rect(color = "black",
                                         fill = "black"),
          panel.background = element_rect(fill = "black"),   # вроде хватает одного fill
          text = element_text(color = "white"))
```

#### Фон легенды
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          legend.background = element_rect(fill = "black"),
          plot.background = element_rect(color = "black", fill = "black"),
          panel.background = element_rect(fill = "black"),     # затемняем фон легенды
          text = element_text(color = "white"))
```

#### 2.5.4 Продолжаем-с
Для начала занесем наши изменения темы графика в отдельную переменную:
```{r}
my_theme <- theme(legend.title = element_blank(),
          legend.position = "top",
          legend.background = element_rect(fill = "black"),
          plot.background = element_rect(color = "black", fill = "black"),
          panel.background = element_rect(fill = "black"),
          text = element_text(color = "white"))
```

#### А теперь поправим точки и вертикальную линию:
```{r}
p <- ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_line(size = 1.3) +           # переместили вверх, и утолщили
  geom_point(shape = 21, size = 4, stroke = 1.5,  # чутка уменьшили
             fill = "black") +      # залили черным
  geom_vline(xintercept = 7.5,
             color = "white",       # побелили 
             linetype = "dotted") + # точечки
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  xlab("") +
  ylab("") +
  theme_classic()
p + my_theme
```

#### Наносим гроизонтальные линии на фоне
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          legend.background = element_rect(fill = "black"),
          plot.background = element_rect(color = "black", fill = "black"),
          panel.background = element_rect(fill = "black"),
          text = element_text(color = "white"),
          panel.grid.major.y = element_line(color = "gray50",       # цвет горизонтальных линий
                                            linetype = "longdash")) # длинные тире
```

#### Подписи шкал и легенды
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          legend.background = element_rect(fill = "black"),
          plot.background = element_rect(color = "black", fill = "black"),
          panel.background = element_rect(fill = "black"),
          text = element_text(color = "white"),
          panel.grid.major.y = element_line(color = "gray50", linetype = "longdash"),
          axis.text.x = element_text(face = "bold", size = 12, color = "white"),  # подписи x 
          axis.text.y = element_text(face = "bold", size = 12, color = "white"),  # подписи y
          legend.text = element_text(size = 12, color = "white"))                 # текст легенды
```

#### Заголовок и подписи внизу
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_line(size = 1.3) +
  geom_point(shape = 21, size = 4, stroke = 1.5, fill = "black") +
  geom_vline(xintercept = 7.5, color = "white", linetype = "dotted") +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red", "yellow1", "orangered1")) +
  xlab("") +
  ylab("") +
  ggtitle("Top 5 Linux distributions (% of total per year)") +               # название прописываем тут
  theme_classic() +
  theme(legend.title = element_blank(),
        legend.position = "top",
        legend.background = element_rect(fill = "black"),
        plot.background = element_rect(color = "black", fill = "black"),
        panel.background = element_rect(fill = "black"),
        text = element_text(color = "white"),
        panel.grid.major.y = element_line(color = "gray50", linetype = "longdash"),
        axis.text.x = element_text(face = "bold", size = 12, color = "white"),
        axis.text.y = element_text(face = "bold", size = 12, color = "white"),
        legend.text = element_text(size = 12, color = "white"),
        plot.title = element_text(face = "bold", size = 17, hjust = 0.5))    # отцентровали титульник
```

### 2.5.5 Перенос команд в переменную
Все эти настройки графика можно переннести в меременную и использовать когда появится необходимость.
```{r}
p <- ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_line(size = 1.3) +
  geom_point(shape = 21, size = 4, stroke = 1.5, fill = "black") +
  geom_vline(xintercept = 7.5, color = "white", linetype = "dotted") +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red", "yellow1", "orangered1")) +
  xlab("") +
  ylab("") +
  ggtitle("Top 5 Linux distributions (% of total per year)") +
  theme_classic()

my_theme <- theme(legend.title = element_blank(),
        legend.position = "top",
        legend.background = element_rect(fill = "black"),
        plot.background = element_rect(color = "black", fill = "black"),
        panel.background = element_rect(fill = "black"),
        text = element_text(color = "white"),
        panel.grid.major.y = element_line(color = "gray50", linetype = "longdash"),
        axis.text.x = element_text(face = "bold", size = 12, color = "white"),
        axis.text.y = element_text(face = "bold", size = 12, color = "white"),
        legend.text = element_text(size = 12, color = "white"),
        plot.title = element_text(face = "bold", size = 17, hjust = 0.5))
p + my_theme
```

### 2.5.6 Финалочка
При помощи отдельного пакета мы добавляем надписи на графике:
```{r}
library(grid)
p + my_theme

grid.text("Data sourse: The DistroWatch's Page Hit Ranking (Nov. 23, 2011)",
          x = 0.02, y = 0.01, just = c("left", "bottom"),
          gp = gpar(fontface = "bold", fontsize = 9, col = "white"))

grid.text("www.pingdom.com",
          x = 0.98, y = 0.01, just = c("right", "bottom"),
          gp = gpar(fontface = "bold", fontsize = 9, col = "white"))
```

# 3. R Markdown
## 3.1 Здравствуйте, я ваш R Markdown!
### 3.1.1 Введение
### 3.1.2 Установка пакета
```{r}
# install.packages("rmarkdown")
library(rmarkdown)
```

### 3.1.3 Что такое R Markdown и для чего он нужен
Языку `R` уже больше пятнадцати лет, а вот `rmarkdown` всего два года [^1]. Поэтому прежде чем погрузимся в детали `rmarkdown`, давайте прежде поймем что же это такое и для чего это нужно.

[^1]: На момент написания курса в 2016 году.

#### Общее определение `rmarkdown` 
Тут две ключевые идеи:

* **это средство для создания динамических документов, отчетов и презентаций**; важно понимать, что один и тот же исходный файл может служить основой для большого набора конечных файлов разных форматов
* **это инструмент для встраивания результатов исполнения кода на `R` в текст документа**; большое количество форматов, причем постоянно растущее

#### Зачем это нужно
Начнем с самого важного:

* **Для полной воспроизводимости результатов.** Как только мы скомпилировали отчет и у нас есть исходный текст отчета, мы можем его послать кому-то еще и результат полученный у нас будет воспроизводиться у всех
* **Для конвертирования исходного .Rmd файла в разные форматы:**
    + HTML
    + PDF
    + MS Word (ODT, RTF)
    + Markdown
    + Презентации: ioslides, reveal.js, Slidy, Beamer (первые три в HTML, последняя в PDF)
    + Шаблоны для web-сайтов
* **Для удобства написания, разметки и форматирования документа**
* **Для распространения открытого кода, идей, алгоритмов и результатов исследований**

#### Reproducible research и коллаборация
Небольшое лирическое отступление. 

* [Статья в Nature](http://www.nature.com/news/1-500-scientists-lift-the-lid-on-reproducibility-1.19970): более 70: опрошенных исследователей не могут воспроизвести результаты, полученные коллегам; они видят исходные данные, видят к чему это должно привести, но не могут воспроизвести шаги
* В последнее время ситуацитя ухудшается:
    + Растут объемы данных
    + Используются сложные схемы (пред)обработки данных
    + Применяемые алгоритмы требуют тонкой настройки
    + Форматы традиционной журнальной статьи не отвечает современным требованиям
* Это привело к появлению [Ropensci reproducibility guide](http://ropensci.github.io/reproducibility-guide/sections/dataSharing/) (кстати, вот хорошая [статья](http://vita.had.co.nz/papers/tidy-data.pdf) от Hadley Wickham])

### 3.1.4 Glacier Part 1

### 3.1.5 Встраивание кода
Есть два способа встроить результаты исполнения кода на `R` в `rmarkdown`:

#### Inline code
* Простейший случай: вставка результата **в виде текста** прямо в строку
* Синтаксис: backtik ("`") - "r" - пробел - кода на R - backtik
* Пример: "Теорема доказана в предположении, что число пи равно `` `r knitr::inline_expr('ceiling(pi)')` ``" [^2]
* Результат: "Теорема доказана в предположении, что число пи равно `r ceiling(pi)`"

[^2]: Как это сделано? Справка по функции `?knitr::inline_expr`.

#### Code chunks
* Основной способ вставки кода
* Каждый кусок (chunk, чанк) настраиваем с помощью опций
* Чанк может что-либо печатать, рисовать или вообще не иметь вывода

#### Синтаксис чанков
Чанк должен начинаться с новой строки. Затем идет три бэктика и в фигурных скобках пишем `r`. Потом с новой строки мы пишем код как обычно и закрываем чанк тремя бэктиками с новой строки. Вот как это выглядит:
```{r, echo = FALSE, comment = ""}
cat(c("```{r}",
      "head(iris)",
      "```"),
    sep = '\n')       # разделение путем переноса каретки на новую строку
```

После компиляции этого чанка мы получим две вещи:

* будет выведен исходный код (с подсветкой синтаксиса)
* и результат выполнения кода

```{r}
head(iris)
```

Весь вывод по умолчанию отделяется двумя хэштегами `##`. Это на тот случай, если случайно при копировании кода захватывается часть вывода; тогда он сойдет за комментарии и не будет исполняться. Это настраиввается в заголовке чанка при помощи опции `comment`.

#### Опция echo = FALSE
* В фигурных скобках через запятую можно указывать *опции* чанка
* По умолчанию печатается и код, и его результат
* Опция `echo = FALSE` подавит вывод кода:

```{r, echo = FALSE, comment = ""}
cat(c("```{r, echo = FALSE}",
      "(1:10)^3",
      "```"),
    sep = '\n')
```

```{r, echo = F}
(1:10)^3
```

И мы увидим только рузультат выполнения чанка. Само выражение `(1:10)^3` не будет напечатано. Это необходимо для того, чтобы спрятать некоторые детали вычислений. Например для специалистов не владеющих языком `R`. А те кто владеют, могут обратится к исходному файлу.

### 3.1.6 Вопрос
Помните древнегреческий миф про нимфу Эхо? Пока вы проходите этот тест, я пойду читать википедию: не помню, чем она так провинилась (возможно, злоупотребляла ассоциациями первого уровня).
Верно ли, что ...

* **по умолчанию echo=TRUE?**
* воспроизводимость результатов нужна только для академических исследований?
* **один и тот же исходный .Rmd файл может быть скомпилирован как в HTML, так и PDF?**
* **в RStudio есть проверка правописания?**

### 3.1.7 Glacier Part 2

### 3.1.8 Задача
Скачайте файл glacier.csv, если вы ещё этого не сделали, и познакомьтесь с ним поближе. Попробуйте выяснить, о каких ледниках идёт речь в тексте внизу. Можно работать непосредственно в консоли, а можно решать при помощи inline кода, который хорошо подходит в данном случае, если такой текст вы захотите включить в отчёт.

Среди шести изучаемых ледников самую короткую историю наблюдений имеет **Вопрос 1**. При этом ледник, для которого медианное значение изменения (переменная Value для Annual Mass Balance) наиболее близко к нулю, называется **Вопрос 2** . Единственное пропущенное значение содержит история наблюдений ледника **Вопрос 3**.

#### Решение
Для начала подгрузим датасет
```{r}
gl <- read.csv("glacier.csv", na.strings = "..", comment.char = "#")
```

##### Ответ 1
```{r}
gl %>% 
  group_by(GEO) %>%                                   # группируем по GEO
  summarise(Val = max(Ref_Date) - min(Ref_Date)) %>%  # схлопываем по новой переменной Val
  filter(Val == min(Val)) %>%                         # отфильтровываем минимальный
  select(GEO)                                         # выбираем только переменную GEO из полученной строки
```

##### Ответ 2
```{r}
gl %>%
  filter(MEASURE == "Annual mass balance") %>%   # фильтруем только Annual mass balance
  group_by(GEO) %>%                              # группируем по GEO
  summarise(M = median(Value, na.rm = T)) %>%    # схлопываем по новой переменной - медиане
  filter(abs(M) == min(abs(M))) %>%              # ищеи наиболее близкое к нулю (наимаеньший модуль)
  select(GEO)                                    # выбираем только название ледника
```

##### Ответ 3
```{r}
gl %>%
  filter(is.na(Value)) %>%   # отфильтровываем значение с NA 
  select(GEO)                # выбираем только GEO
```

## 3.2 Погружаемся в детали: R слева, markdown справа
### 3.2.1 Примеры разметок
Не трудно заметить, что словосочетание **R Markdown** состоит из двух слов **R** и **Markdown**. Пр **R** мы знаем -- это использование `inline code` и `chunk` в теле документа. А что такое **Markdown**? Вот на этот вопрос мы и будеи отвечать.

#### Зачем нужен Markdown
Для того чтобы разобраться откуда он взялся, нам необходимо сказать пару слов о таком понятии как **HTML**:

* HTML -- это набор инструкций для браузера; эта разметка предназначена для использования браузером
* Написание HTML-страниц в ручном режиме очень неудобно
* Markdown -- текстовый формат, удобный для написания и для чтения
* Markdown -- инструмент конвертации такого текста в HTML

Фишка Markdown -- его легко как писать так и читать (и человеку и машине).

#### Основные элементы Markdown
Как мы уже заметили, некоторые символы в Markdown получают дополнительное значение.

* `**Жирный** __шрифт__` --> **Жирный шрифт**
* `*Курсивный* _шрифт_`  --> *Курсивный шрифт*
* Моноширный шрифт `` `sum(x)` `` --> `sum(x)`
* Верхние и нижние индексы `A^2^~i~` --> A^2^~i~
* `~~Зачеркнутый текст~~` --> ~~Зачеркнутый текст~~
* Экранирование символов (escape): `\* \_ \\ \$` --> \* \_ \\ \$ 
* Автозамена тире и длинного тире: `-- ---` --> -- --- 
* Заголовки: `# Header 1` -- `###### Header 6`
* Гиперссылка: `<http://bash.im>` --> <http://bash.im>
* Гиперссылка в тексте: `[Этот курс](https://stepic.org/course/724)` --> [Этот курс](https://stepic.org/course/724)

#### Поддержка $\LaTeX$
$\LaTeX$ -- специальный математический движок для верстки и публикации работ, с большим кол-вом формул.

* Для сборки pdf нужна установка $\TeX$ (MiKTex -- для Windows, TeX Live -- для Linux, Mac OS)
* `$\hat{\beta} = (X^T X)^{-1} X^T y$` --> $\hat{\beta} = (X^T X)^{-1} X^T y$
* `$$i \hbar \frac{\partial}{\partial t} \Psi(\textbf{r},t) = \hat{H} \Psi (\textbf{r},t)$$` --> $$i \hbar \frac{\partial}{\partial t} \Psi(\textbf{r},t) = \hat{H} \Psi (\textbf{r},t)$$
* Полноценные возможности $\TeX$ (настройки, пакеты, макросы)
* Формулы корректно отображаются в HTML благодаря MathJax

### 3.2.2 Glacier Part 3

### 3.2.3 Вопрос
В синтаксисе markdown некоторые символы обретают новый смысл, благодаря чему .Rmd файл представляет собой так называемый rich text. Поэкспериментируйте с различными вариантами написания и посмотрите, что будет получаться (что будет, например, при вложении зачёркнутого текста в моноширинный?).
Кстати, в последнее время всё больше сайтов поддерживают markdown (по крайней мере частично) для написания постов и комментариев: например, github и stackoverflow.

### 3.2.4 Опции чанков
#### Сначала был knitr
История R Markdown началась с пакета `knitr`.

* Сейчас именно он отвественен за обработку кода на `R`
* Он может быть использован отдельно от R Markdown
* Изначальный фокус `knitr` -- pdf (LaTeX + R)

#### Chunk options
* Существуют глобальные настройки `knitr`
* Каждый чанк может иметь локальные настройки, переопределяющие глобальные
* Локальные настройки указываются через запятую и их может быть любое количество
* Все возможные опции приведены на <https://yihui.name/knitr/options/>

#### Основные опции
* **`echo` (default: `TRUE`)** -- отображать ли исходный код чанка?
* **`eval` (default: `TRUE`)** -- исполнять ли код чанка?
* **`include` (default: `TRUE`)** -- отображать ли результат чанка?
* **`error` (default: `FALSE`)** -- добавлять ли в документ текст ошибок?
* **`message` (default: `TRUE`)** -- добавлять ли в документ текст сообщений?
* **`warnings` (default: `TRUE`)** -- добавлять ли в документ текст предупреждений?
* **`comment` (default: `##`)** -- какой префикс добавлять перед каждой строкой вывода результата?
* **`results` (default: `markup`)** -- каким образом выводить результаты исполнения?
* **`highlight` (default: `TRUE`)** -- подсвечивать ли синтаксис кода?
* **`tidy` (default: `FALSE`)** -- отформатировать ли код (отступы, пробелы, переносы...)?

#### Графики
* **`fig.hight`, `fig.width`** -- размеры изображения (в дюймах)
* **`fig.align` (default: `default`)** -- расположение графика на странице; еще бывают `left`, `right`, `center`
* **`fig.cap` (default: `NULL`)** -- строка с подписью к графику

#### Кэширование чанков
* Некоторые чанки могут содержат длинные вычисления; и каждый раз при пересборке конечного файла прийдется долго ждать
* Для таких чанков нужно выставить `cache = TRUE`
* Кэш срабатывает в том случае, если содержимое кода внутри чанка не изменялось; если в одном чанке что-то изменилось, то он пересчитается и мы будем ждать завершения пересчета только один раз
* Важно: если чанки взаимосвязаны, нужно помнить о кэше!
* В этих случаях помолжет опция `dependson`
* Важное: некоторые алгоритмы используют генераторы случайных чисел!

#### Метки чанков
* В фигурных скобках между "r" и опциями чанка может находиться метка чанка
* Чанки могут ображаться друг к другу по меткам

```{r echo = F, comment = ""}
cat(c("```{r chunk1, echo = TRUE, result = 'hide'}",
      "cos(2*pi)",
      "```"),
    sep = "\n")
```

```{r echo = F, comment = ""}
cat(c("```{r chunk2, echo = FALSE, ref.lable = 'chunk1'}",
      "```"),
    sep = "\n")
```

```{r chunk1, echo=TRUE, results='hide'}
cos(2*pi)
```

```{r chunk2, echo=FALSE, ref.label="chunk1"}
```

Второй чанк обращается к первому. И первый чанк как бы неявно будет вызван вторым.

#### Глобальные опции
* Задаются, как правило, в начале документа (но могут меняться локально)
* `knitr::opts_chunk$set(echo = F, fig.width = 5, fig.height = 5)`
* Этот вызов удобно поместить в отдельный чанк с опцией `include = F`

### 3.2.5 Вопрос
Будьте бдительны: при неверном написании названия опции чанка не будет ни ошибок, ни предупреждений, просто опция не сработает. Особенно это касается опции cache (не путать с cash).

"If anything goes wrong, just remove that folder with cash, will you?"

Теперь, собственно, тест. Верно ли, что...

* LaTeX корректно поддерживается только при сборке в pdf?
* **при выставлении cache=TRUE кеш будет перестроен, если изменился код чанка?**
* **если опция чанка указана и глобально, и локально, то используется локальное значение?**
* глобальные опции R markdown задаются при помощи функции options?

### 3.2.6 Glacier Part 4
В чанке настроек можно внести вызов функции `options` [^3], с настройками чисел с плавающей точкой:
```{r echo = F, comment = ""}
cat(c("```{r setup, include = F}",
      "options(scipen = 0, digits = 3)",
      "```"),
    sep = "\n")
```

[^3]: Справка доступна здесь `?base::options`

Записать этот урок !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

### 3.2.7 Задача
Я работаю над написанием отчёта по составлению задач для нового курса под названием ["Анализ данных в R. Часть 2"](https://stepic.org/course/724). В начале документа я поставил такой чанк:

```{r echo = F, comment = ""}
cat(c("```{r setup, include=FALSE}",
      "knitr::opts_chunk$set(echo=FALSE, warning=FALSE, eval=FALSE)",
      "```"),
    sep = "\n")
```

Что я получу после компиляции документа, если добавлю теперь вот такой чанк?
```{r echo = F, comment = ""}
cat(c("```{r squares, eval=TRUE, cache=TRUE}",
      "1:4 ^ 2",
      "```"),
    sep = "\n")
```

#### Ответы:
* Код выведен не будет, напечатаются числа 1, 4, 9, 16.
* Будет выведен код, напечатаются числа 1, 4, 9, 16.
* Код не будет ни выведен, ни исполнен.
* Будет выведен только код, но исполнен он не будет.
* **Код выведен не будет, напечатаются все целые числа от 1 до 16.**
* Будет выведен только код, он будет исполнен, но результат не напечатается.

## 3.3 Зоопарк возможностей: форматы, pandoc, html
### 3.3.1 Очередность обработки
Давайте внесем ясность: какой инструмент в какой момент времени работает.

#### Как устроен R Markdown
Что происходит с исходным файлом .Rmd когда мы нажимаем кнопку `Knit`?

* **Исходный файл: .Rmd**
* **`knitr`: .Rmd --> .md** 
    + `knitr` находит чанки кода
    + исполняет их в соответствии с нашими инструкциями
    + собирает результаты исполнения кода на R
    + кладет все это в промежуточный .md-файл 
* **`pandoc`: .md --> .html, .docx, .tex**
    + `pandoc` преобразует Markdown разметку в один из трех форматов
* **`latex`: .tex --> .pdf**
    + `latex` преобразует промежуточный .tex-файл в .pdf-файл

#### YAML header
Как ранее мы уже поняли, R Markdown состоит из нескольких независимых инструментов. Конфигурировать эти инструменты по отдельности необходимо при помощи заголовка.

* В заголовке .Rmd-файла можно указывать различные опции, которые будут конфигурировать каждый из инструментов при последовательной сборке файлов.
* Опции задаются в особом формате (YAML) в виде списка ключей и значений

#### Конфигурация форматов
* Секция `output:` отвечает за формат конечного документа
* Каждый формат имеет собствнные настройки


```{r echo = F, comment = ""}
cat(c("output:",
      "  html_document:",
      "     toc_float: TRUE"),
    sep = "\n")
```

#### Параметры документа
Есть еще одна возможность. Эти параметры, находящиеся в YAML header'е могут быть дополнительно настраиваемы. Т.е. один и тот же исходный файл может быть основой для разнообразных отчетов. Это могут быть различные сценарии обработу данных; какие-то настройки алгоритмов; различные источники данных, которые могут то подключаться, то отключаться и т.д.

* Содержимое документа может зависеть от внешних параметров
* Это могут быть различные сценарии, настройки алгоритмов, имена файлови т.д.

Вот примерно такую запись можно поместить в хэдер:

```{r echo = F, comment = ""}
cat(c("params:",
      "  n: 100",
      "  d: !r Sys.Date()"),
    sep = "\n")
```

* Использование возможно через список `` `params` ``:  `` `r knitr::inline_expr('params$n')` ``

### 3.3.2 Glacier Part 5

### 3.3.3 Задача
Я задумал написать динамический отчёт, в котором будут математические формулы, участки кода на R и элементы markdown. 

В каком порядке расположены этапы получения конечного файла с готовым отчётом?
Порядок следования этапов -- сверху вниз, верхний идёт первым.

#### Решение

* Пишется текст документа со встроенным кодом на R (результат: файл .Rmd)
* Исполняется код на R, встраиваются текст или изображения (результат: файл .md)
* Обрабатываются элементы разметки markdown (результат: файл .html, .tex)
* Компилируются и отображаются элементы LaTeX (результат: файл .html, .pdf)

### 3.3.4 Только для HTML
#### HTML Tags
* Отсюда и далее говорим только об HTML (сборка в pdf остается за скобками)
* При сборке .Rmd разметка markdown заменяется HTML-тегами 
* Но эти теги можно использовать напрямую
* `<u>Подчеркнутый текст</u>`: <u>Подчеркнутый текст</u> (в R Markdown ет подчеркнутого текста)

#### CSS
* CSS -- способ изменять стили отображения элементов, не меняя текст markdown-файла
* Уровень абстракции: разметка отдельно, стили отдельно

Для того, чтобы добавить стилевой файл, нужно воспользоваться конфигурацией в YAML-header'е:
```{r echo = F, comment = ""}
cat(c("output:",
      "  html_document:",
      "    css: style.css"),
    sep = "\n")
```

#### HTML-презентации
* ioslide, slidy, revealjs (+ beamer в pdf)
* Слайды отделяются друг от другна заголовками первого и второго уровней
* Или принудительно, при помощи строки из дефисов:
`----`
* У каждого формата свои удобства для показа, визуального оформления, конфигурации и т.п.

#### ggvis
* HTML хорош тем, что он может быть интерактивым за счет `javascript`
* `ggvis` -- это "web-friendly" наследник `ggplot2`
* Синтаксис очень похож:
```{r eval = F}
library(ggplot2)
ggplot(mtcars, aes(x = wt, y = mpg, color = factor(cyl))) +
  geom_point(size = 5)
```

```{r eval = F}
library(ggvis)
ggplot(mtcars, x = ~wt, y = ~mpg, fill = ~factor(cyl)) %>%
  layer_points(size := 100)
```

### 3.3.5 Glacier Part 6

### 3.3.6 Задача
Судя по тому, как бурно развивается связанная с R Markdown инфраструктура, через каких-то пару лет она сможет варить кофе, гулять с собакой и проектировать космические корабли. Пока этого не случилось, мы будем пользоваться имеющимися возможностями, которых и так очень много. Об этом и тест.

Верно ли, что ...

* **ggvis -- это пакет, схожий с ggplot2, но для интерактивных HTML изображений?**
* можно использовать HTML теги напрямую при сборке pdf?
* **в YAML-заголовке указываются опции конечного формата?**
* оглавление документа и библиографию придётся делать вручную?

### 3.3.7 Задача
В ходе изучения R Markdown мы использовали большое количество аббревиатур, за которыми стоят как широко распространённые, так и узкоспециализированные понятия. Давайте попробуем навести порядок в этих терминах. 

Для этого необходимо сопоставить элементы слева с их определениями справа.

* HTML -- Формат разметки, используемый большинством web-страниц
* YAML -- Формат представления данных в виде вложенных пар ключей и значений
* CSS -- Формат, задающий правила описания и отображения элементов веб-страниц
* Rmd -- Формат исходного файла R Markdown
* LATEX -- Система инструментов для работы с типографией, вёрсткой, математическими формулами
* Knit --Процесс компиляции исходного файла R Markdown в конечный формат
