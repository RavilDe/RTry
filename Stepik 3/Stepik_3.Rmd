---
title: "Анализ данных в R. Часть 2"
author: "Анатолий Карпов, Антон Антонов"
output:
  html_document:
    highlight: tango
    # toc: yes
    # toc_float: yes
  pdf_document: default
header-includes: \usepackage[english, russian]{babel}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(message = F, # отрубаем всякие не шибко нужные сообщения
                      cache = T)   # врубаем сохранение кэша, ибо данные тяжеловаты и долго пересчитываются
library(Hmisc)
```

# 2. Подробнее о визуализации
## 2.1 Грамматика ggplot2, функция qplot
### 2.1.1 План урока
В этом уроке мы:

* познакомимся с основными элементами графической грамматики пакета `ggplot2`;
* научимся пользоваться функцией `qplot` для построения базовых графиков.

### 2.1.2 Теоретические материалы
В этом шаге я бы хотел собрать все теоретические материалы, на которые буду ссылаться в уроках:

* Самый хороший учебник [Cookbook for R](http://www.cookbook-r.com/Graphs/), в котором разобраны наиболее важные вопросы с примерами кода.
* [Документация](http://docs.ggplot2.org/current/) пакета `ggplot2` с примерами кода для построения основных типов графиков.

Различные графические параметры:

* [типы точек](http://sape.inf.usi.ch/quick-reference/ggplot2/shape)
* [типы линий](http://sape.inf.usi.ch/quick-reference/ggplot2/linetype) 
* [цвета](http://sape.inf.usi.ch/quick-reference/ggplot2/colour)

### 2.1.3 Общие вводные слова

### 2.1.4 Основные грамматические конструкции ggplot2
Основная идея пакета заключается в том, что мы можем рассматривать процесс построения графика как последовательный процесс перемещения данных в графический вид, состоящий из нескольких этапов. Каждый этап является "грамматической единицей" построения графиков. Комбинируя эти грамматические единицы мы и получим график. Давайте разберемся что же это за этапы. 

#### Основные принципы (грамматические конструкции) ggplot2:
* **Aestetic attributes** -- определяют какие данные будут на графике и где;
* **Geometric objects** -- определяют, как именно будут отражены данные (линии, точки, столбики и т.д.);
* **Statistical transformation** -- определяют, какие трансформации с данными будут отображены на графике (регрессионаая прямая или сглаживание) -- не обязательно;
* **Scales** -- какие именно значения (и как) будут отображены на графике (шкалы, сетки);
* **Coordinates** -- система координат;
* **Faceting** -- группировка данных (разбивка на фасетки).

В этом  заключается основная идея построения графика. Поэтапное конструирование.

### 2.1.5 Начало работы, qplot
Подгрузим библиотеку `ggplot2`:
```{r}
library(ggplot2)
```

#### Быстрый график qplot -- quick plot
Подгрузим данный `diamonds` из пакетв `ggplot2`:
```{r}
data("diamonds")
```

Начнем с функции `qplot` которая ближе к базовой графике, чем к идеи `ggplot2`. Потому что она позволяет очень быстро нарисовать самые простые взаимосвязи, как бы угадывая за нас что мы хотим от данных. 

Разберем самый простой пример; посмотрим какие аргументы есть в функции. Это `x, y, data`. И построим график, в котором по оси `x` будеть переменная `price`, ну а данные -- `diamonds`. Мы не сказали функции ни при помощи какого geom-а собирались строить график, в каком геометрическом пространстве, ни про какие доп настройки. И такая функция по умолчанию построит гистограмму:
```{r}
qplot(x = price, data = diamonds)
```

Т.е. если на вход `qplot` подать одну количественную переменную, то получится гистограмма.

Теперь добавим `y`. Если на входе две количественные переменные, то выйдет обычная диаграмма рассеивания:
```{r}
qplot(x = price, y = carat, data = diamonds)
```

А теперь отложим по оси `x` фактор (качественную переменную): `cut`. Пакет `ggplot2` не растеряется и отложит по оси `х` группы переменных, объединенных фактором `cut`:
```{r}
qplot(x = cut, y = carat, data = diamonds)
```

Еще одна особенность `qplot`, в качестве минимального аргументьа функции может быть поставлен вектор:
```{r}
v <- diamonds$carat
qplot(v)
```

Вот такой вот минимум настроек функции `qplot`. Видно, что не обязательно прописывать название аргумента, они идут по порядку (TAB'овая подсказка). 

### 2.1.6 Задача
Используя функцию `qplot`, постройте гистограмму переменной `depth` из данных `diamonds`. Сохраните график в переменную `depth_hist`.

#### Решение
```{r}
(depth_hist <- qplot(diamonds$depth))
```

### 2.1.7 Структура переменной графика qplot
Вот эта идея, что можно напрямую обращаться к переменной дата-фрейма, так же распространяется и на диаграмму рассеивания:
```{r}
qplot(diamonds$price, diamonds$carat)
```

При этом функция `qplot` является частью пакета `ggplot2` и обладает большим кол-вом преимуществ над базовой графикой `R`. Это и большее количество настроек и что более важно, возможность сохранять графики в переменные. 

Вот такой код создаст переменную `my_plot`:
```{r}
my_plot <- qplot(qplot(x = price,        # переменная на ось x
                       y = carat,        # переменная на ось y
                       data = diamonds)) # из какого дата-фрейма берем переменные
str(my_plot)
```

Этот список хранит в себе информацию о всех графических элементах составляющих график.

### 2.1.8 Еще пара важных особенностей функции qplot
Давайте разукрасим наш график. Это достигается всего-лишь добавлением одной строчки:
```{r}
qplot(x = price,
      y = carat,
      color = color, # добавляем цвет, через аргумент color
      data = diamonds)
```

Тут появляется некая двойственность записи, название аргумента совпадает со значением переменной :)

Давайте вручную пропишем, каким геометрическим объектом мы хотим отрисовать наши данные:
```{r}
qplot(x = price,
      y = carat,
      color = color, 
      data = diamonds,
      geom = "point") # указываем каким геометрическим объектом отрисовать наши данные
```

У точки есть параметры: размер `size` и форма `shape`:
```{r}
qplot(x = price,
      y = carat,
      color = color,
      shape = cut,     # форма точки - варианты огранки бриллиантов (cut)
      data = diamonds,
      geom = "point")
```

Предыдущий график получился слегка перегруженным, поэтому давайте посмотрим эти характеристики на меньшем дата-фрейме `mtcars`:
```{r}
qplot(mpg,
      hp,
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am), # добавим цвет с помощью переменной am
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl), # изменяем форму точек по кол-ву цилиндров в авто
      data = mtcars)
```

```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl),
      size = I(3),         # изменили размер точки; см справку по ф-ии I()
      data = mtcars)
```

### 2.1.9 Задача
Теперь давайте отобразим сразу три переменные на одном графике! 

Постройте диаграмму рассеивания `scatter plot` как в указанном ниже примере, результат сохраните в переменную `price_carat_clarity_points`.

* данные -- `diamonds`
* ось x -- `carat`
* ось y -- `price`
* цвет точек -- `clarity`

#### Решение
```{r}
(price_carat_clarity_points <- qplot(data = diamonds,
                                    x = carat,
                                    y = price,
                                    color = clarity))
```

### 2.1.10 Продолжаем накачивать qplot
Добавим прозрачности точкам:
```{r}
qplot(mpg,
      hp,
      color = factor(am),
      shape = factor(cyl),
      size = I(5),        # немного увеичил размер точки для наглядности
      alpha = I(0.7),     # изменяем прозрачность точки
      data = mtcars)
```

Вернемся к гистограмме и явно пропишем её `geom`:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram")
```

Изменим цвет и заливку столбиков:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram",
      fill = I("white"),  # заливка
      col = I("black"))   # рамка
```

```{r}
qplot(data = diamonds,
      x = price,
      geom = "histogram",
      fill = color,       # заливка переменной
      col = I("black"))   
```

Немного поменяем способ отображения столбцов изменив `geom`:
```{r}
qplot(data = diamonds,
      x = price,
      geom = "density",  # сменили geom
      fill = color,
      col = I("black"))   
```

```{r}
qplot(data = diamonds,
      x = price,
      geom = "density",
      fill = color,
      alpha = I(0.3),    # добавили прозрачность для наглядности 
      col = I("black"))   
```

#### Примечание
В лекции не сказано, но можно использовать совершенно любые `HEX` цвета, просто записывая их внутри функции `I( )`, что очень удобно :) Например `I('#66cc66')`.

### 2.1.11 Задача
Используя функцию `qplot`, постройте график плотности переменной `x` из данных `diamonds`. Сохраните график в переменную `x_density`.

#### Решение
```{r}
(x_density <- qplot(data = diamonds,
                   x = x,
                   geom = "density"))
```

### 2.1.12 Задача
Усложним задачу, постройте график плотности переменной `x` для каждой группы наблюдений по переменной `cut` из данных `diamonds`. Таким образом за цвет графика теперь отвечает переменная `cut`. Сохраните результат в переменную `x_cut_density`.

#### Решение
```{r}
(x_density <- qplot(data = diamonds,
                   x = x,
                   col = cut,
                   geom = "density"))
```

### 2.1.13 Задача
Давайте знакомиться с различными `geoms`. Документация пакета и весь список с примерами использования доступен [здесь](http://ggplot2.tidyverse.org/reference/). Вообще обратите внимание на документацию `ggplot2`, очень подробное описание основных возможностей пакета!

Давайте построим график `violin plot` для переменной `price` в каждой группе наблюдений по переменной `color`. Сохраните результа в переменную `price_violin`.

#### Решение
```{r}
(price_violin <- qplot(data = diamonds,
                       geom = "violin",
                       y = price,
                       x = color))
```

### 2.1.14 Заключение урока
Бла--бла--бла

## 2.2. Функция ggplot и различные geoms
### 2.2.1 План урока
В этом уроке мы:

* познакомимся поближе с функцией `ggplot`;
* разберем различные примеры `geoms`;
* поговорим подробнее о функции `stat_summary`;

### 2.2.2 Функция ggplot
Функция `ggplot` является самой главной заготовкой нашего графика. И требует на вход данные, которые мы хотим визуализировать; на самом деле этого достаточно:
```{r}
ggplot(diamonds)
```

Появилась некая заготовка графика. Мы пока просто создали холст для графика.

Теперь мы хотим сказать какие переменные будут отображены на графике. Для этого используется функция `aes()`. Давайте построим самый простой график, где по оси `x` будет отложена переменная `price`:
```{r}
ggplot(diamonds, aes(x = price))
```

На холсте появилась шкала значений переменной `price`. Он пустой, т.к. мы ничего не сказали про то, каким образом отобразить данные. Третьим этапом нам необходимо добавить некий геометрический объект или `geom`; это будет новый слой графика:
```{r}
ggplot(diamonds, aes(x = price)) +
  geom_histogram()
```

#### Минимальный набор атрибутов для построения графика:

* `ggplot(diamonds)` -- чистый холст;
* `aes(x = price)` -- какие переменный из diamonds мы хотим показать;
* `geom_histogram` -- каким способом мы это хотим сделать.

#### График с несколькими переменными
```{r}
ggplot(diamonds, aes(price, carat)) # x и y можно опустить
```

Добавим geom с точками:
```{r}
ggplot(diamonds, aes(price, carat)) + 
  geom_point()
```

Основная фишка `ggplot` -- мы не ограничены количеством `geom`'ов
```{r}
ggplot(diamonds, aes(price, carat)) + 
  geom_point() + 
  geom_smooth()
```

Все переменные, которые мы хотим перенести на график, на оси, в цвете, мы должны прописать в `aes`. Причем `aes` мы можем прописать как в заглавной `ggplot` (они будут работать на все `geom`'ы), так и в отдельных `geom`'ах (индивидуално). 
```{r}
ggplot(diamonds) + 
  geom_point(aes(price, carat)) + 
  geom_smooth(aes(price, carat))  # так тоже можно
```

Добавим переменную в `aes` для обозначения цветат точек:
```{r}
ggplot(diamonds, aes(x = price,
                    y = carat,
                    color = cut)) + # добавили переменную для цвета
  geom_point() + 
  geom_smooth()
```

Заметим, что наша переменная `color` разбивает на группы и точки и линии сглаживания. Однако, что делать, если мы хотим сохранить всего одну линию тренда? Нужно перенести переменную отвечающую за цвет только в нужный нам `geom`.
```{r}
ggplot(diamonds, aes(x = price,
                    y = carat)) + 
  geom_point(aes(color = cut)) +    # прописываем цвет только в этом geom'е
  geom_smooth()
```

### 2.2.3 Aesthetics
Поэтому внутри функци `ggplot` мы указываем данные и только те переменны, которые будут общими для всех `geom`'ов. А если хотим изменить что-то лишь для одного `geom`'а то эти изменения нужно прописывать именно в нем:

```{r}
ggplot(diamonds, aes(x = price,
                    y = carat)) + 
  geom_point(aes(color = cut),
             size = 0.5,      # размер точки; без I()
             alpha = .3) +    # прохрачность; без I(); десятичную дробь можно писать без нуля
  geom_smooth(size = 2,
              color = "red")
```

Настройки прописанные внутри одного `geom`'а никак не переходят на другой `geom`.

### 2.2.4 Набор данных airquality
Давайте посмотрим на данные `airquality`:
```{r}
str(airquality)
```

```{r}
library(dplyr)
glimpse(airquality) # этакий расширенный str() из пакета tibble
```

Для каждого месяца есть показатель температуры, давайте создадим новый дата-фрейм, в котором данные будут сгруппированы по месяцам, а затем схлопнем эти данные со средней температурой и средней скорости ветра:
```{r}
gr_airquality <- group_by(airquality, Month)
(t <- summarise(gr_airquality, 
                mean_temp = mean(Temp),
                mean_wind = mean(Wind)))
```

А теперь нарисуем график:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_point(aes(size = mean_wind)) + # размер точек вынесен отдельно
  geom_line()                         # линии для соединения точек
```

Линия показывает некий тренд температуры, а размер точек скорость ветра.

```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_point(aes(size = mean_wind),
             color = "red") + # покарсим точки в красный
  geom_line()
```

Наблюдаем нахлест линий на точки. Как это исправить? Просто поменять порядок `geom`'ов:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_line() +                      # поставили его первым
  geom_point(aes(size = mean_wind),
             color = "red")          # точки закроют линии
```

Есть такие `geom`'ы, котрые не зависят от `aes()` прописанных в `ggplot()`. Предположим, что мы хотим добавить на график горизонтальную линию на уровне $75$:
```{r}
ggplot(t, aes(Month, mean_temp)) +
  geom_line() +
  geom_point(aes(size = mean_wind),
             color = "red") +
  geom_hline(yintercept = 75,
             linetype = "dotted", 
             size = 1.2,
             color = "blue")      # эта линия не зависит от aes(Month, mean_temp); ну кроме границ
```

### 2.2.5 Рассмотрим geom_errorbar и geom_pointrange
Посмотрим описание `?geom_errorbar`. `Geom` ожидает от нас две переменные `ymax` и `ymin`, которые и будут означать минимальную и максимальную грпницу ошибки. `geom_errorbar` требует небольшой подготовки данных, а именно нужна группирующая переменная. `geom_pointrange` еще и среднюю точку нарисует.

Для начала сгруппируем и преобразуем данные:
```{r}
gr_mtcars <- group_by(mtcars, am)
(se_data <- summarise(gr_mtcars,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),  # вехняя граница ошибки
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg)))) # нижняя граница ошибки
```
А теперь нарисуем все это:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_errorbar(aes(ymin = y_min, 
                    ymax = y_max)) # здесь необходим aes, чтобы подтянуть данные из дата-фрейма
```

Изменим ширину и добавим средние точки:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) + # уменьшим ширину границ 
  geom_point(size = 3,        # размер
             shape = 21,      # форма точки
             fill = "white")  # цвет заливки
```

А теперь все то же самое, только `geom_pointrange`:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max))
```

Поколдуем над настройками:
```{r}
ggplot(se_data, aes(x = factor(am), y = mean_mpg)) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max),
                  color = "red")
```

Добавим в изначальный дата-фрейм еще одну группировку:
```{r}
gr_mtcars_2 <- group_by(mtcars, am, vs)     # добавили vs
(se_data_2 <- summarise(gr_mtcars_2,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),  # вехняя граница ошибки
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg)))) # нижняя граница ошибки
```

Теперь у нас четыре группы данных. Нарисуем их:
```{r}
ggplot(se_data_2, aes(x = factor(am), y = mean_mpg)) +           # заменили se_data_2
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Но пока не понятно, где на этом графике переменная `vs`. Давайте добавим ее в `aes()` в качестве цвета:
```{r}
ggplot(se_data_2, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(vs))) +                     # теперь vs будет отображена цветом
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Не хватает линии соединяющей точки. Для ее построения необходимо в `aes` прописать группировку по переменной; в данном случае она совпадает с переменной цвета `vs`:
```{r}
ggplot(se_data_2, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(vs),
                      group = factor(vs))) +                    # группируем по цвету
  geom_line() +                                                 # добавляем линии связи
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Если бы мы группировали по большему числу значений переменных (возьмем `cyl`), то ничего не поменялось бы:
```{r}
gr_mtcars_3 <- group_by(mtcars, am, cyl)     # поменяли vs на cyl
(se_data_3 <- summarise(gr_mtcars_3,
                     mean_mpg = mean(mpg),
                     y_max = mean(mpg) + 1.96 * sd(mpg) / sqrt(length(mpg)),
                     y_min = mean(mpg) - 1.96 * sd(mpg) / sqrt(length(mpg))))
```

```{r}
ggplot(se_data_3, aes(x = factor(am), 
                      y = mean_mpg, 
                      color = factor(cyl),      # поменяли vs на cyl
                      group = factor(cyl))) +   # поменяли vs на cyl
  geom_line() +
  geom_errorbar(aes(ymin = y_min, ymax = y_max), width = 0.3) +
  geom_point(size = 3,
             shape = 21,
             fill = "white")
```

Попробуем этот же дата-фрейм с `geom_pointrange`:
```{r}
ggplot(se_data_3, aes(x = factor(am),
                    y = mean_mpg,
                    color = factor(cyl),
                    group = factor(cyl))) +
  geom_pointrange(aes(ymin = y_min, ymax = y_max)) +
  geom_line()  # тут порядок линий и точек не важен
```

### 2.2.6 Статистические трансформации внутри ggplot
А что если предобработку запихнуть внутрь `ggplot`?

Для начала просто отрисуем необходимые данные: 
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  geom_point()
```

Заменим `geom_point` на `stat_summary` и получим полный аналог `geom_pointrange`, но без предобработки:
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary()                       # тут пока еще чего-то не хватает :)
```

Функция `mean_cl_boot` (на ее вход подается вектор) возвращает данные, необходимые для построения доверительного интервала (`y` -- среднее, `ymin` -- минимум и `ymax` -- максимум) при помощи `bootstrap`'а.
```{r}
mean_cl_boot(mtcars$mpg)
```

Эти результаты вычислений мы помещаем как аргументы `stat_summary`; эта функция по-умолчанию работает с `y`. 
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary(fun.data = mean_cl_boot) # в ф-ию mean_cl_boot попадают данный по y 
```

Внутри `stat_summary` можно прописать нужный нам `geom` (`point` идет по-умолчанию):
```{r}
ggplot(mtcars, aes(factor(am), mpg)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",       # поменяли geom
               width = 0.3) +           # немного сжали усы
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point", # добавили средние точки
               size = 2)
```

Добавим разбивку по `vs`:
```{r}
ggplot(mtcars, aes(factor(am), mpg, col = factor(vs))) + # добавили цвет vs-ом
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2)
```

Соединим теперь средние точки линией. Нужно соединить только средние значения:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(vs), 
                   group = factor(vs))) + # добавили группирующую переменную
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "line") # предыдующая команда, только geom - линия
```

Последнюю команду, соединяющуюу линиями средние точки можно немног оупростить:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(vs), 
                   group = factor(vs))) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,   # в fun.y передаем среднее значение и соединяем линией
               geom = "line")
```

Измения группирующую (она же цветовая) переменную:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),       # поменяли vs на cyl
                   group = factor(cyl))) +  # поменяли vs на cyl
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = mean_cl_boot, 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,
               geom = "line")
```

Плюсом такого метода является отсутствие предобработки данных; все вычисления на себя берет `ggplot`. А так же можно использовать какую-то свою функцию вместо `mean_cl_boot`. Вот такую например:
```{r}
# данная ф-ия рассчитывает среднее значение +/- стандартное отклонение
sd_error <- function(x){
  c(y = mean(x),
    ymin = mean(x) - sd(x),
    ymax = mean(x) + sd(x))
}
```

Подставим эту функцию в предыдущую выкладку:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),
                   group = factor(cyl))) +
  stat_summary(fun.data = sd_error,
               geom = "errorbar",
               width = 0.3) +
  stat_summary(fun.data = sd_error,    # подставили сюда свою функцию 
               geom = "point",
               size = 2) +
  stat_summary(fun.y = mean,
               geom = "line")
```

Зеленый график наехал на синий -- решаемо:
```{r}
ggplot(mtcars, aes(factor(am), mpg, 
                   col = factor(cyl),
                   group = factor(cyl))) +
  stat_summary(fun.data = sd_error,
               geom = "errorbar",
               width = 0.3,
               position = position_dodge(0.2)) +  # сдвиг
  stat_summary(fun.data = sd_error,
               geom = "point",
               size = 2,
               position = position_dodge(0.2)) +  # сдвиг
  stat_summary(fun.y = mean,
               geom = "line",
               position = position_dodge(0.2))    # сдвиг
```

### 2.2.7 Задача
Давайте потренируемся комбинировать различные geoms на одном графике. Используя данные `mtcars` скомбинируем два варианта отображения количественных данных `boxplot` и `violin plot`.

* ось x -- `am` (нужен фактор)
* ось y -- `mpg`

Сохраните график в переменную `my_plot`.

Обратите внимание, я сделал `boxplot` чуть уже, чтобы ящики полностью оказались внутри `violin plot`: `geom_boxplot(width = 0.2)`

#### Решение
```{r}
ggplot(mtcars, aes(factor(am), mpg)) + 
  geom_violin() +
  geom_boxplot(width = 0.2)
```

### 2.2.8 Условие задачи
Для закрепления результатов поработаем с [вымышленными данными](https://stepic.org/media/attachments/course/724/sales.csv) о доходах в нескольких магазинах:

```{r}
sales = read.csv("https://stepic.org/media/attachments/course/724/sales.csv",
                 encoding =  "UTF-8")
str(sales)
```

* sale -- число проданных товаров
* shop -- номер магазина
* date -- год, за который велась статистика
* season -- время года
* income -- доход магазина

### 2.2.9 Задача
Отобразите взаимосвязь между доходом `income` и числом продаж `sale`, цветом точек указав номер магазина `shop`. Сохраните график в переменную `my_plot`. Обратите внимание, что линия тренда одна для всех наблюдений. Данные хранятся в переменной `sales`.

#### Решение
```{r}
(my_plot <- ggplot(sales, aes(income, sale)) +
  geom_point(aes(color = shop)) +
  geom_smooth()
 )
```

### 2.2.10 Задача
При помощи функции `stat_summary` постройте график с доверительными интервалами для демонстрации различий в доходах двух магазинов с учетом времени года:

* переменная `shop` -- ось x;
* переменная `income` -- ось y;
* переменная `season` -- цвет;
* geom pointrange.

Сохраните график в переменную `my_plot`, дополнив предложенный код. Обратите внимание, что доверительные интервалы не накладываются друг на друга! 

#### Решение
```{r}
(my_plot <- ggplot(sales, aes(shop, income, color = season)) +
   stat_summary(fun.data = mean_cl_boot,
                # geom = "pointrange",     # эту команду можно не писать, она по-умолчанию стоит
                position = position_dodge(0.2))
)
```

### 2.2.11 Задача
Теперь давайте отобразим на графике различия в продажах (переменная `sale`), в зависимости от:

* года (date) -- ось x;
* и номера магазина (shop) -- цвет.

Дополните предложенный код, чтобы получился график как в примере ниже. Используйте функцию `mean_cl_boot` для построения доверительных интервалов.Вам также понадобится использовать три `geoms`: `errorbar`, `point`, `line`. Используйте их прямо внутри функции `stat_summary()`. 

#### Решение
```{r}
ggplot(sales, aes(date, sale, color = shop, group = shop)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "errorbar",
               position = position_dodge(0.2)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "point",
               position = position_dodge(0.2)) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "line",
               position = position_dodge(0.2))
```

## 2.3 Facet -- способы группировки данных на графике
### 2.3.1 План урока
В этом уроке мы:

* научимся разбивать график на несколько подграфиков;
* узнаем в чем разница между `facet_grid()` и `facet_wrap()`;
* Поговорим о кино!

### 2.3.2 Вводные слова

### 2.3.3 Facet-grid
Пакет, а точнее функция `ggplot` позволяет поместить в график очень много информации. Он к этому располагает :)
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(am), size = disp,
       shape = factor(cyl))) +
  geom_point()
```

Но зачастую не стоит злоупотреблять этой возможностью. Рано или поздно график станет очень перегруженным и какие-то важные взаимосвязи будет трудно наблюдать. Поэтому если мы хотим показать некий эффект на разных уровнях какого-либо фактора, то нужно использовать `facet`.

`facet` -- это разбивка нашего графика на несколько подграфиков по какой-либо переменной. Есть несколько видов фасета, давайте посмотрим на наиболее типичные из них.

Пример графика с большим кол-вом уровней фактора:
```{r}
ggplot(diamonds, aes(carat, fill = color)) +
  geom_density()
```

Даже если добавить прозрачность `alpha=0.2`, то все равно график очень перегружен и хорошо понять распределение пременных очень тяжело. Поэтому в таких случаях лучше использовать `facet`. 

`facet-grid()` разбивает график на группы в виде матрицы. Можно задействовать сразу несколько переменных. 
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(color ~ cut) # разбивка по двум переменным
```

Если нам нужно разбить данные только по одному фактору, то вместо второго ставим просто точку:
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(. ~ cut) # в качестве столбцов
```

```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_grid(cut ~ .) # в качестве строк
```

### 2.3.4 Facet-grid продолжение
Воспользуемся более маленьким набором данных `mtcars`, чтобы посмотреть еще одну особенность `facet-grid()`. Только для начала преобразуем две переменные в факторы:
```{r}
mtcars <- mutate(mtcars,
                 am = factor(am, labels = c("A", "M")),
                 vs = factor(vs, labels = c("V", "S")))
ggplot(mtcars, aes(hp)) +
  geom_dotplot() +
  facet_grid(am ~ vs, margins = T) # margins - добавляет сумму по строкам и столбцам
```

Добавим в эстетику еще одну переменную:
```{r}
ggplot(mtcars, aes(hp, mpg)) +            # добавили mpg 
  geom_point(aes(color = factor(cyl))) +  # поменяли geom и добавили цвет
  facet_grid(am ~ vs, margins = T)
```

Уберем из фасета одну переменную и добавим сглаживание:
```{r}
ggplot(mtcars, aes(hp, mpg)) +
  geom_point(aes(color = factor(cyl))) +
  facet_grid(. ~ am) +
  geom_smooth(method = "lm")
```

### 2.3.5 Facet-wrap
Основная идея `facet-grid()` -- разбить график на несколько подграфиков в виде матрицы. 

В `facet-wrap` мы строим несколько независимых графиков подряд, с перебором всех факторв.
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap(~ color + cut) # всегда начинается с тильды, а дальше просто перечисляем факторы
```

Нет деления на столбики и столбцы, на каждом графике есть свое название. Так же здесь очень легко задавать форму вывода графика -- можно задавать число столбиков и столбцов.
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap(~ color + cut, nrow = 5) # кол-во строк 
```

Для фасета достаточно одной факторной переменной:
```{r}
ggplot(diamonds, aes(carat)) +
  geom_density() +
  facet_wrap( ~ cut)          # оставили всего одну переменную 
```

#### Без фасета
```{r}
ggplot(diamonds, aes(carat, price, col = color)) +
  geom_smooth()
```

#### Фасет спешит на помощь!
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_smooth() +
  facet_wrap(~ color) # просто переместили переменную из эстетики в фасет
```

```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_smooth() +
  facet_grid(color ~ .) # просто переместили переменную из эстетики в фасет
```

### 2.3.6 Заключительные слова
Совет: три переменный, это максимум для одного графика. А в фасет можно закинуть сразу два фактора.

### 2.3.7 Задача
Потренируемся с разбиением графика на подгруппы! Используя `facet_grid()` постройте следующий график и сохраните его в переменную `mpg_facet`.

* ось `x` -- переменная mpg
* `facet` -- переменная `am` по строчкам и `vs` по столбцам

#### Решение
```{r}
(mpg_facet <- ggplot(mtcars, aes(mpg)) +
  geom_dotplot() +
  facet_grid(am ~ vs)
 )
```

### 2.3.8 Задача
Используя данные `iris`, постройте график плотности для переменной `Sepal.Length`. Разбейте график на части по переменной `Species` при помощи `facet_wrap`. Результат сохраните в переменную `sl_wrap`.

#### Решение
```{r}
(sl_wrap <- ggplot(iris, aes(Sepal.Length)) +
  geom_density() +
  facet_wrap(~ Species)
 )
```

### 2.3.9 Задача
Используя данные `iris`, постройте график, иллюстрирующий взаимосвязь переменных `Sepal.Length` и `Sepal.Width` внутри каждого вида (переменной `Species`), при помощи `facet_wrap()`.

В этом задании вам потребуется использовать два `geom`:

* `geom_point` -- для отображения отдельных наблюдений,
* `geom_smooth` -- для добавления сглаживания.

Сохраните график в переменную `my_plot`.

#### Решение
```{r}
(my_plot <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
   geom_point() +
   geom_smooth() +
   facet_wrap(~ Species)
  
)
```

### 2.3.10 Задача
«Отряд самоубийц» уже посмотрели? Пишите в комментариях, как вам! У меня вот смешанные чувства вызвала эта команда суперзлодеев. Собрали самых интересных персонажей вселенной и отправили их в одну локацию весь фильм ходить , перебрасываясь односложными фразами. Джокера совсем не показали, все так ждали Джареда Лето в этой роли, а он появился, считайте, в двух эпизодах! К чему это я? Поговорим о кино!

Вы можете скачать данные myMovieData (жмите на [ссылку](https://stepik.org/media/attachments/course/724/myMovieData.csv)), в которых представлена различная информация о голливудских фильмах с 2002 по 2005: тип жанр, бюджет и год выхода на экраны. Давайте построим следующий график, чтобы выяснить есть ли различия в бюджетах фильмов разного жанра из года в год. Cохраните результат в переменную `my_plot`.

* ось `x` -- переменная `Type`
* ocь `y` -- переменная `Budget`
* `facet` -- переменная `Year` (используйте `facet_grid`)

В примере графика я отобразил название жанров вертикально, чтобы все уместилось на графике и не перекрывалось. В коде, который вы отправляете на проверку, это необязательно, но вот как это можно было бы сделать:

`ggplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1))`

Про настройку таких моментов мы поговорим далее.

#### Решение
```{r}
myMovieData <- read.csv("https://stepik.org/media/attachments/course/724/myMovieData.csv")
# glimpse(myMovieData)
ggplot(myMovieData, aes(Type, Budget)) +
  geom_boxplot() +
  facet_wrap(~ Year) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

## 2.4 Scale и Theme: оси, легенда, внешний вид графика
### 2.4.1 План урока
В этом уроке мы:

* поработаем с настройками `scales`;
* научимся видоизменять внешний вид графика.

```{r, echo = F}
data(mtcars) # заново подгружаем датасет, т.к. ранее мы его немного изменили
```


### 2.4.2 Функция scale
При помощи функции sсale мы получаем контроль над значениями на осях и в легенде. На графике ниже каждая точка имеет три значения: по `x`, по `y` и цвет:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point()
```

Начнем с оси `x`. Подберем из огромного списка функций начинающихся на scale именну ту, которая контролирует ось x: `scale_x_continuous` т.к. переменная у нас континуальная:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",         # подпись x*
                     breaks = c(10, 20, 30, 31, 32, 33)) # вектор из последовательности делений
```

Если нужно поменть на оси только название, то есть более быстрый способ это сделать с помощью `xlab`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  xlab("Miles/(US) gallon")        # точечная смена имени оси х
```

Но если на оси x нужно менять больше одного параметра, то лучше сразу заносить все изменения под `scale_x_continuous`.

Поиграем с делениями шкалы:
```{r}
seq_x <- round(seq(min(mtcars$mpg),
                   max(mtcars$mpg),
                   length.out = 15))               # переменная для делений шкалы

ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = seq_x)
```

### 2.4.3 Функция scale. Продолжение.
Занесем переменную внутрь `ggplot`'а:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)))  # НО единица не входит в диапазон данных (
```

Но у нас ничего не вышло, шкала НЕ начинается единицы. Необходимо задать лимиты `limits`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35))             # укажем лимиты явно
```

Короткая запись для лимитов:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  xlab("Miles/(US) gallon") +
  xlim(c(1, 35))               # прямая функция для смены лимитов шкалы
```

Отступы в графике от крафних данных -- `expand`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(expand = c(1, 1))
```

Сузим пространство графика еще сильнее:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(expand = c(2, 2))
```

Все то же самое справедливо и для оси `Y`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35)) +
  scale_y_continuous(limits = c(50, 400))          # поднимем слегка график   
```

### 2.4.4 Меняем scale по цвету, заливке, размеру и виду точек
#### Настройка легенды переменной "цвета" -- scale_color
Вот мы и добрались до нашей третьей переменной, до цвета. За цвет отвечает `scale_color`, а дальше в зависимости от переменной; если она дискретная (фактор), то это будет функция `scale_color_discrete`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35)) +
  scale_y_continuous(limits = c(50, 400)) +
  scale_color_discrete(name = "Transmission")         # поменяли имя легенды
```

Поменяем названия внутри легенды:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35)) +
  scale_y_continuous(limits = c(50, 400)) +
  scale_color_discrete(name = "Transmission",
                       labels = c("Auto", "Manual"))
```

**Очень полезная возможность, не нужно менять сами данные, ради двух подписей на графике!!!**

Давайте теперь вручную выберем цвета легенды с помощью функции `scale_color_manual`:
```{r}
ggplot(mtcars, aes(mpg, hp, col = factor(am))) +
  geom_point() +
  scale_x_continuous(name = "Miles/(US) gallon",
                     breaks = c(1, seq(10, 35, 5)),
                     limits = c(1, 35)) +
  scale_y_continuous(limits = c(50, 400)) +
  scale_color_manual(values = c("Red", "Blue"),
                       name = "Transmission",
                       labels = c("Auto", "Manual"))
```

#### Настройка легенды переменной "заливки" -- scale_fill
Рассмотрим пример с одной переменной на графике, чтобы явно показать настройку легенды при заливке цветом: 
```{r}
ggplot(mtcars, aes(hp, fill = factor(am))) + # фактор на заливке
  geom_density(alpha = 0.3) +
  scale_fill_discrete(name = "Transmission") # дискретная, т.к. у нас фактор отвечает за заливку
```

```{r}
ggplot(mtcars, aes(hp, fill = factor(am))) +
  geom_density(alpha = 0.3) +
  scale_fill_manual(name = "Transmission",
                    values = c("Red", "Green"))
```

#### Настройка легенды переменной "размера" -- scale_size
Рассмотрим пример с непрерывной переменной в качестве размера точки:
```{r}
ggplot(mtcars, aes(hp, mpg, size = disp)) +
  geom_point(alpha = 0.7)     # много наложений точек; прозрачность улучшает читаемость
```

Чтобы изменить легенду переменной отвечающий за размер точки, необходима функция `scale_size_continuaus`:
```{r}
ggplot(mtcars, aes(hp, mpg, size = disp)) +
  geom_point(alpha = 0.7) +
  scale_size_continuous(name = "Объем движка",      # меняем название легенды
                        breaks = seq(100, 400, 40)) # увеличим градацию в легенде
```


#### Настройка легенды переменной "формы точки" -- scale_shape
Добавим в график еще одну переменную, отвечающую за форму точки:
```{r}
ggplot(mtcars, aes(hp, mpg, size = disp, shape = factor(vs))) +
  geom_point(alpha = 0.7) +
  scale_size_continuous(name = "Объем движка",
                        breaks = seq(100, 400, 40))
```

Теперь чтобы настроить легенду формы нужна функция `scale_shape`:
```{r}
ggplot(mtcars, aes(hp, mpg, size = disp, shape = factor(vs))) +
  geom_point(alpha = 0.7) +
  scale_size_continuous(name = "Объем движка",
                        breaks = seq(100, 400, 40)) +
  scale_shape_discrete(name = "Форма движка",         # discrete т.к. перменная факторная
                       labels = c("V", "рядный"))
```

#### Еще пример
Рассмотрим пример с факторной (качественной) переменной на оси **X** и континуальной (количественной) на оси **Y**. Для изменения подписи под осью для факторных переменных необходима функция `scale_x_discrete`:
```{r}
ggplot(mtcars, aes(factor(am), hp)) +
  geom_boxplot() +
  scale_y_continuous(name = "Мощность, лс") +    # вектор
  scale_x_discrete(name = "Трансмиссия",         # фактор
                   labels = c("Авто",
                              "Ручная"))
```

### 2.4.5 Промежуточные итоги
бла-бла-бла

### 2.4.6 Задача
В этом задании мы построим график используя данные Iris. Наша цель отобразить взаимосвязь переменных Sepal.Length (ось X) и Petal.Length (ось Y) внутри трех групп по переменной Species. Для этого постройте `scaterplot`, отобразите цветом значения переменной Species и добавьте линейное сглаживание в каждой группе.

Далее от вас потребуется привести график к более завершенному виду. Мы переведем на русский название осей, название легенды и ее расшифровку:

* Ось X -- "Длина чашелистика".
* Ось Y -- "Длина лепестка".
* Название легенды -- "Вид цветка".
* Расшифровка легенды: "Ирис щетинистый", "Ирис разноцветный", "Ирис виргинский".

Также мы чуть измени отображение значений по осям. 

* Значения по оси X должны начинаться с 4 и заканчиваться на 8 с шагом в единицу.
* Значения по оси Y должны начинаться с 1 и заканчиваться на 7 с шагом в единицу.

#### Решение
```{r}
ggplot(iris, aes(Sepal.Length, Petal.Length, color = Species)) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_continuous(name = "Длина чашелистика",
                     breaks = seq(4, 8, 1),
                     limits = c(4, 8)) +
  scale_y_continuous(name = "Длина лепестка",
                     breaks = seq(1, 7, 1),
                     limits = c(1, 7)) +
  scale_color_discrete(name = "Вид цветка",
                       labels = c("Ирис щетинистый",
                                  "Ирис разноцветный",
                                  "Ирис виргинский"))
```

### 2.4.7 scale_fill_brewer
В описании к функции `scale_fill_brewer` есть ссылка на замечательный сайт [http://colorbrewer2.org/](http://colorbrewer2.org/), этот сайт поможет нам сформировать палитру цветов для нашего графика.

#### До
Ну, поехали! Сначала отрисуем график без дополнительных вмешательств:
```{r}
ggplot(mtcars, aes(factor(am), hp, fill = factor(cyl))) +
  geom_boxplot()
```

#### После
А теперь откроем страничку [http://colorbrewer2.org/](http://colorbrewer2.org/) и подберем следующие параметры:

* **Number of data classes** -- 3
* **Nature of your data** -- qualitative
* **Pick a color scheme** -- 2

Остальное не трогаем. Теперь пропишем парамеры `qualitative` и номер **второй** палитры для количества переменных равным **трем**:
```{r}
ggplot(mtcars, aes(factor(am), hp, fill = factor(cyl))) +  # три переменных
  geom_boxplot() +
  scale_fill_brewer(type = "qual",       # "Nature of your data"" из colorbrewer (“div”, “qual”, “seq”)
                    palette = 2)         # номер палитры (color scheme) из "Pick a color scheme""
```

#### Пример с scale_color_brewer
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  scale_color_brewer(type = "qual",
                     palette = 6) +
  theme_bw()
```

### 2.4.8 Продолжаем работать с функцией theme
Для начала поизучеем справку по функции`theme`. Офигеваем от кол-ва настроек.

#### Классическая тема
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  scale_color_brewer(type = "qual",
                     palette = 6) +
  theme_classic()                    # убирает линии штриховки и фон 
```

#### Темная тема
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  scale_color_brewer(type = "qual",
                     palette = 6) +
  theme_dark()                    # немного затемнимся
```

### 2.4.9 Пакет ggthemes
Существует много сторонних пакетов с различными `themes`. Установим один из таких под названием `ggthemes`
```{r}
library(ggthemes)
```

Cправка по этому пакету находится на [GitHub'е](https://github.com/jrnold/ggthemes).

Переберем несколько тем:
#### ggthemes: theme_economist
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  theme_economist()
```

#### ggthemes: theme_solarized
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  theme_solarized()
```

#### ggthemes: theme_stata
```{r}
ggplot(mtcars, aes(hp, mpg, col = factor(cyl))) +
  geom_point(size = 4) +
  theme_stata()
```

## 2.5 Пример решения практическоой задачи
### 2.5.1 План урока
В этом уроке:

* мы поэтапно разберем построение графика с нуля до итогового результата, когда график можно вставлять в отчет или в презентацию.

### 2.5.2 Постройка базового графика
Подгрузим датасет  который мы хотим визуализировать:
```{r}
d <- read.csv("https://stepic.org/media/attachments/course/724/example_data.csv")
glimpse(d)
```
#### Базовый график
Отрисуем базу нашего графика -- данные **d** и настройки мэппинга, а именно:

* ось X -- date
* ось Y -- percent
* color -- system
* group -- system (для отрисовки линий)
```{r}
ggplot(d, aes(date, percent, color = system,
              group = system)) +  # группируем для geom_line
  geom_point() +
  geom_line()                     # geom_line соединяет все точки в каждой группе
```

#### Добавим вертикальную линию -- geom_vline
Вспомним, что у фактора в `R` есть уровни `levels`:
```{r}
d$date
```
Каждый уровень фактора закодирован целым числом:
```{r}
str(d$date)
```

Поэтому на нашем графике **Now** это **8**, а **2011** это **7**. И чтобы нарисовать линию между 7 и 8 делениями фактора, нужно просто присвоить аргументу `xintercept` значение **7.5**:
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = 7.5)     # линия ровно между 7-м и 8-м уровнем фактора
```

#### Меняем точки
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_line() +
  geom_point(shape = 21,         # форма точки
             size = 5,           # ее размер
             stroke = 1.5) +     # толщина обводки
  geom_vline(xintercept = 7.5)
```

#### Меняем цвет линий графика
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_color_manual(values = c("springgreen2",
                                "cyan",
                                "red",
                                "yellow1",
                                "orangered1"))
```

#### Убираем задний фон
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  theme_classic()
```

### 2.5.3 Продолжаем изменять график
#### Меняем надписи на шкале Y
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),        # добавили отметку 0.15
                     limits = c(0, .15)) +                     # добавили лимиты (0, 0.15)   
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  theme_classic()
```

#### Меняем десятичную шкалу на процентную
В пакете `scales` есть чудесная функция `percent` изменяющая аргумент на процент:
```{r}
scales::percent(0.4)
```

Пропишем его в качестве аргумента к функции `labels`:
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +                # превращаем десятичную шкалу в процентную
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  theme_classic()
```

#### Убираем подписи осей
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  xlab("") +      # просто пустые строки вместо значений
  ylab("") +      # просто пустые строки вместо значений
  theme_classic()
```

#### Перемещаем легенду вверх
Сохраним наш график в переменную и просто будем прибавлять к нму наши будущие изменения:
```{r}
p <- ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_point(shape = 21, size = 5, stroke = 1.5) +
  geom_line() +
  geom_vline(xintercept = 7.5) +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  xlab("") +
  ylab("") +
  theme_classic()
```

Убиреаем подпись легенды:
```{r}
p + theme(legend.title = element_blank()) # отрисовка пустого объекта
```

Перенос легенды:
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top") # перенос легенды наверх
```

#### Заливка фона графика
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          plot.background = element_rect(color = "black",  # окантовка
                                         fill = "black"))  # весь задний фон графика 
```

#### Цвет шрифта
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          plot.background = element_rect(color = "black",
                                         fill = "black"),
          text = element_text(color = "white"))           # цвет шрифта только в легенде
```

#### Цвет фона самого графика
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          plot.background = element_rect(color = "black",
                                         fill = "black"),
          panel.background = element_rect(fill = "black"),   # вроде хватает одного fill
          text = element_text(color = "white"))
```

#### Фон легенды
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          legend.background = element_rect(fill = "black"),
          plot.background = element_rect(color = "black", fill = "black"),
          panel.background = element_rect(fill = "black"),     # затемняем фон легенды
          text = element_text(color = "white"))
```

#### 2.5.4 Продолжаем-с
Для начала занесем наши изменения темы графика в отдельную переменную:
```{r}
my_theme <- theme(legend.title = element_blank(),
          legend.position = "top",
          legend.background = element_rect(fill = "black"),
          plot.background = element_rect(color = "black", fill = "black"),
          panel.background = element_rect(fill = "black"),
          text = element_text(color = "white"))
```

#### А теперь поправим точки и вертикальную линию:
```{r}
p <- ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_line(size = 1.3) +           # переместили вверх, и утолщили
  geom_point(shape = 21, size = 4, stroke = 1.5,  # чутка уменьшили
             fill = "black") +      # залили черным
  geom_vline(xintercept = 7.5,
             color = "white",       # побелили 
             linetype = "dotted") + # точечки
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red",
                                "yellow1", "orangered1")) +
  xlab("") +
  ylab("") +
  theme_classic()
p + my_theme
```

#### Наносим гроизонтальные линии на фоне
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          legend.background = element_rect(fill = "black"),
          plot.background = element_rect(color = "black", fill = "black"),
          panel.background = element_rect(fill = "black"),
          text = element_text(color = "white"),
          panel.grid.major.y = element_line(color = "gray50",       # цвет горизонтальных линий
                                            linetype = "longdash")) # длинные тире
```

#### Подписи шкал и легенды
```{r}
p + theme(legend.title = element_blank(),
          legend.position = "top",
          legend.background = element_rect(fill = "black"),
          plot.background = element_rect(color = "black", fill = "black"),
          panel.background = element_rect(fill = "black"),
          text = element_text(color = "white"),
          panel.grid.major.y = element_line(color = "gray50", linetype = "longdash"),
          axis.text.x = element_text(face = "bold", size = 12, color = "white"),  # подписи x 
          axis.text.y = element_text(face = "bold", size = 12, color = "white"),  # подписи y
          legend.text = element_text(size = 12, color = "white"))                 # текст легенды
```

#### Заголовок и подписи внизу
```{r}
ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_line(size = 1.3) +
  geom_point(shape = 21, size = 4, stroke = 1.5, fill = "black") +
  geom_vline(xintercept = 7.5, color = "white", linetype = "dotted") +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red", "yellow1", "orangered1")) +
  xlab("") +
  ylab("") +
  ggtitle("Top 5 Linux distributions (% of total per year)") +               # название прописываем тут
  theme_classic() +
  theme(legend.title = element_blank(),
        legend.position = "top",
        legend.background = element_rect(fill = "black"),
        plot.background = element_rect(color = "black", fill = "black"),
        panel.background = element_rect(fill = "black"),
        text = element_text(color = "white"),
        panel.grid.major.y = element_line(color = "gray50", linetype = "longdash"),
        axis.text.x = element_text(face = "bold", size = 12, color = "white"),
        axis.text.y = element_text(face = "bold", size = 12, color = "white"),
        legend.text = element_text(size = 12, color = "white"),
        plot.title = element_text(face = "bold", size = 17, hjust = 0.5))    # отцентровали титульник
```

### 2.5.5 Перенос команд в переменную
Все эти настройки графика можно переннести в меременную и использовать когда появится необходимость.
```{r}
p <- ggplot(d, aes(date, percent, color = system, group = system)) +
  geom_line(size = 1.3) +
  geom_point(shape = 21, size = 4, stroke = 1.5, fill = "black") +
  geom_vline(xintercept = 7.5, color = "white", linetype = "dotted") +
  scale_y_continuous(breaks = c(0, .04, .08, .11, .15),
                     limits = c(0, .15),
                     labels = scales::percent) +
  scale_color_manual(values = c("springgreen2", "cyan", "red", "yellow1", "orangered1")) +
  xlab("") +
  ylab("") +
  ggtitle("Top 5 Linux distributions (% of total per year)") +
  theme_classic()

my_theme <- theme(legend.title = element_blank(),
        legend.position = "top",
        legend.background = element_rect(fill = "black"),
        plot.background = element_rect(color = "black", fill = "black"),
        panel.background = element_rect(fill = "black"),
        text = element_text(color = "white"),
        panel.grid.major.y = element_line(color = "gray50", linetype = "longdash"),
        axis.text.x = element_text(face = "bold", size = 12, color = "white"),
        axis.text.y = element_text(face = "bold", size = 12, color = "white"),
        legend.text = element_text(size = 12, color = "white"),
        plot.title = element_text(face = "bold", size = 17, hjust = 0.5))
p + my_theme
```

### 2.5.6 Финалочка
При помощи отдельного пакета мы добавляем надписи на графике:
```{r}
library(grid)
p + my_theme

grid.text("Data sourse: The DistroWatch's Page Hit Ranking (Nov. 23, 2011)",
          x = 0.02, y = 0.01, just = c("left", "bottom"),
          gp = gpar(fontface = "bold", fontsize = 9, col = "white"))

grid.text("www.pingdom.com",
          x = 0.98, y = 0.01, just = c("right", "bottom"),
          gp = gpar(fontface = "bold", fontsize = 9, col = "white"))
```

# 3. R Markdown
## 3.1 Здравствуйте, я ваш R Markdown!
### 3.1.1 Введение
### 3.1.2 Установка пакета
```{r}
# install.packages("rmarkdown")
library(rmarkdown)
```

### 3.1.3 Что такое R Markdown и для чего он нужен
Языку `R` уже больше пятнадцати лет, а вот `rmarkdown` всего два года [^1]. Поэтому прежде чем погрузимся в детали `rmarkdown`, давайте прежде поймем что же это такое и для чего это нужно.

[^1]: На момент написания курса в 2016 году.

#### Общее определение `rmarkdown` 
Тут две ключевые идеи:

* **это средство для создания динамических документов, отчетов и презентаций**; важно понимать, что один и тот же исходный файл может служить основой для большого набора конечных файлов разных форматов
* **это инструмент для встраивания результатов исполнения кода на `R` в текст документа**; большое количество форматов, причем постоянно растущее

#### Зачем это нужно
Начнем с самого важного:

* **Для полной воспроизводимости результатов.** Как только мы скомпилировали отчет и у нас есть исходный текст отчета, мы можем его послать кому-то еще и результат полученный у нас будет воспроизводиться у всех
* **Для конвертирования исходного .Rmd файла в разные форматы:**
    + HTML
    + PDF
    + MS Word (ODT, RTF)
    + Markdown
    + Презентации: ioslides, reveal.js, Slidy, Beamer (первые три в HTML, последняя в PDF)
    + Шаблоны для web-сайтов
* **Для удобства написания, разметки и форматирования документа**
* **Для распространения открытого кода, идей, алгоритмов и результатов исследований**

#### Reproducible research и коллаборация
Небольшое лирическое отступление. 

* [Статья в Nature](http://www.nature.com/news/1-500-scientists-lift-the-lid-on-reproducibility-1.19970): более 70: опрошенных исследователей не могут воспроизвести результаты, полученные коллегам; они видят исходные данные, видят к чему это должно привести, но не могут воспроизвести шаги
* В последнее время ситуацитя ухудшается:
    + Растут объемы данных
    + Используются сложные схемы (пред)обработки данных
    + Применяемые алгоритмы требуют тонкой настройки
    + Форматы традиционной журнальной статьи не отвечает современным требованиям
* Это привело к появлению [Ropensci reproducibility guide](http://ropensci.github.io/reproducibility-guide/sections/dataSharing/) (кстати, вот хорошая [статья](http://vita.had.co.nz/papers/tidy-data.pdf) от Hadley Wickham])

### 3.1.4 Glacier Part 1

### 3.1.5 Встраивание кода
Есть два способа встроить результаты исполнения кода на `R` в `rmarkdown`:

#### Inline code
* Простейший случай: вставка результата **в виде текста** прямо в строку
* Синтаксис: backtik ("`") - "r" - пробел - кода на R - backtik
* Пример: "Теорема доказана в предположении, что число пи равно `` `r knitr::inline_expr('ceiling(pi)')` ``" [^2]
* Результат: "Теорема доказана в предположении, что число пи равно `r ceiling(pi)`"

[^2]: Как это сделано? Справка по функции `?knitr::inline_expr`.

#### Code chunks
* Основной способ вставки кода
* Каждый кусок (chunk, чанк) настраиваем с помощью опций
* Чанк может что-либо печатать, рисовать или вообще не иметь вывода

#### Синтаксис чанков
Чанк должен начинаться с новой строки. Затем идет три бэктика и в фигурных скобках пишем `r`. Потом с новой строки мы пишем код как обычно и закрываем чанк тремя бэктиками с новой строки. Вот как это выглядит:
```{r, echo = FALSE, comment = ""}
cat(c("```{r}",
      "head(iris)",
      "```"),
    sep = '\n')       # разделение путем переноса каретки на новую строку
```

После компиляции этого чанка мы получим две вещи:

* будет выведен исходный код (с подсветкой синтаксиса)
* и результат выполнения кода

```{r}
head(iris)
```

Весь вывод по умолчанию отделяется двумя хэштегами `##`. Это на тот случай, если случайно при копировании кода захватывается часть вывода; тогда он сойдет за комментарии и не будет исполняться. Это настраиввается в заголовке чанка при помощи опции `comment`.

#### Опция echo = FALSE
* В фигурных скобках через запятую можно указывать *опции* чанка
* По умолчанию печатается и код, и его результат
* Опция `echo = FALSE` подавит вывод кода:

```{r, echo = FALSE, comment = ""}
cat(c("```{r, echo = FALSE}",
      "(1:10)^3",
      "```"),
    sep = '\n')
```

```{r, echo = F}
(1:10)^3
```

И мы увидим только рузультат выполнения чанка. Само выражение `(1:10)^3` не будет напечатано. Это необходимо для того, чтобы спрятать некоторые детали вычислений. Например для специалистов не владеющих языком `R`. А те кто владеют, могут обратится к исходному файлу.

### 3.1.6 Вопрос
Помните древнегреческий миф про нимфу Эхо? Пока вы проходите этот тест, я пойду читать википедию: не помню, чем она так провинилась (возможно, злоупотребляла ассоциациями первого уровня).
Верно ли, что ...

* **по умолчанию echo=TRUE?**
* воспроизводимость результатов нужна только для академических исследований?
* **один и тот же исходный .Rmd файл может быть скомпилирован как в HTML, так и PDF?**
* **в RStudio есть проверка правописания?**

### 3.1.7 Glacier Part 2

### 3.1.8 Задача
Скачайте файл glacier.csv, если вы ещё этого не сделали, и познакомьтесь с ним поближе. Попробуйте выяснить, о каких ледниках идёт речь в тексте внизу. Можно работать непосредственно в консоли, а можно решать при помощи inline кода, который хорошо подходит в данном случае, если такой текст вы захотите включить в отчёт.

Среди шести изучаемых ледников самую короткую историю наблюдений имеет **Вопрос 1**. При этом ледник, для которого медианное значение изменения (переменная Value для Annual Mass Balance) наиболее близко к нулю, называется **Вопрос 2** . Единственное пропущенное значение содержит история наблюдений ледника **Вопрос 3**.

#### Решение
Для начала подгрузим датасет
```{r}
gl <- read.csv("glacier.csv", na.strings = "..", comment.char = "#")
```

##### Ответ 1
```{r}
gl %>% 
  group_by(GEO) %>%                                   # группируем по GEO
  summarise(Val = max(Ref_Date) - min(Ref_Date)) %>%  # схлопываем по новой переменной Val
  filter(Val == min(Val)) %>%                         # отфильтровываем минимальный
  select(GEO)                                         # выбираем только переменную GEO из полученной строки
```

##### Ответ 2
```{r}
gl %>%
  filter(MEASURE == "Annual mass balance") %>%   # фильтруем только Annual mass balance
  group_by(GEO) %>%                              # группируем по GEO
  summarise(M = median(Value, na.rm = T)) %>%    # схлопываем по новой переменной - медиане
  filter(abs(M) == min(abs(M))) %>%              # ищеи наиболее близкое к нулю (наимаеньший модуль)
  select(GEO)                                    # выбираем только название ледника
```

##### Ответ 3
```{r}
gl %>%
  filter(is.na(Value)) %>%   # отфильтровываем значение с NA 
  select(GEO)                # выбираем только GEO
```

## 3.2 Погружаемся в детали: R слева, markdown справа
### 3.2.1 Примеры разметок
Не трудно заметить, что словосочетание **R Markdown** состоит из двух слов **R** и **Markdown**. Пр **R** мы знаем -- это использование `inline code` и `chunk` в теле документа. А что такое **Markdown**? Вот на этот вопрос мы и будеи отвечать.

#### Зачем нужен Markdown
Для того чтобы разобраться откуда он взялся, нам необходимо сказать пару слов о таком понятии как **HTML**:

* HTML -- это набор инструкций для браузера; эта разметка предназначена для использования браузером
* Написание HTML-страниц в ручном режиме очень неудобно
* Markdown -- текстовый формат, удобный для написания и для чтения
* Markdown -- инструмент конвертации такого текста в HTML

Фишка Markdown -- его легко как писать так и читать (и человеку и машине).

#### Основные элементы Markdown
Как мы уже заметили, некоторые символы в Markdown получают дополнительное значение.

* `**Жирный** __шрифт__` --> **Жирный шрифт**
* `*Курсивный* _шрифт_`  --> *Курсивный шрифт*
* Моноширный шрифт `` `sum(x)` `` --> `sum(x)`
* Верхние и нижние индексы `A^2^~i~` --> A^2^~i~
* `~~Зачеркнутый текст~~` --> ~~Зачеркнутый текст~~
* Экранирование символов (escape): `\* \_ \\ \$` --> \* \_ \\ \$ 
* Автозамена тире и длинного тире: `-- ---` --> -- --- 
* Заголовки: `# Header 1` -- `###### Header 6`
* Гиперссылка: `<http://bash.im>` --> <http://bash.im>
* Гиперссылка в тексте: `[Этот курс](https://stepic.org/course/724)` --> [Этот курс](https://stepic.org/course/724)

#### Поддержка $\LaTeX$
$\LaTeX$ -- специальный математический движок для верстки и публикации работ, с большим кол-вом формул.

* Для сборки pdf нужна установка $\TeX$ (MiKTex -- для Windows, TeX Live -- для Linux, Mac OS)
* `$\hat{\beta} = (X^T X)^{-1} X^T y$` --> $\hat{\beta} = (X^T X)^{-1} X^T y$
* `$$i \hbar \frac{\partial}{\partial t} \Psi(\textbf{r},t) = \hat{H} \Psi (\textbf{r},t)$$` --> $$i \hbar \frac{\partial}{\partial t} \Psi(\textbf{r},t) = \hat{H} \Psi (\textbf{r},t)$$
* Полноценные возможности $\TeX$ (настройки, пакеты, макросы)
* Формулы корректно отображаются в HTML благодаря MathJax

### 3.2.2 Glacier Part 3

### 3.2.3 Вопрос
В синтаксисе markdown некоторые символы обретают новый смысл, благодаря чему .Rmd файл представляет собой так называемый rich text. Поэкспериментируйте с различными вариантами написания и посмотрите, что будет получаться (что будет, например, при вложении зачёркнутого текста в моноширинный?).
Кстати, в последнее время всё больше сайтов поддерживают markdown (по крайней мере частично) для написания постов и комментариев: например, github и stackoverflow.

### 3.2.4 Опции чанков
#### Сначала был knitr
История R Markdown началась с пакета `knitr`.

* Сейчас именно он отвественен за обработку кода на `R`
* Он может быть использован отдельно от R Markdown
* Изначальный фокус `knitr` -- pdf (LaTeX + R)

#### Chunk options
* Существуют глобальные настройки `knitr`
* Каждый чанк может иметь локальные настройки, переопределяющие глобальные
* Локальные настройки указываются через запятую и их может быть любое количество
* Все возможные опции приведены на <https://yihui.name/knitr/options/>

#### Основные опции
* **`echo` (default: `TRUE`)** -- отображать ли исходный код чанка?
* **`eval` (default: `TRUE`)** -- исполнять ли код чанка?
* **`include` (default: `TRUE`)** -- отображать ли результат чанка?
* **`error` (default: `FALSE`)** -- добавлять ли в документ текст ошибок?
* **`message` (default: `TRUE`)** -- добавлять ли в документ текст сообщений?
* **`warnings` (default: `TRUE`)** -- добавлять ли в документ текст предупреждений?
* **`comment` (default: `##`)** -- какой префикс добавлять перед каждой строкой вывода результата?
* **`results` (default: `markup`)** -- каким образом выводить результаты исполнения?
* **`highlight` (default: `TRUE`)** -- подсвечивать ли синтаксис кода?
* **`tidy` (default: `FALSE`)** -- отформатировать ли код (отступы, пробелы, переносы...)?

#### Графики
* **`fig.hight`, `fig.width`** -- размеры изображения (в дюймах)
* **`fig.align` (default: `default`)** -- расположение графика на странице; еще бывают `left`, `right`, `center`
* **`fig.cap` (default: `NULL`)** -- строка с подписью к графику

#### Кэширование чанков
* Некоторые чанки могут содержат длинные вычисления; и каждый раз при пересборке конечного файла прийдется долго ждать
* Для таких чанков нужно выставить `cache = TRUE`
* Кэш срабатывает в том случае, если содержимое кода внутри чанка не изменялось; если в одном чанке что-то изменилось, то он пересчитается и мы будем ждать завершения пересчета только один раз
* Важно: если чанки взаимосвязаны, нужно помнить о кэше!
* В этих случаях помолжет опция `dependson`
* Важное: некоторые алгоритмы используют генераторы случайных чисел!

#### Метки чанков
* В фигурных скобках между "r" и опциями чанка может находиться метка чанка
* Чанки могут ображаться друг к другу по меткам

```{r echo = F, comment = ""}
cat(c("```{r chunk1, echo = TRUE, result = 'hide'}",
      "cos(2*pi)",
      "```"),
    sep = "\n")
```

```{r echo = F, comment = ""}
cat(c("```{r chunk2, echo = FALSE, ref.lable = 'chunk1'}",
      "```"),
    sep = "\n")
```

```{r chunk1, echo=TRUE, results='hide'}
cos(2*pi)
```

```{r chunk2, echo=FALSE, ref.label="chunk1"}
```

Второй чанк обращается к первому. И первый чанк как бы неявно будет вызван вторым.

#### Глобальные опции
* Задаются, как правило, в начале документа (но могут меняться локально)
* `knitr::opts_chunk$set(echo = F, fig.width = 5, fig.height = 5)`
* Этот вызов удобно поместить в отдельный чанк с опцией `include = F`

### 3.2.5 Вопрос
Будьте бдительны: при неверном написании названия опции чанка не будет ни ошибок, ни предупреждений, просто опция не сработает. Особенно это касается опции cache (не путать с cash).

"If anything goes wrong, just remove that folder with cash, will you?"

Теперь, собственно, тест. Верно ли, что...

* LaTeX корректно поддерживается только при сборке в pdf?
* **при выставлении cache=TRUE кеш будет перестроен, если изменился код чанка?**
* **если опция чанка указана и глобально, и локально, то используется локальное значение?**
* глобальные опции R markdown задаются при помощи функции options?

### 3.2.6 Glacier Part 4
В чанке настроек можно внести вызов функции `options` [^3], с настройками чисел с плавающей точкой:
```{r echo = F, comment = ""}
cat(c("```{r setup, include = F}",
      "options(scipen = 0, digits = 3)",
      "```"),
    sep = "\n")
```

[^3]: Справка доступна здесь `?base::options`

Записать этот урок !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

### 3.2.7 Задача
Я работаю над написанием отчёта по составлению задач для нового курса под названием ["Анализ данных в R. Часть 2"](https://stepic.org/course/724). В начале документа я поставил такой чанк:

```{r echo = F, comment = ""}
cat(c("```{r setup, include=FALSE}",
      "knitr::opts_chunk$set(echo=FALSE, warning=FALSE, eval=FALSE)",
      "```"),
    sep = "\n")
```

Что я получу после компиляции документа, если добавлю теперь вот такой чанк?
```{r echo = F, comment = ""}
cat(c("```{r squares, eval=TRUE, cache=TRUE}",
      "1:4 ^ 2",
      "```"),
    sep = "\n")
```

#### Ответы:
* Код выведен не будет, напечатаются числа 1, 4, 9, 16.
* Будет выведен код, напечатаются числа 1, 4, 9, 16.
* Код не будет ни выведен, ни исполнен.
* Будет выведен только код, но исполнен он не будет.
* **Код выведен не будет, напечатаются все целые числа от 1 до 16.**
* Будет выведен только код, он будет исполнен, но результат не напечатается.

## 3.3 Зоопарк возможностей: форматы, pandoc, html
### 3.3.1 Очередность обработки
Давайте внесем ясность: какой инструмент в какой момент времени работает.

#### Как устроен R Markdown
Что происходит с исходным файлом .Rmd когда мы нажимаем кнопку `Knit`?

* **Исходный файл: .Rmd**
* **`knitr`: .Rmd --> .md** 
    + `knitr` находит чанки кода
    + исполняет их в соответствии с нашими инструкциями
    + собирает результаты исполнения кода на R
    + кладет все это в промежуточный .md-файл 
* **`pandoc`: .md --> .html, .docx, .tex**
    + `pandoc` преобразует Markdown разметку в один из трех форматов
* **`latex`: .tex --> .pdf**
    + `latex` преобразует промежуточный .tex-файл в .pdf-файл

#### YAML header
Как ранее мы уже поняли, R Markdown состоит из нескольких независимых инструментов. Конфигурировать эти инструменты по отдельности необходимо при помощи заголовка.

* В заголовке .Rmd-файла можно указывать различные опции, которые будут конфигурировать каждый из инструментов при последовательной сборке файлов.
* Опции задаются в особом формате (YAML) в виде списка ключей и значений

#### Конфигурация форматов
* Секция `output:` отвечает за формат конечного документа
* Каждый формат имеет собствнные настройки


```{r echo = F, comment = ""}
cat(c("output:",
      "  html_document:",
      "     toc_float: TRUE"),
    sep = "\n")
```

#### Параметры документа
Есть еще одна возможность. Эти параметры, находящиеся в YAML header'е могут быть дополнительно настраиваемы. Т.е. один и тот же исходный файл может быть основой для разнообразных отчетов. Это могут быть различные сценарии обработу данных; какие-то настройки алгоритмов; различные источники данных, которые могут то подключаться, то отключаться и т.д.

* Содержимое документа может зависеть от внешних параметров
* Это могут быть различные сценарии, настройки алгоритмов, имена файлови т.д.

Вот примерно такую запись можно поместить в хэдер:

```{r echo = F, comment = ""}
cat(c("params:",
      "  n: 100",
      "  d: !r Sys.Date()"),
    sep = "\n")
```

* Использование возможно через список `` `params` ``:  `` `r knitr::inline_expr('params$n')` ``

### 3.3.2 Glacier Part 5

### 3.3.3 Задача
Я задумал написать динамический отчёт, в котором будут математические формулы, участки кода на R и элементы markdown. 

В каком порядке расположены этапы получения конечного файла с готовым отчётом?
Порядок следования этапов -- сверху вниз, верхний идёт первым.

#### Решение

* Пишется текст документа со встроенным кодом на R (результат: файл .Rmd)
* Исполняется код на R, встраиваются текст или изображения (результат: файл .md)
* Обрабатываются элементы разметки markdown (результат: файл .html, .tex)
* Компилируются и отображаются элементы LaTeX (результат: файл .html, .pdf)

### 3.3.4 
#### HTML Tags
* Отсюда и далее говорим только об HTML (сборка в pdf остается за скобками)
* При сборке .Rmd разметка markdown заменяется HTML-тегами 
* Но эти теги можно использовать напрямую
* `<u>Подчеркнутый текст</u>`: <u>Подчеркнутый текст</u> (в R Markdown ет подчеркнутого текста)

#### CSS


